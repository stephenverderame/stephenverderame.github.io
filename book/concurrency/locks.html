<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Locks and Mutexes - Excursion through C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded "><a href="../intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="../guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="../basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="../basics/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="../oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../oop/overloads.html"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="../oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="../oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="../oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="../oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="../oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="../exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="../exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="../pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="../pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="../pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="../pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="../pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="../move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="../move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="../move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="../templates/intro.html"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="../templates/concepts.html"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="../templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="../templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="../templates/variadic.html"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="../templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="../functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functional/lambdas.html"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="../functional/functional_types.html"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="../functional/algorithm.html"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="../more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="../more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="../more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="../more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="../more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/locks.html" class="active"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="../concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="../concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="../concurrency/atomic.html"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="../concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="../cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="../testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="../testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="../testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="../testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="../testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="../testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="../design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="../resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mutexes-and-locks"><a class="header" href="#mutexes-and-locks">Mutexes and Locks</a></h1>
<p>&quot;Shared state is broken state&quot;<sup class="footnote-reference"><a href="#1">1</a></sup>.
If you have two threads reading from the same piece of memory, that's fine, but if you have one reading while another is writing you can get tons of issues.
Firstly, the reading thread might not read a completely changed value on an object (ie. halfway between changing an integer) then for larger data types like classes,
a reading thread might only read some new values (ie. say the first boolean and integer, but not the last string).
Therefore, we need a way to synchronize multiple data accesses on the same data.</p>
<p>First, what exactly is an object? The standard defines it as a &quot;region of storage&quot;.
An object is stored in one or more memory locations and can consist of sub-objects.
For example, a struct is an object where each member is a sub-object (with possibly sub-sub-objects).
Adjacent bit-fields are their own object but share a memory location.
However, zero length bit-fields break up the adjacency and separate bit-fields into different memory locations.
Each variable is an object, and variables of fundamental or primitive types, no matter their size, take up exactly one memory location.
Multiple threads can safely and concurrently access different memory locations.</p>
<pre><code class="language-C++">struct A {
    int a; //obj
    bool b; //obj
    char c; //obj
    unsigned long d : 24, e : 8; 
    //two objs in same mem location
    unsigned spacer : 0;
    char f : 4, g : 4; 
    //2 objs same mem
}
</code></pre>
<p>Each object has a modification order, or the sequence of reads and writes that occur to it.
All threads must agree upon the modification order of a single object, but they don't have to agree on the modification order of an object relative to another.</p>
<h3 id="thread-local"><a class="header" href="#thread-local">Thread Local</a></h3>
<p>Sometimes you don't want shared state.
For those times you have the <code>thread_local</code> storage modifier.
Thread local variables are each unique to their own thread, and must also be static.
You don't need to synchronize on thread-local storage because each thread has their own copy.</p>
<pre><code class="language-C++">class Bar {
private:
    static thread_local int localInt;
public:
    void doFoo() {
        // perform a computation with localInt
        // no synchronization needed
    }

}
</code></pre>
<p>If you can, avoid shared state.
It slows down concurrent applications (now they must serially access the state) and is harder to reason about.</p>
<p>I won't dive into the details, but two architectures of concurrency without shared state are Actors aka CSP, and Blackboards.
For the actor model, think of each thread as its own actor. Each actor can only communicate to other actors via a one way messaging system.
As messages come, an actor processes it to completion and has an internal state machine. 
For the backboard model, think of a bunch of investigators working on a case.
Each thread can put information on the blackboard and all other threads can process the information and add more to the blackboard.
Information comes in any order, and the threads have no knowledge about each other.</p>
<h2 id="mutexes"><a class="header" href="#mutexes">Mutexes</a></h2>
<p>Of course things aren't always as peachy as being able to avoid shared state.
When those times come, you must enforce a modification order between objects.
If you don't, you have a <em>race condition</em> where one thread is racing another to access the state. </p>
<p>One tool to avoid that are mutexes which stand for MUTually EXclusive. Mutexes basically enforce
serial access to pieces of data. Threads lock a mutex before executing instructions that cannot be completed by multiple threads
at once. Once a thread has obtained the lock, other threads that try to lock the mutex must wait until the
thread that has the mutex releases it. When a thread is done with a mutex, it must release it so other threads
can acquire it and execute the code the mutex protects.</p>
<p>In C++, we have <code>std::mutex</code>. I'm not even going to enumerate the member functions of a mutex because you should basically never use it directly.
Instead, you want to wrap it in a class such as <code>std::lock_guard&lt;&gt;</code> or <code>std::scoped_lock&lt;&gt;</code>.
A lock guard is the simplest RAII object for a mutex.
When it's constructed it locks immediately and won't unlock until its destroyed.
It's neither moveable or copyable, it simply guards a piece of code that uses shared state.
Its lack in functionality is made up for by being lightweight.</p>
<pre><code class="language-C++">std::mutex mu;
std::queue&lt;char&gt; sharedState;

void workerThread() {
    while(/* do work */){
        std::lock_guard&lt;std::mutex&gt; lk(mu);
        if(!sharedState.empty()){
            auto c = sharedState.front();
            sharedState.pop();
            // process it
        }
    }
}
std::thread t1(&amp;workerThread);
std::thread t2(&amp;workerThread);
std::thread t3([&amp;mutex, &amp;sharedState](){
    while(/* do work*/){
        auto c = //compute c
        std::lock_guard&lt;std::mutex&gt; lk(mutex);
        sharedState.push(c);
    }
});
</code></pre>
<p>Now looking at the code, we see that in the worker thread, we process the data while still holding the lock. What if that takes a long time? Could we fix it by doing this?</p>
<pre><code class="language-C++">void workerThread(){
    bool empty = false;
    {
        std::lock_guard&lt;std::mutex&gt; lk(mu);
        empty = sharedState.empty();
    }
    if(!empty){
        {
            std::lock_guard&lt;std::mutex&gt; lk(mu);
            //front and pop
        }
        // process as before
    }
}
</code></pre>
<p>Let's say that we take the lock and store the value <code>false</code> from the call to <code>empty()</code> into the local variable <code>empty</code>.
After releasing the lock, let's say that another thread pops off the last element of the stack.
Now when the first thread goes to pop an element off the stack, it will find that it's already empty!
In general, we want to use locks to make operations like this atomic, so a thread can't be interrupted when its doing this.
Moreover, in general we want to hold a lock for as narrow of a scope as possible, and as little time as possible.
However, as shown in the above example, we can't lock on too fine of a scale so that single operations can be interrupted by other threads.</p>
<p><code>scoped_lock&lt;&gt;</code> is pretty much exactly like <code>lock_guard</code>, however <code>scoped_lock</code> allows locking multiple mutexes at the same time.
Generally, <code>std::scoped_lock</code> should be preferred to <code>std::lock_guard</code>.</p>
<pre><code class="language-C++">std::mutex m1, m2;

{
    std::scoped_lock lk(m1, m2);
    // compiler deduces themplate type
    // full definitions is:
    // std::scoped_lock&lt;std::mutex, std::mutex&gt; lk(m1, m2);
}
</code></pre>
<p>Let's look at a more powerful lock. <code>std::unique_lock</code> can be unlocked and re-locked and it can be moved. </p>
<pre><code class="language-C++">std::unique_lock&lt;std::mutex&gt; lk(mu, std::lock_deferred);
// don't lock on construction
lk.lock(); //lock it.
//OR std::lock(lk);

if(!sharedState.empty()){
    auto c = sharedState.front();
    sharedState.pop();
    lk.unlock(); //unlock
    // process it
}
</code></pre>
<p><code>std::lock()</code> allows locking two locks at the same time. 
Using <code>std::unique_lock</code>, we're able to easily lock the mutex,
check if the shared stack isn't empty and if it isn't, pop the top of the stack,
then finally unlock the lock to perform processing without inhibiting other threads
from processing elements separately.</p>
<p>You don't have to worry about forgetting to unlock a <code>std::unique_lock</code> since <code>std::unique_lock</code> will unlock itself during destruction.</p>
<pre><code class="language-C++">std::mutex m1, m2;

std::lock(m1, m2);
// lock m1 and m2 atomically together
std::lock_guard&lt;std::mutex&gt; lk1(m1, std::lock_adopt);
// take over an already locked mutex
std::lock_guard&lt;std::mutex&gt; lk2(m2, std::lock_adopt);

// OR

std::unique_lock&lt;std::mutex&gt; lk3(m1, std::lock_deferred), lk4(m2, std::lock_deferred);
std::lock(lk3, lk4);

//OR even better

std::scoped_lock lk(m1, m2);

// lock on construction
std::unique_lock&lt;std::mutex&gt; lk5(m1);
</code></pre>
<p>Note: Although I show them all in the same code sample, you <strong>cannot</strong> lock an already locked mutex.
<code>std::mutex</code> is <strong>not</strong> reentrant.</p>
<p>Notice how these RAII objects are templates.
That sort of implies that there is more than one type of mutex. </p>
<p>We also have the <code>std::shared_mutex</code>. 
A shared mutex allows threads to access data concurrently by using a <code>std::shared_lock</code>, and will only allow exclusive access using a <code>std::unique_lock</code>.
This is commonly referred to as a <em>reader-writer</em> locks because typically you have a group of threads safely reading data at the same time,
and one thread writing data exclusively. This is used in data structures where the usage pattern is to commonly read and infrequently update data.</p>
<pre><code class="language-C++">/**
* Calculates an id based on the current msg count and 
* the thread id of the calling thread
* Since we're only working with 1 byte, there can 
* only be max 32 threads to one msg formatter 
* and only 8 writes before a read per thread
* @return unique id for the message
*/
uint8_t calcId(std::atomic&lt;uint8_t&gt;&amp; counter) {
    static std::map&lt;std::thread::id, uint8_t&gt; threadIds;
    static std::shared_mutex threadIdMu;
    // shared mutex
    static uint8_t idCounter = 0;
    
    auto index = counter++ % 8;
    uint8_t id = index &lt;&lt; 5;
    std::shared_lock lk(threadIdMu);
    // lock for reading

    auto it = 
        threadIds.find(std::this_thread::get_id());
    if (it != threadIds.end()) {
        // common case
        id |= it-&gt;second;
    }
    else {
        // rare case

        lk.unlock(); //unlock reading
        std::unique_lock lk2(threadIdMu);
        // lock for writing

        threadIds.emplace(std::this_thread::get_id(), 
           static_cast&lt;uint8_t&gt;(idCounter));
        id |= (idCounter++ &amp; 0b11111);
    
    }
    return id;
}
</code></pre>
<p>As you can see, we use <code>std::unique_lock</code> to get exclusive access and write to the map and <code>std::shared_lock</code> to get shared access read from the map.
Shared locks have the same semantics as <code>unique_lock</code>, except for being shared access of course.
When a thread wants to get exclusive access, it blocks other threads from locking the mutex for either shared or exclusive access, waits for all in-progress operations to stop, then
performs the operation and unlocks th lock. Threads waiting for the exclusive lock get priority. So then what happens if we have more threads looking for exclusive access than shared access? 
Well, we can end up with a situation known as
<em>starvation</em> where threads continually acquire the exclusive lock leaving threads waiting for the shared lock for a long time. Thus, it's important such locks be used in situations
where shared access is the common case and exclusive access happens less frequently.</p>
<p>Earlier I mentioned reentrant locks. Let's see that in C++. C++ has <code>std::recursive_mutex</code> which allows one thread to lock the mutex multiple times
and requires the thread to unlock it the same amount of times it has locked it. Think of this as basically allowing nested locks within a single thread.</p>
<pre><code class="language-C++">class Foo {
    std::recursive_mutex mu;
public:
    void stuff() {
        std::lock_guard&lt;std::recursive_mutex&gt; lk(mu);
        // do some stuff
    }
    void moreStuff() {
        std::lock_guard&lt;std::recursive_mutex&gt; lk(mu);
        // complex stuff
        stuff();
    }
}
</code></pre>
<p>We have some code reuse here, which is great. Unfortunately, if we were to use a normal <code>std::mutex</code>, this code would deadlock because when we call <code>stuff()</code> from <code>moreStuff()</code>,
we'd be waiting for a lock, yet we already have the lock!
Basically, the thread would be waiting for itself to give up the lock, yet it won't give up the lock because it's waiting for a lock.
<code>std::recursive_mutex</code> avoids this problem, and you see we can happily implement <code>moreStuff()</code> in terms of <code>stuff()</code>.</p>
<p>Speaking of waiting, as I mentioned earlier, when you lock a mutex, you wait for it to become available if you don't have it.
What if you don't want to wait if it's not available, or at least not wait too long? We can use a
<code>std::timed_mutex</code> or <code>std::recursive_timed_mutex</code>! When using these, our RAII wrappers will be able to be able to use the member functions <code>try_lock()</code>,
<code>try_lock_for()</code>, and <code>try_lock_until()</code>. After a call to such functions, we can query if we obtained the lock with the member <code>owns_lock()</code>.
This allows us to avoid blocking (<code>try_lock()</code>), or avoid blocking for long periods of time.</p>
<pre><code class="language-C++">using namespace std::chrono_literals;
std::timed_mutex mu;

std::unique_lock&lt;std::timed_mutex&gt; lk(mu, std::lock::deferred);
lk.try_lock_for(500ms); //wait 500ms if not available

if(lk.owns_lock()){
    //exclusive access
}
</code></pre>
<h3 id="once-flag"><a class="header" href="#once-flag">Once Flag</a></h3>
<p>Let's say you need to call some code once. It seems overkill to have a boolean flag, and a mutex to protect it. That's why we have <code>std::call_once</code>.</p>
<pre><code class="language-C++">std::once_flag once;

std::call_once(once, []() {
    //execute this once
});
// pass the once_flag and a callable object to std::call_once
</code></pre>
<h3 id="deadlock"><a class="header" href="#deadlock">Deadlock</a></h3>
<p>I mentioned deadlock before, it's basically where no progress is made because one thread is waiting for another, but that thread is waiting for the first thread. More formally, deadlock occurs when all of the following conditions are met:</p>
<ul>
<li>Bounded Resources - we have a limited number of resources that many threads may try to access.</li>
<li>No preemptions - a thread must wait for another thread to finish before taking the resource. Basically, threads are not stopped or interrupted during the time that is has the resource.</li>
<li>Hold and Wait - a thread holding a resource waits for another resource.</li>
<li>Circular Waiting - there exists a cycle in a resource acquisition graph. For example, thread <code>A</code> waits for <code>B</code>, who waits for <code>C</code>, who waits for <code>A</code>.</li>
</ul>
<p>Typically Bounded Resources and No Preemptions are not conditions we can do much about, so most strategies at avoiding deadlock aim to prevent Hold and Wait and Circular Waiting from occuring at the same time.</p>
<p>Here are some guidelines to avoid deadlock:</p>
<ul>
<li>
<p>Use <code>std::lock()</code> or <code>std::scoped_lock&lt;&gt;</code> if you need to acquire multiple locks together</p>
</li>
<li>
<p>Avoid nested locks</p>
</li>
<li>
<p>Avoid calling user supplied code when holding a lock. This could possible lead to nested locks, since we don't know what that code does</p>
</li>
<li>
<p>Always acquire and release locks in the same order</p>
</li>
<li>
<p>Use a lock Hierarchy</p>
<p>A Hierarchical lock is one which enforces an ordering. You can only lock locks going up (or down) the hierarchy.
You can google for a simple implementation of one.</p>
</li>
</ul>
<p>Deadlock and proper locking granularity are very simple concepts to describe,
but takes practice in order to identify and write code that considers both issues.
Thus, I'm going to refer you to C++ Concurrency in Action for more information.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Professor Myers</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../concurrency/threads.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../concurrency/cond_var.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../concurrency/threads.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../concurrency/cond_var.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
