<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Atomics - Excursion through C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded "><a href="../intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="../guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="../basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="../basics/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="../oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../oop/overloads.html"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="../oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="../oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="../oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="../oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="../oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="../exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="../exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="../pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="../pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="../pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="../pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="../pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="../move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="../move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="../move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="../templates/intro.html"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="../templates/concepts.html"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="../templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="../templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="../templates/variadic.html"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="../templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="../functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functional/lambdas.html"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="../functional/functional_types.html"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="../functional/algorithm.html"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="../more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="../more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="../more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="../more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="../more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/locks.html"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="../concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="../concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="../concurrency/atomic.html" class="active"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="../concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="../cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="../testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="../testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="../testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="../testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="../testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="../testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="../design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="../resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="atomics"><a class="header" href="#atomics">Atomics</a></h1>
<p>Do you remember how I said we can have a situation where an integer is half-updated?
Well that's because normal read and writes are not atomic.
When something is atomic, it is basically an indivisible operation. An atomic operation is either fully completed, or not started.
Which means it forces some kind of modification order between threads. For most primitive types, atomic data types are lock free,
that is they are implemented using purely atomic operations provided by the ISA (Instruction Set Architecture, think of this as the API the hardware provides to software).
This isn't always the case and sometimes they are implemented via locks. You can call the <code>is_lock_free()</code> member function to determine this at runtime.
The <code>is_always_lock_free</code> static constant will tell you at compile time if the atomic is lock free on all supported architectures for the compiler.</p>
<p>One atomic type that is <strong>always</strong> lock-free is <code>std::atomic_flag</code>.
It's extremely primitive and only offers two functions: <code>clear()</code> and <code>test_and_set()</code>. <code>clear()</code> sets the flag to &quot;false&quot;, and <code>test_and_set()</code>
will return the last value of the flag and set it to &quot;true&quot;. That's it.
Now, as simple as it is, this is enough to provide a synchronizes-with relationship between two threads.
Remember, a synchronizes-with relationship allows any updates prior to the synchronization point on thread <code>A</code> to be
visible to thread <code>B</code> after the synchronization point.</p>
<pre><code class="language-C++">std::atomic_flag flag;
void processor() {
    while(true) {
        if(!flag.test_and_set()){
            auto val = data.front();
            data.pop_front();
        }
    }
}
void producer() {
    while(true) {
        data.push_back(/*data*/);
        flag.clear();
    }
}
</code></pre>
<p>This is very similar to our barrier example.
The processor will never read data from the front unless the flag is false.
The producer will never set the flag to false unless there is data on the queue.
Thus, it is perfectly safe to access the queue without a lock.
We say that such synchronization forces each thread to recognize the changes made in the other prior to the synchronization.
In this case the processor must recognize changes the producer made to the queue prior to the producer clearing the flag.
I'll talk about this more in the next chapter, but each core has their own cache.
Synchronization like this forces a core to update their cache with the new data from another processor's cache.
This is how objects can have different relative modification orders to each other according to different threads.
Let's say thread <code>A</code> updates value <code>a</code> to 3, then 5, and 6. Then thread <code>B</code> updates value <code>b</code> to 20, then 30 then 40.
Both threads will see <code>a -&gt; 3 -&gt; 5 -&gt; 6</code> and <code>b -&gt; 20 -&gt; 30 -&gt; 40</code>.
However, the relative ordering (ie. <code>a -&gt; 5</code> before or after <code>b -&gt; 20</code>) will differ depending on the memory ordering used. 
I'm going to only discuss the strictest (and default) memory ordering: sequentially consistent but there are others.
Sequentially consistent memory ordering enforces a total ordering.
So with <code>std::seq_cst</code> we can ask if <code>a \to 5</code> happened before <code>b \to 20</code> and get an answer.
On other orderings such an inquiry is moot because each thread will have a different answer to that question.</p>
<p>So let's look at some more useful atomic types. The most basic operations on atomic types are <code>store()</code>, <code>load()</code>,
<code>exchange()</code>, <code>compare_exchange_strong()</code>, and <code>compare_exchange_weak()</code>. <code>store()</code> and <code>load()</code> are rather self-explanatory.
<code>exchange()</code> will return the old value and store a new value that's passed to it as a parameter. We call these RMW (read-modify-write) operations.
<code>compare__exchange</code>. isn't going to be very important to our discussion here, but they are vital for the development of lock free data structures. 
<code>compare_exchange_weak(expected, desired)</code> will compare <code>expected</code> with the value of the atomic, if they are equal, then <code>desired</code> will be stored.
If they are unuequal, <code>expected</code> will be updated with whatever is currently stored in the atomic.
Equality is tested by byte-wise comparisons such as <code>memcmp</code>. It <strong>will not</strong> use any form of overloaded <code>==</code> if your type provides own.
Given this, floats and doubles may lead to <code>compare_exchange</code> returning improper results due to slight differences in representation of the same number.
<code>compare_exchange_weak()</code> will also fail if the exchange cannot be guaranteed to be atomic.
This happens if the ISA does not have an atomic <code>compare_exchange</code> instruction, and the scheduler interrupts the thread.
This is known as a <em>spurious failure</em>.
<code>compare_exchange_strong</code> is guaranteed to return <code>false</code> only if expected was not equal to the current value in the atomic.
Internally, it uses a loop on <code>compare_exchange_weak</code>. <code>std::atomic&lt;&gt;</code> is a template class. Here's the same flag implementation, but this time with <code>std::atomic&lt;bool&gt;</code>.</p>
<pre><code class="language-C++">std::atomic&lt;bool&gt; flag = false;
//initialize to false
void processor(){
    while(true) {
        if(flag.load()){
            auto val = data.front();
            data.pop_front();
        }
    }
}
void producer() {
    while(true){
        data.push_back(/*data*/);
        flag.store(true);
        flag = true;
        // overloaded operator=()
    }
}
</code></pre>
<p>Because atomic variables, are, well atomic, no locking or synchronization mechanism is needed to access them from multiple threads.</p>
<pre><code class="language-C++">std::atomic&lt;int&gt; count = 0;
void processor(){
    while(count.load() &lt; 500){
        ++count;
        // overloaded ++
    }
}
std::thread t1(&amp;processor), t2(&amp;processor);
</code></pre>
<p>This isn't a particularly useful code sample, but it does show how numerical types
have <code>++</code> and <code>--</code> both postfix and prefix versions overloaded. Instead of <code>++</code> and <code>--</code>, we also have the functions <code>fetch_add()</code>, <code>fetch_sub()</code>, <code>fetch_and()</code> etc.
Numerical atomics also overload <code>+</code>, <code>+=</code> and other arithmetic functions.</p>
<p>Finally, atomic also has free functions for each member function.
For example <code>std::atomic_load()</code>. They are specialized for each primitive atomic type and also for <code>std::shared_ptr</code>.
However, now there is <code>std::experiemental::shared_ptr</code> and in C++20 we can use <code>std::atomic&lt;std::shared_ptr&gt;&gt;</code>.</p>
<p>In C++20, we also have the <code>std::atomic_ref</code>.
The interface is exactly the same as any other atomic type, but it is constructed from an existing lvalue reference.
Once an <code>atomic_ref</code> is created, access to that object must be exclusively through <code>atomic_ref</code> instances. </p>
<p>Here's a very basic example</p>
<pre><code class="language-C++">template&lt;typename T&gt;
class lock_free_stack
{
private:
    struct node
    {
         T data;
         std::atomic&lt;std::shared_ptr&lt;node&gt;&gt; next;
         node(T const&amp; data_): data(data_) {}
    };
    std::atomic&lt;shared_ptr&lt;node&gt;&gt; head;
public:
    void push(T const&amp; data)
    {
        auto const new_node = 
            std::make_shared&lt;node&gt;(data);
        new_node-&gt;next = head.load();
        // another thread could change head here
        while(!head.compare_exchange_weak(new_node-&gt;next, new_node));
        /* 
        while head != new_node-&gt;next:
            update new_node-&gt;next to be head
        when head == new_node-&gt;next, set head to be new_node
        */
    }
    void pop(T&amp; result)
    {
         auto old_head = head.load();
         while(
            !head.compare_exchange_weak(old_head,old_head-&gt;next));
            result = old_head-&gt;data;
    }
</code></pre>
<p>When we push something, we first set the new node's next pointer to whatever the head is.
Then, we keep checking to make sure <code>head</code> hasn't been updated by checking that our new node's next pointer is still the head pointer.
If it is, then <code>head</code> is atomically set to <code>new_node</code>.
If <code>head</code> has changed and is no longer <code>new_node-&gt;next</code>, then we update <code>new_node-&gt;next</code> and try again.</p>
<p>To pop from the stack, we follow a similar process.
We first get a copy of head.
Then, as long as <code>head</code> hasn't changed, we atomically set <code>head</code> to whatever it is pointing to next.
If <code>head</code> has changed, then we update <code>old_head</code> and try again.
Notice we have an output parameter.
This is an over generalization, but generally speaking for pop operations such as this we have two options.
Return by reference via output parameter or make the user pass a smart pointer. The reason is that a copy operation can throw.
Moreover, when we return by smart pointer (whose copy cannot throw), we could not allocate the smart pointer in <code>pop()</code> because the allocation can fail.</p>
<p><code>std::atomic&lt;shared_ptr&lt;T&gt;&gt;</code> does not make accesses of the underlying data thread safe, but it makes changing the actual pointer value thread safe. </p>
<p>Lock free data structures are generally hard to design and even harder to get right, so only go for it if it is <strong>necessary</strong>.
They're even harder when we relax the memory ordering and start using relaxed or acquire-release memory ordering instead of sequentially consistent.
As far as I know however, x86 only supports sequentially consistent memory ordering.</p>
<p>Here's a common issue with lock-free data structures known as the <em>ABA</em> problem. Consider:</p>
<ol>
<li>Thread 1 reads a value <code>A</code> from a variable. Then Thread 1 does something to <code>A</code> (such as dereference it).</li>
<li>Thread 1 is stalled</li>
<li>Thread 2 performs an operation changing the variable's value to <code>B</code>. Another thread does something based on the new value <code>B</code> so that it invalidates <code>A</code> (such as freeing <code>A</code>)</li>
<li>Another thread then changes the value back to <code>A</code> based on the new data (such as a new pointer with the same address)</li>
<li>Thread 1 resumes, uses a <code>compare_exchange</code> to find that the value is still <code>A</code> (although now it's a different <code>A</code>), and continues on with invalid data.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../concurrency/async.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../concurrency/consider.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../concurrency/async.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../concurrency/consider.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
