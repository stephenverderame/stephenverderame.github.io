<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concepts and Type Traits - Excursion through C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded "><a href="../intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="../guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="../basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="../basics/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="../oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../oop/overloads.html"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="../oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="../oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="../oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="../oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="../oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="../exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="../exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="../pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="../pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="../pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="../pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="../pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="../move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="../move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="../move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="../templates/intro.html"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="../templates/concepts.html" class="active"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="../templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="../templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="../templates/variadic.html"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="../templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="../functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functional/lambdas.html"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="../functional/functional_types.html"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="../functional/algorithm.html"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="../more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="../more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="../more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="../more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="../more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/locks.html"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="../concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="../concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="../concurrency/atomic.html"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="../concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="../cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="../testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="../testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="../testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="../testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="../testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="../testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="../design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="../resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="concepts-and-type-traits"><a class="header" href="#concepts-and-type-traits">Concepts and Type Traits</a></h1>
<p>In C++20, concepts and constraints are a direct language feature.
However, the idea of a concept has long existed before then. Consider the following function:</p>
<pre><code class="language-C++">template&lt;typename T, typename U&gt;
U sum(const T&amp; container, U initialValue) {
    // another example of making the compiler do the copy for us
    for(auto e : container) {
        initialValue += e;
    }
    return initialValue;
}
</code></pre>
<p>What is required from <code>T</code> and <code>U</code>? Well <code>U</code> needs to define <code>operator+=</code>, and that operator must take a <code>U</code> as the first parameter and whatever type is returned from dereferencing an iterator to <code>T</code>. 
<code>T</code> must be iterable by defining a <code>begin()</code> and <code>end()</code> function and that iterator must return a type that is implicitly convertible to <code>U</code> or <code>U</code> must provide an overload of <code>operator+=</code> 
so that it takes whatever is &quot;contained&quot; in <code>T</code>. These requirements form the <em>concepts</em> that <code>T</code> and <code>U</code> must implement.</p>
<p>Templates allow for generic programming and <em>parametric polymorphism</em>, which allows a single code implementation to be used with multiple classes.</p>
<p>Earlier I discussed how the types passed to our <code>LList&lt;T&gt;</code> class needed to be default constructable and copyable. 
These are two major criteria for the <em>Regular</em> concept which among being default constructable and copyable also needs to be comparable with <code>==</code> and <code>!=</code>.</p>
<p>The <code>type_traits</code> header provides many helpers to query types or the adherence of a type to a certain quality. 
Traits that end in <code>_v</code> &quot;return&quot; values, and those that end in <code>_t</code> &quot;return&quot; types. 
These &quot;helpers&quot; are not actually functions but rather template <code>constexpr</code> variables or type aliases in <code>struct</code>s. Therefore, the results of these queries are available at compile time.</p>
<pre><code class="language-C++">std::is_default_constructable_v&lt;std::string&gt;; // true
// is_default_constructable is a template struct
// so the above is shorthand for:
std::is_default_constructable&lt;std::string&gt;::value;

std::is_fundamental_v&lt;char&gt;; // true
std::is_arithmetic_v&lt;int&gt;; // true
std::is_same_v&lt;int, const int&gt;; // false
std::is_floating_point_v&lt;long long&gt;; // false
std::is_signed_v&lt;unsigned&gt;; // false

std::rank_v&lt;int(&amp;)[3]&gt;; // 1 - dimensions of array type

std::is_base_of_v&lt;Base, Derived&gt;; // true

using typ = std::remove_cv_t&lt;const bool&gt;; // bool
// once again, shorthand for
std::remove_cv&lt;const bool&gt;::type;

enum class myEnum {}
std::underlying_type_t&lt;myEnum&gt;; // int
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/header/type_traits">cppreference</a> has a list of all of them.
Now how do these work? I won't explain the full story just yet, but they can use template specialization behind the scenes.
Let's create a simple <code>is_bool</code> type trait.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
struct is_bool {
    inline constexpr static auto value = false;
    // inline so redefinitions are allowed in a program
};

template&lt;&gt;
struct is_bool&lt;bool&gt; {
    inline constexpr static auto value = true;
};

template&lt;typename T&gt;
inline constexpr auto is_bool_v = is_bool&lt;T&gt;::value;
</code></pre>
<p><code>is_bool</code> is specialized so that when <code>T</code> is <code>bool</code> its <code>value</code> member will be true. Now what about <code>const bool</code> or <code>bool&amp;</code> or <code>const bool&amp;</code>? 
Since these are distinct types from <code>bool</code>, they'll fall into the unspecialized version of <code>is_bool</code> and <code>value</code> will be false. 
One solution would be to pass the argument into <code>std::remove_reference_t</code> and <code>std::remove_cv_t</code> prior to passing it to <code>is_bool_v</code>.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
using strip_t = std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;;
// order matters here, remove_cv removes the top level const and volatile qualifiers

remove_cv_t&lt;int * const volatile&gt;; // int* because const and volatile apply to the pointer
remove_cv_t&lt;const volatile int *&gt;; // const volatile int * because const and volatile apply to the data

is_bool_v&lt;strip_t&lt;const bool &amp;&gt;&gt;; // true
is_bool_v&lt;const bool&gt;; // false

template&lt;typename T&gt;
inline constexpr auto is_bool2_v = std::is_same_v&lt;T, bool&gt;;
</code></pre>
<p>There's a bunch more type traits in the STL that can be found <a href="https://en.cppreference.com/w/cpp/header/type_traits">here</a>. 
Now that we have these traits, the most basic approach to enforcing adherence of template parameters to a concept is with <code>static_cast</code>.</p>
<pre><code class="language-C++">template&lt;typename T, typename U, typename V&gt;
V sum(T a, U b) {
    static_cast(std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;,
        &quot;Sum passed non arithmetic types&quot;);
    return a + b;
}
</code></pre>
<p>This incurs no runtime penalty since the check happens during compilation.</p>
<p>A better approach is to use <code>std::enable_if_t</code>. As the name might suggest, the main usage of this is to conditionally enable functions. 
How this works is by replacing the entire statement with the second template type parameter
if the first template parameter evaluates to a true condition at compile time. 
Then you can specify the return type of the function to be an <code>enable_if_t</code> expression. 
If the function is called with template parameters that make the condition true, all is well since the return type will be the second template argument to
<code>std::enable_if_t</code>. Otherwise, the <code>enable_if</code> effectively prevents the instantiation of the function template causing the compiler to complain that the function doesn't exist. 
Not as clear as an error message as you'd get in C++ 20 with concepts and constraints, but trust me it's far nicer than some monstrosities you might receive without it.
You can omit the second type parameter to <code>enable_if</code>, in that case it defaults to <code>void</code>.</p>
<p>The default type for the second template argument is <code>void</code>. </p>
<pre><code class="language-C++">template&lt;typename T, typename U&gt;
constexpr inline auto are_arithmetic_v = std::is_arithmetic_v&lt;strip_t&lt;T&gt;&gt; &amp;&amp; 
    std::is_arithmetic_v&lt;strip_t&lt;U&gt;&gt;;

template&lt;typename T, typename U, typename V&gt;
std::enable_if_t&lt;are_arithmetic_v&lt;T, U&gt;, V&gt;
sum(T a, U b) {
    return a + b;
}
// sum returns type V if `are_arithmetic_v&lt;T, U&gt;` is true


// same thing with trailing return type
template&lt;typename T, typename U, typename V&gt;
auto sum2(T a, U b) -&gt; std::enable_if_t&lt;are_arithmetic_v&lt;T, U&gt;, V&gt;
{
    return a + b;
}
/*
This is not type deduction, the auto doesn't mean auto like normal
but instead its syntax for trailing return type
the return type of the function is specified after it using a -&gt;
allows the parameters to be used in the return type
*/
</code></pre>
<p>A trailing return type is most useful with <code>decltype()</code> which &quot;returns&quot; the type of the expression passed to it. 
The expression passed is not evaluated, but instead the compiler figures out what the type of the expression is and replaces the <code>decltype</code>
expression with this type during compilation. 
Thus, it incurs no runtime penalty.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
auto getIter(const T&amp; container) -&gt; decltype(container.begin()) {
    return container.begin();
}
// Of course the trailing return type here isn't necessary

template&lt;typename T&gt;
auto getIter(const T&amp; container) {
    decltype(*container.begin()) acc = 0;
    // auto will deduce to int, but we want the type to be whatever container holds
    for (e : container) {
        acc += e;
    }
    return acc;
}
</code></pre>
<p>So how does all this work? By a language feature known as <em>SFINAE</em> which stands for specialization failure is not an error. 
Basically, if instantiating a template causes an error, the compiler will look for another template specialization.
If no other template is found, it complains that it can't find the class or function.</p>
<p>I think it's best to start with an example.</p>
<pre><code class="language-C++">template&lt;typename T, typename = void&gt;
struct SFINAE : std::false_type {};
// primary definition
// 2 template arguments, the second is unnamed and defaulted to void

template&lt;typename T&gt;
struct SFINAE&lt;T, std::void_t&lt;typename T::type&gt;&gt; : std::true_type {}; 
// 1 template argument specialization
// instantiates if T has a member type alias called type

enum e {};

static_assert(SFINAE&lt;std::underlying_type&lt;e&gt;&gt;::value); 
//good (second declaration) bc std::underlying_type&lt;e&gt; has a type alias called type

static_assert(SFINAE&lt;std::string&gt;::value); 
// error (first declaration) bc std::string does not have an alias type
</code></pre>
<p>Let's walk this through. First we create our default struct which inherits <code>false_type</code> so that it has a constant member <code>value</code> that is false. 
This is the primary definition. The <code>typename = void</code> is somewhat odd, but all it's doing is creating a template with two parameters,
where the second one is unnamed and defaults to <code>void</code>. 
This allows code to reach this version of the struct <code>SFINAE</code> if the specialization fails. Then we create a specialization. 
The specialization subtypes <code>std::true_type</code> to get a <code>constexpr</code> member <code>value</code> that's true.</p>
<p>For the second template argument of the specialization, we pass <code>T::type</code> to <code>std::void_t</code>. 
If the type arguments of <code>std::void_t</code> (multiple can be passed) are valid, <code>std::void_t</code> is substituted with <code>void</code>. 
If it isn't, then specialization fails. We need the <code>typename</code> keyword whenever we are accessing a type alias which is part of a template type. </p>
<pre><code class="language-C++">struct MyStruct {
    using name = int;
};

template&lt;typename T&gt;
auto test() {
    typename T::type t_type; // accessing alias of template parameter, need typename keyword
    typename std::vector&lt;T&gt;::iterator it; // std::vector&lt;T&gt; is a template, need typename keyword
    std::vector&lt;int&gt;::iterator it2; // no keyword needed
    MyStruct::name i; // also no keyword
}
</code></pre>
<p>So if <code>T</code> contains a type alias called <code>type</code>, then <code>std::void_t</code> will be substituted with <code>void</code> and the specialization will succeed. 
Otherwise, the specialization fails, and the next best specialization is chosen. 
When we use these structs, we'll only pass 1 type parameter. 
Thus, the compiler will first try to instantiate the better matching specialization (1 template parameter) before trying to instantiate the next best match (2 template parameters with one of them defaulted).</p>
<pre><code class="language-C++">template&lt;typename T, typename = void&gt;
struct IsThreadDestructionPolicy : std::false_type {};

template&lt;typename T&gt;
struct IsThreadDestructionPolicy&lt;T,
	std::void_t&lt;
        decltype(T::onThreadDestroy(std::declval&lt;std::thread&amp;&gt;()))
    &gt;&gt; : std::true_type {};
</code></pre>
<p>Think of <code>std::void_t&lt;... Ts&gt;</code> as &quot;try to instantiate&quot; the following types. In actuality, <code>void_t</code> is a usage of SFINAE itself. 
In this example, what we try to instantiate is the return type of the function <code>onThreadDestroy</code>. It's static and takes a reference to a thread. 
In order to get the proper function signature, we must somehow &quot;construct&quot; an object of the type it expects and pass this object to it at compile time. 
That's basically what <code>std::declval&lt;T&gt;()</code> does. <code>std::declval</code> cannot be ODR-used, so it is only applicable in unevaluated contexts such as template arguments. 
Note that to get a reference of <code>T</code>, like we need here, you must explicitly request it by putting an <code>&amp;</code> in the brackets. 
<code>Sizeof()</code> is another unevaluated context: it does not actually evaluate whatever expression you pass to is.</p>
<p>Now what if for some type <code>T</code>, it doesn't have the function <code>onThreadDestroy</code>? 
Well, we get a specialization failure, and by the name of SFINAE this does not halt compilation, rather it just goes on to the next possible instantiation which is the struct that inherits from <code>false_type</code>. 
This is why our primary definition needed that second parameter. We need a parameter to put the <code>std::void_t</code> to see if we can resolve a correct type. 
If we can't, because this second parameter is defaulted, the compiler will then choose the less restricting primary definition of the struct. 
It won't choose this first, because our users will only supply one type parameter, and a specialization taking one parameter will be chosen over one in which it takes a second, defaulted argument.</p>
<p>Let's create a struct to check if a type implements an iterable concept. We'll check the type has <code>begin()</code> and <code>end()</code> member functions and that whatever returned from those functions is
incrementable, dereferenceable, and comparable with <code>==</code> and <code>!=</code>. As we'll soon see, there's a better way to check if a type is an interator, and these requirements don't even cover all our bases.</p>
<pre><code class="language-C++">template&lt;typename T, typename = void&gt;
struct IsIterable : std::false_type {};

template&lt;typename T&gt;
using iter_t = decltype(std::declval&lt;T&amp;&gt;().begin());

template&lt;typename T&gt;
struct IsIterable&lt;T, std::void_t&lt;
        decltype(std::declval&lt;T&gt;().begin()),
        decltype(std::declval&lt;T&gt;().end()),
        decltype(*std::declval&lt;iter_t&lt;T&gt;&gt;()),
        decltype(++std::declval&lt;iter_t&lt;T&gt;&gt;()),
        decltype(std::declval&lt;iter_t&lt;T&gt;&gt;()++),
        decltype(std::declval&lt;iter_t&lt;T&gt;&gt;() == std::declval&lt;iter_t&lt;T&gt;&gt;()),
        decltype(std::declval&lt;iter_t&lt;T&gt;&gt;() != std::declval&lt;iter_t&lt;T&gt;&gt;()),
    &gt;&gt; : std::true_type {};

template&lt;typename T&gt;
constexpr inline auto is_iterable_v = IsIterable&lt;T&gt;::value 
    &amp;&amp; std::is_default_constructible_v&lt;iter_t&lt;T&gt;&gt;
    &amp;&amp; std::is_copy_constructible_v&lt;iter_t&lt;T&gt;&gt; 
    &amp;&amp; std::is_copy_assignable_v&lt;iter_t&lt;T&gt;&gt;
    &amp;&amp; std::is_swappable_v&lt;iter_t&lt;T&gt;&gt;;

template&lt;typename T&gt;
auto printContainer(const T&amp; container) -&gt; std::enable_if_t&lt;is_iterable_v&lt;T&gt;&gt;
{
    std::cout &lt;&lt; &quot;[&quot;;
    for (auto e : container) {
        std::cout &lt;&lt; e &lt;&lt; &quot;, &quot;;
    }
    std::cout &lt;&lt; &quot;]\n&quot;;
}

const std::vector v = {10, 20, 30, 40};
const std::string s = &quot;Hello World&quot;;
const char * str = &quot;Hiya&quot;;

printContainer(v);
printContainer(s);
printContainer(str); // error!
</code></pre>
<p>Why is this useful? Well, try uncommenting the trailing return type with <code>enable_if_t</code> and calling <code>printContainer(100)</code>. 
See what error message you get. Trust me it gets way worse when there's nested template functions used in multiple source files across a project that has thousands of lines of code. 
In Visual Studio, the linter will also be able to pick up on violating <code>enable_if</code> the second you type the function call.</p>
<p>Here's another example</p>
<pre><code class="language-C++">template&lt;typename T, typename = void&gt;
struct IsThreadInterruptionPolicy 
: std::false_type {};

template&lt;typename T&gt;
struct IsThreadInterruptionPolicy&lt;T,
    std::enable_if_t&lt;
        std::is_same_v&lt;T, InterruptableThreadPolicy&gt; || 
        std::is_same_v&lt;T, UninterruptableThreadPolicy&gt;
    &gt;&gt;
    : std::true_type {};
</code></pre>
<p>Here we use <code>std::enable_if</code> which is a struct that defines a member <code>type</code> if the first template parameter is true. 
If the first argument to <code>enable_if</code> is <code>false</code>, then it doesn't have a member alias named <code>type</code> and the specialization will fail. 
<code>std::enable_if</code>and <code>std::void_t</code> work very similarly, the difference is <code>enable_if</code> takes a boolean or boolean expression while <code>std::void_t</code> takes a type or list of types. 
Instead of having to type <code>typename std::enable_if&lt;/*...*/&gt;::type</code> or <code>typename std::void&lt;/*...*/&gt;::type</code> we use <code>std::enable_if_t</code> and <code>std::void_t</code> respectively. 
Of course in C++17 this whole example can simply be written as:</p>
<pre><code class="language-C++">template&lt;typename T&gt;
constexpr inline auto is_thread_interruptable_policy_v = 
    std::is_same_v&lt;T, InterruptableThreadPolicy&gt; || 
    std::is_same_v&lt;T, UninterruptableThreadPolicy&gt;;
</code></pre>
<p>Let's see another example of SFINAE. Here it's used to ensure that only certain types are passed and to get a friendlier compiler error if these conditions are violated. </p>
<pre><code class="language-C++">/**
* Enables a function at compile time if all 
* the type parameters are integral types or vectors
* @param &lt;T&gt; typename to check if it is an integer or 
* vector type
* @param &lt;ReturnType&gt; defaults to std::vector&lt;uint8_t&gt;, 
*   the return type of the function if enabled
*/
template&lt;typename T, 
typename ReturnType = std::vector&lt;uint8_t&gt;&gt;
using requires_int_or_vec = std::enable_if_t&lt;
    is_int_or_vector&lt;strip_t&lt;T&gt;&gt;::value, ReturnType&gt;;



template&lt;typename T&gt;
static constexpr auto convertToByteArray(const std::initializer_list&lt;T&gt;&amp; numArray) 
    -&gt; requires_int_or_vec&lt;T&gt; 
{
    std::vector&lt;uint8_t&gt; ret;
    ret.reserve(numArray.size() * sizeof(T));
    for (auto&amp; v : numArray) {
        const std::vector&lt;uint8_t&gt; subArray 
            = convertToByteArray(v);
        ret.insert(ret.end(),
            subArray.begin(), subArray.end());
    }
    return ret;
}
</code></pre>
<p>This will only compile if <code>T</code> is an int or vector/array like type. <code>is_int_or_vector</code> is a custom struct defined using SFINAE similar to my earlier example.</p>
<p>If C++ 20 is available to you, use C++ 20 concepts and <code>requires</code> clauses.</p>
<p>Let's recap:</p>
<ul>
<li><code>decltype</code> - gets the type of whatever expression is passed to it. Like <code>sizeof</code>, the expression passed is not actually evaluated but simply used for the compiler to figure out the type of said expression.</li>
<li><code>std::declval&lt;T&gt;</code> - creates a &quot;proto&quot; <code>T</code> object that can be used in unevaluated contexts like <code>decltype</code>. Allows us to &quot;call&quot; member functions or functions taking a <code>T</code> in such unevaluated contexts. 
<code>T</code> need not be default constructable. If you needed <code>T</code> to be default constructable as well, you could use <code>T()</code>, however this would always return a prvalue.</li>
<li><code>std::void_t&lt;T, ...&gt;</code> - if all the types passed as template arguments are valid, substitutes the entire expression with <code>void</code>. 
Otherwise, it fails to instantiate causing whatever template specialization it's used in to also fail to instantiate.</li>
<li><code>std::enable_if_t&lt;Condition, Type&gt;</code> - if <code>Condition</code> is true, substitutes the entire expression for <code>Type</code>. 
Otherwise, it fails to instantiate causing whatever function it's used in to also fail to instantiate. 
<code>Type</code> defaults to <code>void</code> if it's not specified.</li>
</ul>
<p>Let's look at one final example from our <code>sum</code> function we motivated this section with. This will build on the <code>IsIterable</code> example:</p>
<pre><code class="language-C++">/*
Original Function:

    template&lt;typename T, typename U&gt;
    U sum(const T&amp; container, U initialValue) {
        for(auto e : container) {
            initialValue += e;
        }
        return initialValue;
    }
*/

template&lt;typename T, typename U, typename = void&gt;
struct IsSummable : std::false_type {};

template&lt;typename T, typename U&gt;
struct IsSummable&lt;T, U, std::void_t&lt;
    decltype(std::declval&lt;T&amp;&gt;() += std::declval&lt;U&gt;()),
    decltype(std::declval&lt;U&amp;&gt;() += std::declval&lt;T&gt;()),
    decltype(std::declval&lt;T&gt;() + std::declval&lt;U&gt;()),
    decltype(std::declval&lt;U&gt;() + std::declval&lt;T&gt;()),
&gt;&gt; : std::true_type {};

template&lt;typename Container, typename Acc&gt;
constexpr inline auto is_vector_summable_v = is_iterable_v&lt;Container&gt; &amp;&amp;
    IsSummable&lt;decltype(*std::declval&lt;iter_t&lt;Container&gt;&gt;()), Acc&gt;::value;


template&lt;typename T, typename U&gt;
auto sum(const T&amp; container, U initialValue) 
    -&gt; std::enable_if_t&lt;is_vector_summable_v&lt;T, U&gt;, U&gt; 
{
    for(auto e : container) {
        initialValue += e;
    }
    return initialValue;
}
</code></pre>
<h3 id="possible-exercises"><a class="header" href="#possible-exercises">Possible Exercises</a></h3>
<ol>
<li>Use SFINAE to ensure that the previous template classes are protected from misuse.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../templates/special.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../templates/forwarding.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../templates/special.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../templates/forwarding.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
