<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Template Basics - Excursion through C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded "><a href="../intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="../guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="../basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="../basics/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="../oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../oop/overloads.html"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="../oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="../oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="../oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="../oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="../oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="../exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="../exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="../pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="../pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="../pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="../pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="../pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="../move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="../move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="../move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="../templates/intro.html" class="active"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="../templates/concepts.html"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="../templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="../templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="../templates/variadic.html"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="../templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="../functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functional/lambdas.html"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="../functional/functional_types.html"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="../functional/algorithm.html"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="../more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="../more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="../more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="../more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="../more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/locks.html"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="../concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="../concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="../concurrency/atomic.html"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="../concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="../cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="../testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="../testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="../testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="../testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="../testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="../testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="../design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="../resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="templates"><a class="header" href="#templates">Templates</a></h1>
<p>We've been using these quite a bit already, and you may already be familiar with things like templates from another programming language.
Templates allow us to pass parameters (often types) to classes, structs, and functions at compile time. 
Effectively, what this does is replace every template argument with whatever type is passed to it. 
For example, <code>std::vector</code> is a template that is <em>instantiated</em> with the type we specify.
This allows one definition of <code>std::vector</code> to be used for many types.
Each template <em>instantiation</em> is a different type; behind the scene each unique combination of template parameters passed to a template type results in 
the compiler generating a unique class/function. 
As we've seen, this means that <code>std::unique_ptr&lt;Base&gt;</code> and <code>std::unique_ptr&lt;Derived&gt;</code> are totally distinct classes even though <code>Derived</code> is a subclass of <code>Base</code>.</p>
<pre><code class="language-C++">template&lt;typename T&gt; // this is the template parameter
class MyVec {
    size_t size;
    T * data;
public:
    explicit MyVec(size_t size) : size(size), data(new T[size]) {}
    // T is effectively replaced with whatever type we specify
    // this type substitution happens at compile time allowing
    // operations like new (which need the static type)
    // to work
    ~MyVec() {
        delete[] data;
    }

    T&amp; operator[](size_t idx) {
        return data[idx];
    }

    T* begin() {
        return data;
    }

    T* end() {
        return data + size;
    }

    bool contains(const T&amp; e) const {
        const auto end = data + size;
        return std::find(data, end, e) != end;
    }
};

MyVec&lt;int&gt; mv(100);

// -----------------------------------------------
// Effectively what happens is the compiler generates the following:

class MyVec_int {
    size_t size;
    int * data;
public:
    MyVec_int(size_t size) : size(size), data(new int[size])
    ~MyVec_int() {
        delete[] data;
    }

    int&amp; operator[](size_t idx) {
        return data[idx];
    }

    int* begin() {
        return data;
    }

    int* end() {
        return data + size;
    }

    bool contains(const int&amp; e) const {
        const auto end = data + size;
        return std::find(data, end, e) != end;
    }
};

MyVec_int mv(100);
</code></pre>
<p>In order to instantiate a template, the template's full definition (not just declaration) must be available. 
Since translation units (source file + all included headers) are compiled independently,
the general result is that a template function or class must be defined in a header file. 
This allows multiple source files to declare instances of template types because when the compiler compiles the translation unit,
the definition is available since it's in the header file. 
There is a way around this however.
If the amount of different instantiations of a template is limited,
you can define the class in a source file and manually enumerate through all allowed instantiations in that file. 
This way, when another translation unit uses an instance of a template class,
the linker can link the instance defined in an external translation unit with its usage.</p>
<pre><code class="language-C++">// my_vec.h
template&lt;typename T&gt; 
class MyVec {
    size_t size;
    T * data;
public:
    explicit MyVec(size_t size);
    ~MyVec();
};
</code></pre>
<pre><code class="language-C++">// my_vec.cpp
#include &quot;my_vec.h&quot;

template&lt;typename T&gt;
MyVec&lt;T&gt;::MyVec(size_t size) : size(size), data(new T[size]) {}

MyVec&lt;T&gt;::~MyVec() { delete[] data; }

// Manual instantiations
// full definition avaliable here
template MyVec&lt;int&gt;;

template MyVec&lt;double&gt;;
</code></pre>
<pre><code class="language-C++">// main.cpp
#include &quot;my_vec.h&quot;

// only declaration is available
MyVec&lt;long long&gt; v(100); // ERROR
// no definition available

MyVec&lt;int&gt; mvi(10);
// fine, link with the instantiated template from another
// translational unit

</code></pre>
<p>As we've seen, template arguments can be omitted when the compiler can infer them.</p>
<pre><code class="language-C++">
std::vector vec = {1, 2, 3, 4};
// infers std::vector&lt;int&gt;

template&lt;class T&gt; // the keyword class can also be used, there is no difference at all although class conveys more that you are expecting a class
T add(T a, T b) {
    return a + b;
}

const auto sum = add(100, 200);
// deduces to add&lt;int&gt;(100, 200)
</code></pre>
<p>Notice that <code>add</code> may not work with every type we pass to it. For example if we passed two vectors, we'd get a compiler error. 
However, even with this failure case, <code>add</code> still compiles. 
A template instantiation is not generated unless that instantiation is <em>ODR-used</em> (used in a place where a definition is required, we'll discuss this later). 
Later we'll also see ways to constrain the template arguments because if you did ODR-use an invalid template instantiation you'd likely be greeted with a somewhat cryptic and perhaps very lengthy error message.</p>
<p>Because we use <code>T</code> for the return types and both arguments, all 3 must be exactly the same type. If that wasn't the case, we'd need more type parameters.</p>
<pre><code class="language-C++">template&lt;typename T, typename U, typename ReturnType&gt;
ReturnType add(const T&amp; a, const U&amp; b) {
    return a + b;
}

std::string hello = &quot;Hello&quot;;
auto result = add(hello, 5);
// We'll discuss type deduction later, but this deduces to
// add&lt;std::string, int, std::string&gt;
</code></pre>
<p>We can also have non-type template parameters too. We saw this with <code>std::array</code>.</p>
<pre><code class="language-C++">template&lt;typename T, int N&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream &amp; str, const T (&amp; arr)[N]) {
    str &lt;&lt; &quot;[&quot;;
    for (auto i = 0; i &lt; N - 1; ++i) {
        str &lt;&lt; arr[i] &lt;&lt; &quot;, &quot;;
    }
    if (N &gt;= 1) {
        str &lt;&lt; arr[N - 1];
    }
    str &lt;&lt; &quot;]&quot;;
    return str;

}
// pass by reference to T array of size N

int myArray[] = {1, 2, 3};
std::cout &lt;&lt; myArray;
// &quot;[1, 2, 3]&quot;
</code></pre>
<p>Let's look at another example.</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;optional&gt;

template&lt;typename T&gt;
class LList {
    struct node {
        // fully qualified name is LList&lt;T&gt;::node
        std::shared_ptr&lt;node&gt; next;
        T data;

        node(const T&amp; data) : next(nullptr), data(data) {}
        // T must be copy constructable

        node(const node&amp; other) {
            if (other.next) {
                next = std::make_shared&lt;node&gt;(other);
            }
            else next = nullptr;
            data = other.data;
            // T must be copy assignable
        }
        node() = default;
        // T must be default constructable
    };

    std::shared_ptr&lt;node&gt; first; ///&lt; Invariant: nullptr iff list is empty
    std::weak_ptr&lt;node&gt; last; ///&lt; Invariant: nullptr iff list is empty
public:
    LList() = default;

    LList(const LList&lt;T&gt;&amp; other) : LList() {
        // LList&lt;T&gt; is a type, LList is not
        // we make this copy constructable from lists ONLY of the same type
        *this = other;
    }

    // Deep copy, strong guarantee
    // The default copy would increment the reference count of the pointer (shallow copy)
    // So we'd end up with two linked lists sharing the same data
    LList&amp; operator=(const LList&lt;T&gt;&amp; other) {
        if (other.first) {
            first = std::make_shared&lt;node&gt;(*other.first);
            set_last();
        }
        else {
            first = nullptr;
            last = std::weak_ptr&lt;node&gt;(first);
        }
        return *this;
    }

    LList(LList&lt;T&gt;&amp;&amp;) noexcept = default;
    LList&amp; operator=(LList&lt;T&gt;&amp;&amp;) noexcept = default;

    // Strong
    void push_back(const T&amp; elem) {
        if (!set_first_if_empty(elem)) {
            if (last.expired())
                throw std::runtime_error(&quot;Invariant violated&quot;);
            auto lastNode = last.lock();
            lastNode-&gt;next = std::make_shared&lt;node&gt;(elem);
            last = std::weak_ptr&lt;node&gt;(lastNode-&gt;next); //noexcept
        }
    }
    // Strong guarantee
    void push_front(const T&amp; elem) {
        const auto oldRoot = first;
        first = std::make_shared&lt;node&gt;(elem);
        first-&gt;next = oldRoot; //copying a smart pointer is noexcept
    }

    bool empty() const noexcept {
        return first == nullptr;
        // could have have static_cast first to bool
    }

    std::optional&lt;T&gt; pop_front() noexcept {
        if (first) {
            std::optional result = std::move(first-&gt;data);
            // T must be move constructable
            // safe to move because the reference to data is about
            // to be destroyed
            first = first-&gt;next;
            return result;
        }
        return {};
    }
private:
    /**
    * Creates the first node of the list if the list is empty
    * Strong guarantee
    * @param elem the data for the new first node if created
    * @returns true if elem was set to the new first node, else false
    */
    bool set_first_if_empty(const T&amp; elem) {
        if (!first) {
            first = std::make_shared&lt;node&gt;(elem);
            last = std::weak_ptr&lt;node&gt;(first); // noexcept
            return true;
        }
        return false;
    }

    /**
    * Updates last to reference the last element in the list
    */
    void set_last() noexcept {
        auto n = first;
        auto lastNode = n;
        while (n) {
            lastNode = n;
            n = n-&gt;next;
        }
        last = std::weak_ptr&lt;node&gt;(lastNode);
    }
};

int main() {
    LList&lt;int&gt; stack;
    stack.push_front(10);
    stack.push_front(20);
    std::cout &lt;&lt; stack.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //20
    // value_or uses ref qualifiers to move out the contained value of the optional
    // since we call it on an rvalue
    std::cout &lt;&lt; stack.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //10
    std::cout &lt;&lt; stack.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //-1
    auto queue = stack;
    queue.push_back(100);
    queue.push_back(200);
    std::cout &lt;&lt; queue.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //100
    std::cout &lt;&lt; stack.empty() &lt;&lt; &quot;\n&quot;; //1 (true)
    std::cout &lt;&lt; queue.empty() &lt;&lt; &quot;\n&quot;; //0 (false)
    auto q2 = queue;
    q2.push_back(500);
    std::cout &lt;&lt; q2.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //200
    std::cout &lt;&lt; q2.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //500
    std::cout &lt;&lt; queue.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //200
}
</code></pre>
<p>Notice we make a few subtle assumptions about <code>T</code>. We assume that whatever type is instantiated is copy constructable, copy assignable, move constructable, and default constructable. 
One type that won't satisfy this is a unique pointer for example. What we've done is we assumed a static interface that all elements of our list must adhere to.</p>
<h2 id="one-definition-rule"><a class="header" href="#one-definition-rule">One Definition Rule</a></h2>
<p>Firstly, <em>definitions</em> are <em>declarations</em> that fully define something except for the following cases (and a few more):</p>
<ul>
<li>Function declaration without a body</li>
<li>Declaration with <code>extern</code> that lacks an initial value
<pre><code class="language-C++">extern const int i; // declaration
extern const int j = 5; // definition
</code></pre>
</li>
<li>Non-inline static members in a class
<pre><code class="language-C++">struct S {
    int i; // definition
    static int j; // declaration
    inline static int k; // definition
};

int S::j; // definition
</code></pre>
</li>
<li>Declaration of class without body
<pre><code class="language-C++">class S;
class ReturnType func(class ArgType a);
</code></pre>
</li>
<li>Using and typedef aliases</li>
<li>Template parameters
<pre><code class="language-C++">template&lt;typename T&gt; //T is declared
</code></pre>
</li>
</ul>
<p>Now as the name implies, only one definition of something is allowed in a single translation unit,
and one and only one definition of non-inline functions and variables must exist in a program. 
Finally, one definition of inline functions and variables must be present in every translation unit where they are ODR-used.</p>
<p>Functions are ODR used when somebody makes a call to it or takes its address. Objects are ODR used when its value is read (unless it's a compile-time constant), written, has its address taken, 
or a reference is bound to it. For a reference, it is ODR used when it is not known at compile time. Anything that's ODR used must have a valid definition somewhere in the program.</p>
<p>This was a pretty round about way of basically saying that templates are normally defined in header files and nothing else can be defined in a header file unless it's <code>inline</code> or a non-static member variable.</p>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>We can add an alternative name to types using a type alias. The old way of doing this was through the <code>typedef</code> keyword, but now we can do this with <code>using</code> declarations. 
<code>using</code> declarations may be templates themselves, and they respect access modifiers when declared as part of a class. As I just talked about, type aliases are not definitions.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
using stack_t = LList&lt;T&gt;;

stack_t&lt;int&gt; stack;

class Test {
    using name_t = std::string;

    name_t name;
public:
    using test_t = int;
    name_t getName() const { return stack; }
};

Test::name_t nm; // error, not visible
Test::test_t tt; // good

template&lt;typename T&gt;
using tuple_3 = std::tuple&lt;T, T, T&gt;;

tuple_3&lt;int&gt; tp;
// instead of std::tuple&lt;int, int, int&gt;
</code></pre>
<p>Like defining <code>const</code> or <code>constexpr</code> variables instead of magic values, type aliases provide an opportunity to add documentation via a name for a type and make it easy to replace types. 
For example, let's say that you want to change the stack implementation from using our <code>LList&lt;T&gt;</code> to an <code>std::deque&lt;T&gt;</code>. 
Instead of having to change every reference to the type (return type, parameter type, variable declarations, etc.) you can just change it in one place and be done with it.</p>
<h3 id="possible-exercises"><a class="header" href="#possible-exercises">Possible Exercises</a></h3>
<ol>
<li>
<p>Make the <code>Ringbuffer</code> class from earlier into a template. Instead of using raw pointers, can you use a <code>std::unique_ptr</code>? (If you were actually implementing this, the best choice would be <code>std::vector</code>). Make sure it's copyable and moveable. Alternatively, make your favorite container with templates.</p>
</li>
<li>
<p>Make the <code>Vec3d</code> class from before into a template which is templated on type to store and number of elements. Define all of the same members as before plus make it copy constructable and assignable from <code>std::array</code>, <code>std::vector</code>, <code>std::initializer_list</code> and really all other list/vector like containers with a single constructor and assignment operator. For a bonus, do the same with a reference to an array (will need a separate overload).</p>
</li>
<li>
<p>What would happen if you casted the integer 300 to a <code>char</code>. What about the float <code>12.4f</code> to a <code>long long</code>. How would the result of the cast compare to the original value? What about if you casted the integer <code>500</code> to a <code>short</code>? How do these scenarios differ? From these ideas, see if you can implement <code>narrow_cast&lt;T, U&gt;</code> which casts the arithmetic type <code>T</code> to the arithmetic type <code>U</code> if the value of the <code>T</code> object can fit in <code>U</code>. This function is part of the GSL (guidelines support library) so an implementation can be found online.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../move/like_move.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../templates/special.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../move/like_move.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../templates/special.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
