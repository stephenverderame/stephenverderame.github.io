<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Variadic Templates - Excursion through C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded "><a href="../intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="../guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="../basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="../basics/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="../oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../oop/overloads.html"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="../oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="../oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="../oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="../oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="../oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="../exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="../exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="../pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="../pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="../pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="../pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="../pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="../move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="../move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="../move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="../templates/intro.html"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="../templates/concepts.html"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="../templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="../templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="../templates/variadic.html" class="active"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="../templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="../functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functional/lambdas.html"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="../functional/functional_types.html"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="../functional/algorithm.html"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="../more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="../more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="../more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="../more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="../more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/locks.html"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="../concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="../concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="../concurrency/atomic.html"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="../concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="../cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="../testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="../testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="../testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="../testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="../testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="../testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="../design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="../resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="variadic-templates"><a class="header" href="#variadic-templates">Variadic Templates</a></h1>
<p>As we've seen with <code>std::void_t</code>, <code>emplace()</code>, and <code>make_unique</code>/<code>make_shared</code>, there is a way to take an unknown amount of parameters of different types. 
This can be done using a <em>parameter pack</em>. A template that uses a parameter pack is known as a variadic template.</p>
<p>You can almost think of a parameter pack as a list of template parameters (both type and non-type parameters). 
A parameter pack can have any number of parameters, including none.</p>
<pre><code class="language-C++">template&lt;typename ...Ts&gt;
struct Types {};

Types&lt;&gt; t;
Types&lt;1, 2, 3&gt; t2;
Types&lt;int, short, std::string, char&gt; t3;

template&lt;typename ...Ts&gt;
void func(Ts... args) {
    // ..
}

func();
func(100, &quot;Hello&quot;, 'g');
</code></pre>
<p>We can define a parameter pack by putting the ellipsis in front of the pack name, and expand a parameter pack by putting the ellipsis after the <em>pattern</em>. 
The pattern is the pack name with any adornments (such as <code>&amp;</code>) which are given to all elements of the pack. During expansion, the pattern is substituted by the elements of the pack separated by commas.</p>
<pre><code class="language-C++">template&lt;class ...Us&gt; 
void f(Us... pargs) {}

template&lt;class ...Ts&gt; 
void g(Ts... args) {
    return f(&amp;args...); 
    // calls f by passing all elements of args by reference
    // &amp;args is the pattern
}
g(1, 0.2, &quot;a&quot;); 
</code></pre>
<p>We can expand parameter packs in the following contexts:</p>
<ul>
<li>As we've just seen, function arguments
<pre><code class="language-C++">template&lt;typename ... Ts&gt;
void g(Ts... args) {
    f(args...);
    f(++args...); // expands to f(++a, ++b, ++c, ...)
    f(h(args...) + args...); 
    // expands to
    //f(h(a, b, c) + a, h(a, b, c) + b, h(a, b, c) + c);
}
</code></pre>
</li>
<li>Initializers (both parenthesis and braces)
<pre><code class="language-C++">template&lt;typename ... Ts&gt;
auto toVec(Ts ... args) {
    std::vector v = {1, args..., 2};
    return v;
}
</code></pre>
</li>
<li>Template arguments
<pre><code class="language-C++">template&lt;typename ... Ts&gt;
struct Test {
    container&lt;int, short, Ts...&gt; c;
};
</code></pre>
</li>
<li>Base class specifiers and member initialization lists
<pre><code class="language-C++">template&lt;typename ... Mixins&gt;
struct Aggregator : public Mixins ... {
    Aggregator(const Mixins&amp; ... args) : Mixins(args) ... {};
    // expands to call copy constructor of all base classes
}
</code></pre>
</li>
<li>Using declarations
<pre><code class="language-C++">template&lt;typename ... Mixins&gt;
struct Aggregator : public Mixins ... {
    Aggregator(const Mixins&amp; ... args) : Mixins(args) ... {};
    // expands to call copy constructor of all base classes

    void foo() {};
    using Mixins::foo...;
    // unshadow all base class foo overloads
}
</code></pre>
</li>
</ul>
<p>Parameter packs can also be universal references and can be forwarded.</p>
<pre><code class="language-C++">template&lt;typename T, typename ... Args&gt;
auto make_unique(Args&amp;&amp; ... args) {
    return std::unique_ptr&lt;T&gt;( new T(std::forward&lt;Args&gt;(args)...) );
    // expands to
    // new T(std::forward&lt;A&gt;(a), std::forward&lt;B&gt;(b), std::forward&lt;C&gt;(c), /* ... */)
}
</code></pre>
<p>Basically, each use case of <code>...</code> expands a comma separated list of the pattern <code>...</code> is applied to. 
The name of the pack typename (<code>Args</code> in this case) is substituted which each type in the pack, and the name of the pack arguments (<code>args</code> here) is substituted with each argument passed to the function.</p>
<p>We can &quot;unpack&quot; an expansion by using two function overloads (or class specializations), one which takes no arguments, this will be the base case, and one which takes a &quot;head&quot; argument and &quot;tail&quot; parameter pack. 
The idea here is the same as in functional programming. Here's a simple function to get the length of a parameter pack.</p>
<pre><code class="language-C++">constexpr auto argCount() {
    return 0;
}

template&lt;typename T, typename ... Args&gt;
constexpr auto argCount(T&amp;&amp;, Args&amp;&amp; ... args) {
    return 1 + argCount(std::forward&lt;Args&gt;(args)...);
}

constexpr auto count = argCount(5); 
static_assert(count == 1);
static_assert(argCount(&quot;Hello&quot;, 50.0, 10, 'c') == 4);
</code></pre>
<p>When we call <code>argCount</code> with non-zero amount of arguments, the first argument gets bound to <code>T&amp;&amp;</code> and the rest (which there may be none) gets bound to <code>Args&amp;&amp;</code>. 
If the pack has no arguments in it, the expansion won't do anything, and the no parameter overload will be called.</p>
<p>A better way to do this is to use the <code>sizeof...</code> operator, which gets the amount of arguments in a parameter pack.</p>
<pre><code class="language-C++">template&lt;typneame ... Args&gt;
constexpr auto argCount(Args&amp;&amp; ...) {
    return sizeof...(Args);
    // sizeof... takes the typename of the pack, not the argument name
}
</code></pre>
<p>Here's an example of getting the nth type from a parameter pack:</p>
<pre><code class="language-C++">template&lt;unsigned index, typename Head, typename ... List&gt;
struct NthType {
    using Type = typename NthType&lt;index - 1, List...&gt;::Type;
    // we &quot;pop&quot; the Head of the pack by not passing it through
};

template&lt;typename Head, typename ... List&gt;
struct NthType&lt;0, Head, List...&gt; {
    using Type = Head;
};
// index 0 specialization

using sndType = typename NthType&lt;2, void*, char*, int, long, double&amp;&gt;::Type;
//sndType is int
/*  sndType
        NthType&lt;index = 2, Head = void*, List = char*, int, long, double&amp;&gt;
            NthType&lt;index = 1, Head = char*, List = int, long, double&amp;&gt;
                NthType&lt;index = 0, Head = int, List = long, double&amp;&gt;
                    This is the specialization
                    So `Type = Head = int`

*/
</code></pre>
<h2 id="fold-expressions"><a class="header" href="#fold-expressions">Fold Expressions</a></h2>
<p>A fold expression is like another type of pack expansion, except that instead of producing comma separated arguments,
the pack is expanded over a binary operator. 
A fold expression can have an initial value as well, and must be surrounded by parentheses.</p>
<p>I won't explain the details of folds here, but basically left folds operate on the leftmost argument first,
right folds go from the rightmost argument to leftmost. Folds come from functional programming languages. 
Fold expression have the following syntax where <code>pack</code> is the pattern containing the name of the pack,
<code>op</code> is the operator, <code>init</code> is the initial value and <code>...</code> are the actual ellipsis.</p>
<ul>
<li>Unary fold right - <code>(pack op ...)</code></li>
<li>Unary fold left - <code>(... op pack)</code></li>
<li>Binary fold right - <code>(pack op ... op init)</code></li>
<li>Binary fold left - <code>(init op ... op pack)</code></li>
</ul>
<p>The difference between a unary and binary fold is not that one uses unary operators (that would be a normal pack expansion),
but rather the binary fold has an initial value. 
The syntax for a left fold is when the <code>...</code> is on the left side of the pack name.</p>
<pre><code class="language-C++">template&lt;typename ... Ts&gt;
constexpr auto sum(Ts&amp;&amp; ... args) {
    return (... + args);
    // &quot;unary&quot; left fold
}

template&lt;typename ... Args&gt;
void print(Args&amp;&amp; ... args) {
    (std::cout &lt;&lt; ... &lt;&lt; args);
    // binary left fold
}

template&lt;typename ... Args&gt;
constexpr auto allTrue(Args&amp;&amp; ... args) {
    return (... &amp;&amp; args);
    // binary left fold
}

template&lt;typename T, typename ...Args&gt;
constexpr auto contains(T needle, Args ... args) {
    // true if needle is contained within the pack
    return (... || (args == needle));
}

template&lt;typename ...Args&gt;
constexpr auto selfDot(Args... args) {
    // computes the dot product of the arguments with them self
    return (... + (args * args));
}
</code></pre>
<p>Notice the need for the parenthesis to make an entire expression such as <code>args * args</code> or <code>args == needle</code> part of the pattern. 
We define all of these function <code>constexpr</code> so that the result of the function can be available at compile time (and therefore not done during runtime) if we pass arguments that are also <code>constexpr</code> such as literals.</p>
<h2 id="packs-and-concepts"><a class="header" href="#packs-and-concepts">Packs and Concepts</a></h2>
<p>Parameter packs can be used pretty easily with <code>enable_if</code> using fold expressions.</p>
<pre><code class="language-C++">template&lt;typename ... Ts&gt;
constexpr auto sum(Ts... args) 
    -&gt; std::enable_if_t&lt;(... &amp;&amp; std::is_arithmetic_v&lt;Ts&gt;), decltype((... + args))&gt; 
{
    return (... + args);
}

constexpr auto s = sum(10, 20.3, 100.f, 'c'); // double 229.3
</code></pre>
<p>Unlike before, in this situation we <em>need</em> to use the trailing return type because the parameter <code>args</code> is used in determining the return type. 
Also, notice how when we want a fold expression using the types of the pack, we use the name of the template parameter <code>Ts</code>. 
However, when we want a fold expression using the values of the pack, we use the name of the function argument <code>args</code>.</p>
<p>In this case we fold over <code>&amp;&amp;</code> (boolean AND) to ensure that all types in the pack are arithmetic.
We could fold over <code>||</code> (boolean OR) to check that at least one type upholds a certain condition.</p>
<p>We can use a type alias to make this a bit cleaner.</p>
<p>Another less graceful, (and pre C++17 friendly) way of doing this is to create an <code>all_true</code> struct using SFINAE. 
What we'll do is instantiate a struct with a pack of bools.
Then we'll assert that the type of the bool pack is the same when we append a <code>true</code> to the front of the pack as when we push a <code>true</code> to the back. 
If all elements of the bool pack are the <code>true</code>, then the types will be the same.
However, if any of the elements in the pack are <code>false</code>, the position of this <code>false</code> will differ between the two 
instantiations of the template, and they won't be the same type.</p>
<pre><code class="language-C++">
template&lt;bool...&gt;
struct bool_pack {};

// template variables are a C++17 feature
template&lt;bool... bools&gt;
constexpr inline auto all_true_v = std::is_same_v&lt;
    bool_pack&lt;bools..., true&gt;, 
    bool_pack&lt;true, bools...&gt;&gt;;

template&lt;typename... Ts&gt;
std::enable_if_t&lt;all_true_v&lt;std::is_arithmetic_v&lt;Ts&gt;...&gt;&gt;
foo(Ts... args) {
    //...
}
</code></pre>
<h3 id="possible-exercises"><a class="header" href="#possible-exercises">Possible Exercises</a></h3>
<ol>
<li>Can you create a function that takes an arbitrary number of arguments and serializes all of them into a single byte array?
The function should return an <code>std::vector&lt;std::byte&gt;</code> or an <code>std::array&lt;std::byte, N&gt;</code>.
If you go the latter route, the function can be <code>constexpr</code>.
You'll need an overload to handle containers like <code>std::vector</code>, <code>std::list</code>, etc.
You may choose the endianness of the result.
<ul>
<li>So when passed <code>&quot;Hello&quot;, 5, static_cast&lt;short&gt;(1000)</code> the function should return a single byte array that would look something like:
<pre><code class="language-C++">0x48 0x65 0x6C 0x6C 0x6F 0x00 0x00 0x00 0x05 0x03 0xE8
 'H'  'e'  'l'  'l'  'o'|         5         |   1000
// little endian, 4 byte int, 2 byte short
</code></pre>
</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../templates/type_deductions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../templates/iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../templates/type_deductions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../templates/iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
