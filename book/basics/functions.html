<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functions - Excursion through C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded "><a href="../intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="../guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="../basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="../basics/functions.html" class="active"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="../oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../oop/overloads.html"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="../oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="../oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="../oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="../oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="../oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="../exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="../exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="../pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="../pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="../pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="../pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="../pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="../move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="../move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="../move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="../templates/intro.html"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="../templates/concepts.html"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="../templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="../templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="../templates/variadic.html"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="../templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="../functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functional/lambdas.html"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="../functional/functional_types.html"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="../functional/algorithm.html"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="../more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="../more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="../more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="../more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="../more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/locks.html"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="../concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="../concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="../concurrency/atomic.html"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="../concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="../cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="../testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="../testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="../testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="../testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="../testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="../testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="../design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="../resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>As we have seen, if functions are not declared and defined separately, we can use <code>auto</code> to have the compiler use type deduction on the return type. 
Otherwise, just like function parameters, the return type must be specified.</p>
<pre><code class="language-c++">void printHello(); //declaration


int main() {
    printHello();
    return 0;
}

void printHello() {
    //definition
    std::cout &lt;&lt; &quot;Hello\n&quot;;
}
</code></pre>
<p>Declaring a function ahead of its definition like in the above snippet is known as <em>forward declaring</em>. 
It allows us to not have to manually ensure that every function is defined in topological order. 
It basically tells the compiler &quot;hey, I'm going to define this later so if you see this name before you see its definition don't freak out.&quot;</p>
<p><code>void</code> is a special type that essentially means there is no type. We can use it for functions that don't return anything. </p>
<p>Functions can be <em>pass-by-value</em> or <em>pass-by-reference</em>. When a function is pass-by-value, the function parameter gets copied.
When it's pass-by-reference the actual object is not passed to the function, but the address of the object is.</p>
<pre><code class="language-c++">
void add(int a) { // pass by value (copy data)
    a += 5;
    std::cout &lt;&lt; a &lt;&lt; std::endl;
}

void addRef(int &amp; b) { // pass by reference (bind alias to same piece of data)
    b += 5;
}

int main() {
    auto num = 0;
    add(num);
    // num is still 0 but 5 is printed
    addRef(num);
    // num is now 5
    return 0;
}
</code></pre>
<p>In <code>add()</code> a new copy of <code>num</code> is created which is called <code>a</code>. <code>a</code> goes out of scope when <code>add()</code> terminates.
In <code>addRef()</code>, <code>b</code> binds to <code>num</code>, so <code>b</code> and <code>num</code> share the same object and the same data.
In <code>addRef()</code>, <code>b</code> is used as an output parameter because the result of the function is returned in one of its parameters.
<strong>You should avoid output parameters.</strong>
This is because when you're looking at the call site of <code>addRef()</code>, there's nothing to tell you that <code>num</code> is mutated,
and you may reasonably expect that <code>num</code> would retain its value.</p>
<p>Does that mean we shouldn't pass by reference? No! Far from it. We can pass by <code>const</code> reference.</p>
<pre><code class="language-c++">int addRef2(const int &amp; a) {
    // a += 4; // error, a cannot be mutated
    return a + 5;
}

int main() {
    auto num = 0;
    num = addRef2(num);
    // num is now 5
    // from just looking at this, it's pretty clear num is changing
}
</code></pre>
<p>In this example, you can look at the call site of <code>addRef2()</code> and pretty clearly see that <code>num</code> is being mutated. </p>
<p>For built-in types, passing by reference is likely tantamount to premature pessimization.
On a 32-bit OS, and address will be 4 bytes, and a 64-bit OS will have 8-byte addresses.
Therefore, there would be less data being copied if we just passed by value since an address is at best the same size as an integer (in almost all implementations, but not necessarily).
However, we will soon see how this is very useful.</p>
<h2 id="function-overloading"><a class="header" href="#function-overloading">Function Overloading</a></h2>
<p>Functions with the same name can be overloaded by having different argument types or different amount of arguments.
The function with arguments more closely matching the parameters passed is the one called.</p>
<pre><code class="language-c++">void func1(int); //version a
void func1(char); //version b
void func1(double); //version c
void func1(char, int); // version d

short ss = 10;
func1(ss); // version a
func1('H'); // version b
func1(0.1f); // c
func1(true); // a
long l = 100;
func1(l); // a
func1(false, 100ll); // d
</code></pre>
<p>If there are multiple equally good matches, the compiler won't guess and will not compile. 
Likewise, if no parameter is implicitly convertible to the type of any overload's arguments, then compilation fails.</p>
<h2 id="other-notes"><a class="header" href="#other-notes">Other Notes</a></h2>
<p>We can also define the return type after we declare the function parameters.
This is known as a trailing return type, and it looks like this:</p>
<pre><code class="language-C++">auto foo(int a, int b) -&gt; int {
    return a - b;
}
</code></pre>
<p>The evaluation order of function arguments is undefined. So given the following:</p>
<pre><code class="language-C++">int i = 0;
auto res = foo(i++, ++i);
</code></pre>
<p>There are two possible execution orders:</p>
<ol>
<li>
<ul>
<li><code>b = ++i = 1</code></li>
<li><code>a = i++ = 1</code></li>
<li><code>res = a - b = 0</code></li>
</ul>
</li>
<li>
<ul>
<li><code>a = i++ = 0</code></li>
<li><code>b = ++i = 2</code></li>
<li><code>res = a - b = -2</code></li>
</ul>
</li>
</ol>
<h2 id="function-design"><a class="header" href="#function-design">Function Design</a></h2>
<blockquote>
<p>The first rule of functions is that they should be small.</p>
<p>The second rule of functions is that <em>they should be smaller than that</em>
<sup class="footnote-reference"><a href="#1">1</a></sup></p>
</blockquote>
<p>Making functions small organizes sections of your code into named units. 
It's easy to know what your code does when it's part of a named function with a narrow scope.
So how small is small? Well most should rarely hit 20 lines. 
A good rule of thumb is 80 characters wide by 20 lines long or smaller. Not only are small functions easier to reason about and debug,
but such functions are readable for most ways in which you might be viewing it. For example, when developing on a PC with
your code fullscreened on a 27&quot; monitor, it's pretty easy to read lines of code over 150 character long. However,
if you want to do a side-by-side diff comparison, work on the codebase from your 15&quot; laptop with,
or have other developers who might use a &quot;busier&quot; IDE layout, those 150 character lines become quite annoying.
Vertical size is less annoying to deal with, but it's still quite nice when you can view an entire function in one glance
without scrolling on various different viewing modes.</p>
<p>Furthermore, functions should <strong>do one thing</strong>. 
How do you know they do one thing? Well you should be able to describe it in about one sentence without using a conjunction like &quot;and.&quot;</p>
<p>Example:</p>
<pre><code class="language-c++">if(person.getAge() &gt;= 18 &amp;&amp; person.getAge() &lt; 25 
    &amp;&amp; person.getHighestEdu() == EducationLevel::Highschool
    &amp;&amp; !person.livingAtHome()) 
{
    // if person attended college after HS
}
</code></pre>
<p>OR</p>
<pre><code class="language-c++">inline auto didAttendCollegeAfterHS(const Person &amp; person) {
    return person.getAge() &gt;= 18 &amp;&amp; person.getAge() &lt; 25 
        &amp;&amp; person.getHighestEdu() == EducationLevel::Highschool
        &amp;&amp; !person.livingAtHome();
}

// ...

if(didAttendCollegeAfterHS(person)) {

}
</code></pre>
<p>Notice how by creating a helper function, we were able to encode the comment in a name. 
Commenting what the code does is unnecessary since the function name says it all. 
If you find yourself commenting what code does, that's a good hint that you might want to make a function. 
We also see how <code>didAttendCollegeAfterHS()</code> does just one thing: it just determines if a person attended college after high school.
We also pass by <code>const</code> reference since the function only uses accessors of <code>Person</code> and doesn't do any mutations.
When passing by reference, the reference should always be <code>const</code> unless you are mutating it.</p>
<p>For another example, we saw in our guessing game how we turned this:</p>
<pre><code class="language-c++">int main() {
    const auto secretNum = getRandNumBetween(min_value, max_value);
    auto guess = 0;
    do {
        std::cout &lt;&lt; &quot;Guess a number between &quot; 
            &lt;&lt; min_value &lt;&lt; &quot; and &quot; &lt;&lt; max_value &lt;&lt; std::endl;
        guess = getUserGuess();

        if (guess &lt; secretNum) {
            std::cout &lt;&lt; &quot;Too low!&quot; &lt;&lt; std::endl;
        } else if (guess &gt; secretNum) {
            std::cout &lt;&lt; &quot;Too high!&quot; &lt;&lt; std::endl; 
        }
    } while (guess != secretNum);
}
</code></pre>
<p>into this</p>
<pre><code class="language-c++">int main() {
    const auto secretNum = getRandNumBetween(min_value, max_value);
    auto guess = 0;
    auto tries = 0;
    do {
        ++tries;
        guess = getUserGuess();
        displayGuessHint(guess, secretNum);
    } while (guess != secretNum);
    displayWin(secretNum, tries);
}
</code></pre>
<p>Once again, we see that the different tasks done during the main loop are easier to read since they essentially have labelled names. 
We could be more pedantic and make the loop its own function as well, but this function is 10 lines long, so I felt that was good enough. 
I like functions to be of a size so that in one &quot;eye-space&quot; I can take in the entire function. So no scrolling, moving my head, etc.</p>
<p>Functions should also not use output parameters, and have a small amount of arguments. 
Generally shoot for no more than 4 arguments. 
Also, if you have parameters of the same type next to each other (and order matters),
you can encode the order in the function name or separate the parameters by some argument of a different type (if there are more arguments).</p>
<p>Ex.</p>
<pre><code class="language-c++">void assertExpEqAct(int expected, int actual);
</code></pre>
<p>vs</p>
<pre><code class="language-c++">void assertEquals(int expected, int actual);
</code></pre>
<p>A user of <code>assertExpEqAct()</code> wouldn't have to look up the order of arguments in the docs since the order is encoded right into the name.</p>
<p>Here's another example:</p>
<pre><code class="language-c++">using it = std::vector&lt;char&gt;::iterator;
void copy(it dstBegin, it dstEnd, it srcBegin, it srcEnd);
</code></pre>
<p>vs</p>
<pre><code class="language-c++">using it = std::vector&lt;char&gt;::iterator;
struct Range {
    it begin, end;
}

void copyDstFromSrc(Range dst, Range src);
</code></pre>
<p>Notice how the first function was <em>missing an abstraction</em> which led to having 4 parameters. 
In the second function, we created a <code>struct</code> to organize the parameters into an <code>abstraction</code>.
In C++20, this can be done with ranges and <code>std::span</code>.</p>
<p>We should also prefer <em>pure functions</em>; a pure function has no side effects, and returns the same output for the same inputs.
It should not mutate variables or have any other effect other than the value it returns.</p>
<h2 id="inline-functions"><a class="header" href="#inline-functions">Inline Functions</a></h2>
<p>Earlier you saw me use the <code>inline</code> keyword. 
This keyword <em>suggests</em> to the compiler that the function can be inlined. 
What is an inlined function? 
Well, we'll cover the details later, but basically every time you call a function the state of the current function must be saved,
you must jump to the new function,
then you must restore the state of the old function and jump back. 
Abstractly, this process can be viewed as having to push an <em>activation record</em> onto the stack and then popping it off. 
An <em>activation record</em> basically contains all the data like arguments being passed,
where the function is called from (so it can jump back), and the state of the callee.
Sounds like a complex task? Well it sort of is. When a function is inlined, the compiler puts the body of the function right at the call site.
So all this jumping and state saving doesn't need to occur. Let's look at another example of factoring out some code into an inline function:</p>
<pre><code class="language-c++">constexpr auto expFac = 0.83;
const auto pts = (person.getAge() * person.getGPA() 
    + expFac * person.getName().size()) * year;
</code></pre>
<p>VS</p>
<pre><code class="language-c++">inline auto getExperience(const Person &amp; person) {
    constexpr auto expFac = 0.83;
    return person.getAge() * person.getGPA() 
    + expFac * person.getName().size();
}

const auto pts = getExperience(person) * year;
</code></pre>
<p>For most compilers, the generated machine instructions will be pretty much the exact same, but the second option gives us greater readability.</p>
<p>A function can only be inlined if it is defined and declared in the same place. 
So an inline function cannot have separate declarations and definitions unless the declaration and definition are in the same file.</p>
<h2 id="constexpr-functions"><a class="header" href="#constexpr-functions">Constexpr Functions</a></h2>
<p>Like <code>constexpr</code> variables have values that are available at compile time, <code>constexpr</code> function have computations that <em>can be</em> available at compile time.
If you pass non-constexpr arguments to a <code>constexpr</code> function, the function will behave normally,
but if you pass literals or <code>constexpr</code> variables to a <code>constexpr</code> function,
the result will be computed at compile time, and the literal value will be inserted in the code.</p>
<p><code>constexpr</code> functions are implicitly inline as well.</p>
<p>Ex.</p>
<pre><code class="language-c++">constexpr int fact(int a) {
    if(a &lt;= 1) return 1;
    else return a * fact(a - 1);
}

constexpr auto my_number = 10;

int num = fact(my_number);
// num = 3628800 will be in the compiled binary

int num2 = fact(4);
// num = 24 will be in the binary

int num3 = fact(nonConstexprFunc());
// will behave like a normal function
</code></pre>
<p>We will explore more about <code>constexpr</code> and other ways of performing compile time calculations later. </p>
<h4 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h4>
<p><a href="https://github.com/Kikou1998/textbook/blob/master/A%20Tour%20of%20C%2B%2B%20(2nd%20Edition)%20(C%2B%2B%20In-Depth%20Series).pdf">A Tour of C++</a> 1.3</p>
<p><a href="https://github.com/ontiyonke/book-1/blob/master/%5BPROGRAMMING%5D%5BClean%20Code%20by%20Robert%20C%20Martin%5D.pdf">Clean Code</a> Chapter 3 (I <strong>highly</strong> suggest you read this)</p>
<p><a href="https://github.com/yanshengjia/cpp-playground/blob/master/cpp-primer/resource/C%2B%2B%20Primer%20(5th%20Edition).pdf">C++ Primer</a> Chapter 6</p>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-functions">C++ Core Guidelines</a> Functions</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Clean Code p. 34</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basics/references.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../basics/operators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basics/references.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../basics/operators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
