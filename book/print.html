<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Excursion through C++</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About</a></li><li class="chapter-item expanded "><a href="intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="basics/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="oop/overloads.html"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="templates/intro.html"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="templates/concepts.html"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="templates/variadic.html"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functional/lambdas.html"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="functional/functional_types.html"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="functional/algorithm.html"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="concurrency/locks.html"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="concurrency/atomic.html"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about"><a class="header" href="#about">About</a></h1>
<p>The goal of this project is to serve both as a resource for someone new to the language and a reference.
For those learning the language for the first time, there's quite a bit of detail contained in this, and I wouldn't expect
you to read all of it, much less know all of it from memory.</p>
<p>Through this guide we'll look briefly at tons of aspects of C++. My biggest goal is to at least guide you in the right direction
for more information, or give you the names of somethings that might be able to help you during your programming journey. In my
experience learning C++ on my own, I felt that I picked up some bad habits from having a less than ideal base knowledge. I don't claim
this guide is the end-all, be-all, one stop best place to learn C++ (or even anywhere close to it), but my hope is that I'm able to relay some advice
I gleaned from the experienced developers and resources I felt changed the way I write C++.
Hopefully, I'm able to start you down a path of writing idiomatic and clean modern C++,
and point you in the right direction towards more information.
I also hope I'm able to start good software engineering habits in those newer to the field.
See the <a href="resources.html">other resources page</a> for books that I think helped me a ton.</p>
<p>Please feel free to reach out with comments, criticisms, or questions, and let me know if you spot a typo,
mistake, or other error.</p>
<p>- 08/19/2021</p>
<blockquote>
<p>&quot;C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.&quot;</p>
<p>- Bjarne Stroustrup</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>First, let's get all of our tools setup. The most out of the box setup would probably be the Visual Studio IDE. 
However, for this book I'll be using tools that are typical in a Systems programming setting. Windows users might want to consider setting up <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">WSL</a> 
or using <a href="https://www.cygwin.com/">Cygwin</a></p>
<p>In any case, the first thing you'll need is a C++ compiler such as g++ and while we're at it, CMake as well. 
Linux users may simply run <code>sudo apt install g++ cmake -y</code>. Furthermore, we'll want a text editor. I would suggest Visual Studio Code. 
If you want to be hardcore you can also use Vim or anything else you would prefer. 
If you use Visual Studio (the IDE not VS Code), MSVC and CMake are installed when you select the C++ Desktop Development package in the installer.</p>
<p>You're more than welcome to use an IDE, but I will be giving instructions for operating on the command line. 
The GUIs and IDEs should be rather self-explanatory though. Due to the nature of working on embedded systems, I would suggest getting used to using the command line one way or another. 
You never know when the team laptop's UI dies...</p>
<p>C++ has a Standards Committee which agrees upon the specifications of the language. 
From there different vendors such as GNU and Microsoft implement their own compilers which adhere to the language specification. 
Furthermore, since 2011 the Standards Committee has agreed to release a new specification every 3 years. 
For this book we will be using C++17, and I will talk about a few points in C++20, but I will explicitly note when topics only apply to C++20. </p>
<p>So, enough introduction! Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Let's get coding! Create a file called <code>main.cpp</code>. Common file extensions for C++ source code are <code>.cpp</code>, <code>.cc</code>, and <code>.cxx</code>. Here's a Hello World program in C++</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>In the first line, we have this <code>#include</code> statement. This is a preprocessor directive which includes a <em>header file</em> into our current source file. 
We'll talk more about this later, but for now just know that this brings in the declarations of many IO utilities.</p>
<p>Next, we define our insertion point with the <code>main()</code> function. The <code>int</code> designates the return type as an integer. 
In C++, the main function returns <code>0</code> on success, and a non-zero error code on failure. Here we just return <code>0</code>. It's perfectly legal to not have the <code>return</code> statement in the main method.
In that case the return value is <code>0</code>. This is a special property of the <code>main()</code> function only. Everything else needs an explicit <code>return</code> statement.</p>
<p><code>std::cout</code> is an <em>output stream</em> that goes to standard out. Here we print the string <code>&quot;Hello World&quot;</code>, and then add the newline character and flush the stream with <code>std::endl</code>. 
If you just want a newline, you can just print <code>&quot;Hello World\n&quot;</code> directly, which is more efficient if you're doing a lot of printing since it avoids excess flushing. 
<code>&lt;&lt;</code> is an operator defined for <code>ostream</code>s like <code>std::cout</code>. The left-hand argument is a <code>std::ostream</code> and the right-hand argument is data to put onto the output stream. We'll talk more about IO later.</p>
<p>To build and run our code. We can invoke g++.</p>
<p><code>g++ main.cpp -o hello_world</code></p>
<p>This will compile our code and produce an executable called &quot;hello_world&quot;. Running it should yield:</p>
<blockquote>
<p>Hello World</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-cmake"><a class="header" href="#hello-cmake">Hello CMake</a></h1>
<p>We'll talk about CMake more in-depth later, but very quickly, what CMake does is abstract away the compiler from the build process. 
In the previous section, we explicitly invoked g++. But what if we have clang or msvc? That's where CMake comes in. </p>
<p>All CMake projects require a top-level <code>CMakeLists.txt</code> file which is used to generate the build files and invoke the compiler. 
CMake makes it easy when we start to develop projects with many source files and when we want applications to be cross-platform.</p>
<p>In the same directory we put <code>main.cpp</code>, let's create a new <code>CMakeLists.txt</code> file. </p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.8)
project(hello_world)
set(CMAKE_CXX_STANDARD 17)

add_executable(hello main.cpp)
</code></pre>
<p><code>cmake_minimum_required</code> sets the minimum cmake version that must be used to build the project. <code>project(hello_world)</code> creates a new Cmake project called hello_world. 
<code>set(CMAKE_CXX_STANDARD 17)</code> sets the C++ version to C++17. <code>CMAKE_CXX_STANDARD</code> is a variable, and <code>set()</code> sets that variable to a value. Finally <code>add_executable(hello main.cpp)</code> creates a new executable from the source file <code>main.cpp</code> and calls it <code>hello</code>.</p>
<p>Notice how nothing here is specific to g++.</p>
<p>Next, run <code>cmake -B out</code> which will generate the build files in a directory called out. If you don't specify the output directory with the <code>-B</code> flag, the default output directory is the same directory as the 
CMakeLists.txt file. To build it, <code>cd</code> into the <code>out</code> folder and invoke <code>make</code>. 
This will invoke the compiler through CMake-generated Makefiles and compile the executable. Once again, this should produce a file called <code>hello</code>, which upon execution should result in:</p>
<blockquote>
<p>Hello World</p>
</blockquote>
<p>For Windows: Cmake will use the Visual Studio generator and create project files which can be opened in Visual Studio and built like any other project. Therefore, do not invoke <code>make</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-a-guessing-game"><a class="header" href="#making-a-guessing-game">Making a Guessing Game</a></h1>
<p>I think that a guessing game is the stereotypical first thing to make after Hello World, so let's do that. 
To explore some more CMake features we'll be building off the previous &quot;project&quot;. 
In the same directory as <code>main.cpp</code>, add a new folder called <code>guessing_game</code> and create a <code>game.cpp</code> and another <code>CMakeLists.txt</code> file in that folder. 
So your directory should look something like this:</p>
<pre><code>project
|   CMakeLists.txt
|   main.cpp
|
|---guessing_game
|   |   CMakeLists.txt
|   |   game.cpp
|   |
|---out

</code></pre>
<p>In the top-level directory we want to tell cmake to include a subdirectory in the project. 
We do this with <code>add_subdirectory()</code>, so add the following line to the top-level CMakeLists file:</p>
<p><code>add_subdirectory(guessing_game)</code></p>
<p>Variables have scope in CMake like a programming language (CMake is Turing Complete).
Thus, in the guessing game CMakeLists, we don't need to set the C++ version again. All we need to have is the following:</p>
<pre><code class="language-cmake">add_executable(guessing_game game.cpp)
</code></pre>
<p>Let's also enable all warnings. We can do this with the following in the top-level <code>CMakeLists.txt</code>.</p>
<pre><code class="language-cmake">if (MSVC) 
    add_compile_options(/W4 /WX)
else ()
    add_compile_options(-Wall -Werror)
endif ()
</code></pre>
<p><code>add_compile_options</code> adds compiler flags to all targets, whereas <code>target_compile_options</code> adds them to a single target (such as a single executable). 
It's good practice to enable the highest warning level and treat all warnings as errors. The above snippet provides flags to do this depending on the compiler.</p>
<p>So this is the complete top-level CMakeLists.txt:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.8)
project(hello_world)
set(CMAKE_CXX_STANDARD 17)

if (MSVC)
    add_compile_options(/W4 /WX)
else ()
    add_compile_options(-Wall -Werror)
endif ()

add_executable(hello main.cpp)

add_subdirectory(guessing_game)
</code></pre>
<p>Now let's add some basic starter code.</p>
<pre><code class="language-c++">#include&lt;iostream&gt;

int main() {

    std::cout &lt;&lt; &quot;Guess a number:&quot; &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>This is basically just a glorified Hello World, but let's make sure our project was setup correctly. 
Running <code>cmake -B out</code> again should generate a new folder <code>guessing_game</code> in the output directory.
Invoking <code>make</code> in the <code>out</code> directory should compile an executable <code>guessing_game</code> in the guessing_game folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coding-the-guessing-game"><a class="header" href="#coding-the-guessing-game">Coding the Guessing Game</a></h1>
<p>Don't worry about understanding everything right now, all these features will be explained in more detail later.
I just want you to get a feel for C++ right now.</p>
<h2 id="generating-a-random-number"><a class="header" href="#generating-a-random-number">Generating a Random Number</a></h2>
<p>Let's write a function to generate a random number. First include the <code>&lt;random&gt;</code> header. </p>
<pre><code class="language-c++">auto getRandNumBetween(int min, int max) {
    std::random_device rd; //use a source of randonness in the hardware
    // another common seed is to use the current time
    std::mt19937 generator(rd()); //rd() computes a seed for the mt19937 generator
    std::uniform_int_distribution distrib(min, max);
    return distrib(generator); // computes a random number between min and max
}
</code></pre>
<p><code>std::random_device</code> is in it of itself, a random number generator of sorts. 
It overloads the function <code>operator()</code> to allow the parenthesis syntax <code>rd()</code>, which is the same for calling a function. 
<code>random_device</code> is known as a callable object because it overloads <code>operator()</code>. 
We use the number returned from <code>operator()</code> of the random device to seed a Mersenne Twister random number generator
by passing the computed seed from <code>rd</code> to the constructor of <code>generator</code>. 
A constructor is a function used to initialize an object. 
<code>generator</code> is then used as an argument to <code>operator()</code> of the uniform integer distribution between <code>min</code> and <code>max</code>. 
Once again the uniform distribution is a callable object, something we'll talk more about later, but unlike <code>rd</code>, its <code>operator()</code> takes an argument;
namely the random number generator to use. 
<code>min</code> and <code>max</code> are passed as arguments to the constructor of <code>uniform_int_distribution</code>. </p>
<p>Unlike <code>main</code>, this function has a &quot;return type&quot; of <code>auto</code>. 
<code>auto</code> is not an actual type, instead it's indicating that the compiler should figure out what the return type is. In this case it's <code>int</code>.</p>
<p>I'll admit, that for something simple like this, I might use C's <code>rand()</code> function. 
This function always returns an integer between <code>0</code> and <code>RAND_MAX</code> and is seeded by calling the function <code>srand(seed)</code>. 
So an alternative implementation would be:</p>
<pre><code class="language-c++">auto getRandNumBetween(int min, int max) {
    srand(clock()); //seed the random number generator with the current time
    return rand() % (max - min) + min;
}
</code></pre>
<p>I'll stick to the previous implementation for the game.
I should also note that you should not use <code>rand()</code> for something that relies on randomness. <sup class="footnote-reference"><a href="#1">1</a></sup></p>
<blockquote>
<p>&quot;The <random> library is what a random library wants to be when it grows up. As a result, beginners use rand()&quot;</p>
<p>- Bjarne Stroustrup</p>
</blockquote>
<h2 id="getting-user-input"><a class="header" href="#getting-user-input">Getting User Input</a></h2>
<p>Let's create another function to get input from the user.</p>
<pre><code class="language-c++">auto getUserGuess() {
    auto guess = 0;
    std::cin &gt;&gt; guess;
    return guess;
}
</code></pre>
<p>We first initialize a new variable called <code>guess</code>. Once again, let's use type deduction and declare this variable with <code>auto</code>. 
We'll cover this more later, but you should generally always use <code>auto</code>. 
It might seem like an extra letter to type now (as opposed to <code>int</code> which is the type the compiler will infer <code>guess</code> to be),
but it will save a bunch of headaches later. 
Next, we parse whatever the user types in standard input as an integer, and store the result into <code>guess</code>. Finally, we return <code>guess</code>.</p>
<p>Now what if a user doesn't type a number? Well, the way we are parsing the input right now, any non numeric input will just be converted to <code>0</code>. 
This is not ideal. So instead, let's implement the function another way. We'll now need the <code>&lt;string&gt;</code> header for this:</p>
<pre><code class="language-c++">auto getUserGuess() {
    std::string guessStr;
    std::getline(std::cin, guessStr);
    return std::stoi(guessStr);
}
</code></pre>
<p>Here, we use <code>std::getline</code> to get a line from <code>std::cin</code> and store the result in <code>guessStr</code>.
<code>guessStr</code> is an output parameter, something you really should strive to avoid when creating your own functions.
Now what do we get when we type something that's not a number? Well we get:</p>
<blockquote>
<p>terminate called after throwing an instance of 'std::invalid_argument'</p>
<p>what(): stoi</p>
</blockquote>
<p>What's going on is that <code>stoi</code> has thrown an exception, <code>std::invalid_argument</code>. Any exception thrown out of <code>main</code> terminates the program. 
This might seem worse, but we can improve upon this by catching the exception. Let's factor out the exception handling code and make a helper function.</p>
<pre><code class="language-c++">auto getUserInput() {
    std::string guessStr;
    std::getline(std::cin, guessStr);
    return std::stoi(guessStr);
}

auto printNonNumMsg() {
    std::cout &lt;&lt; &quot;You may only guess integers.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Please guess again:&quot; &lt;&lt; std::endl;
}

auto getUserGuess() {
    try {
        return getUserInput();
    } catch (const std::invalid_argument &amp; exn) {
        printNonNumMsg();
        return getUserGuess();
    }
}

</code></pre>
<p><code>getUserInput()</code> is what previously was called <code>getUserGuess()</code>. 
Now <code>getUserGuess()</code> tries to get a number from the user, and if that fails with <code>std::invalid_argument</code> it will print an error message and recurse, trying again. 
The catch block catches <code>invalid_argument</code> by <em>reference</em> which is denoted by <code>&amp;</code>. So instead of copying the exception, we essentially copy the address. 
We declare this reference <code>const</code> so we can't mutate it, which is good practice; you should make everything that can be <code>const</code>, <code>const</code>. 
Besides being more efficient in many cases, passing by reference also allows this catch block to behave <em>polymorphically</em> and accept any 
subtypes of <code>std::invalid_exception</code>(which there are none in the standard library, but it's always good to catch exceptions by reference for this reason)</p>
<h2 id="wiring-it-up"><a class="header" href="#wiring-it-up">Wiring it Up</a></h2>
<p>Let's return to our <code>main()</code> function to finish the game. 
First we'll get a random number and store it in a constant. Then we'll loop until the user's guess equals that number. 
Since we won't be updating the range of possible random numbers during runtime, it's a good idea to make the min and max values <code>constexpr</code>. 
This means that not only are the values constant, but they're also available at compile time. 
Therefore, in the compiled code they don't take up space, instead the compiler just inserts the literal values into the code whenever they are used.</p>
<pre><code class="language-c++">
constexpr auto min_value = 0;
constexpr auto max_value = 100;

int main() {
    const auto secretNum = getRandNumBetween(min_value, max_value);
    auto guess = 0;
    do {
        std::cout &lt;&lt; &quot;Guess a number between &quot; 
            &lt;&lt; min_value &lt;&lt; &quot; and &quot; &lt;&lt; max_value &lt;&lt; std::endl;
        guess = getUserGuess();

        if (guess &lt; secretNum) {
            std::cout &lt;&lt; &quot;Too low!&quot; &lt;&lt; std::endl;
        } else if (guess &gt; secretNum) {
            std::cout &lt;&lt; &quot;Too high!&quot; &lt;&lt; std::endl; 
        }
    } while (guess != secretNum);
}

</code></pre>
<p>Here, we use a do-while loop, which is like a while loop except it always performs at least one iteration. 
They can be harder to reason about and are somewhat controversial. 
Notice we also declare <code>secretNum</code> constant since it cannot change. </p>
<p>We can use Uncle Bob's <em>step-down rule</em> and clean this up a bit by factoring out the prints into other function. 
Basically, his idea is that a function should have only one level of abstraction. This one has a few: the high level <code>getUserGuess()</code> and <code>getRandNumBetween()</code> and the low level <code>cout</code>s. So here's the final code:</p>
<h2 id="final-code"><a class="header" href="#final-code">Final Code</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;string&gt;

constexpr auto min_value = 0;
constexpr auto max_value = 100;

auto getRandNumBetween(int min, int max) {
    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution distrib(min, max);
    return distrib(generator);
}

/**
 * @return the number input by the user
 * @throw std::invalid_argument if the user doesn't type a number
 */
auto getUserInput() {
    std::string guessStr;
    std::getline(std::cin, guessStr);
    return std::stoi(guessStr);
}

auto printNonNumMsg() {
    std::cout &lt;&lt; &quot;You may only guess integers.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Please guess again:&quot; &lt;&lt; std::endl;
}
/**
 * Prompts the user for an integer
 */
auto promptGuess() {
    std::cout &lt;&lt; &quot;Guess a number between &quot; 
        &lt;&lt; min_value &lt;&lt; &quot; and &quot; &lt;&lt; max_value &lt;&lt; std::endl;
}
/**
 * Gets a user's guess. Continues to prompt for a number if the
 * user does not type a number
 */
auto getUserGuess() {
    try {
        promptGuess();
        return getUserInput();
    } catch (const std::invalid_argument &amp; exn) {
        printNonNumMsg();
        return getUserGuess();
    }
}
/**
 * Displays a hint based on the user guess
 * @param actual the real number
 */
auto displayGuessHint(int guess, int actual) {
    if (guess &lt; actual) {
        std::cout &lt;&lt; &quot;Too low!&quot; &lt;&lt; std::endl;
    } else if (guess &gt; actual) {
        std::cout &lt;&lt; &quot;Too high!&quot; &lt;&lt; std::endl; 
    }
}

/**
 * Tells the user they guessed num correctly
 * @param num the correct number
 * @param tries the amount of tries to guess correctly
 */
auto displayWin(int num, int tries) {
    std::cout &lt;&lt; &quot;Congrats! You guessed &quot; &lt;&lt; num 
        &lt;&lt; &quot; correctly in &quot; &lt;&lt; tries &lt;&lt; &quot; tries!\n&quot;;
}

int main() {
    const auto secretNum = getRandNumBetween(min_value, max_value);
    auto guess = 0;
    auto tries = 0;
    do {
        ++tries;
        guess = getUserGuess();
        displayGuessHint(guess, secretNum);
    } while (guess != secretNum);
    displayWin(secretNum, tries);
}
</code></pre>
<p>One thing to note is that we define all of our functions before they are used. This is necessary in C++ because the compiler
essentially compiles the code line by line, and it needs to know the definition of things before it sees it in use.
It's a good idea to put the function definitions close to where they are going to be called. It's also good to keep functions within about 80 characters wide and 20 lines long. 
Is this a hard and fast rule? No, far from it but I think it's a nice guideline that can help keep functions short, which is generally accepted as easier to reason about and thus
less error prone. Most of a developer's time is spent reading code, so it's worthwhile to put in the effort to make that part of the job easier.</p>
<p>Is this over-engineered? Probably. But I really think it's beneficial to start good habits now instead of having to unlearn bad ones later.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Something like a Monte Carlo simulation or an algorithm that relies on randomization to be efficient.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>A great source of information would be <a href="https://github.com/Kikou1998/textbook/blob/master/A%20Tour%20of%20C%2B%2B%20(2nd%20Edition)%20(C%2B%2B%20In-Depth%20Series).pdf">A Tour of C++ 2nd Edition</a>.
<a href="https://github.com/yanshengjia/cpp-playground/blob/master/cpp-primer/resource/C%2B%2B%20Primer%20(5th%20Edition).pdf">C++ Primer 5th Edition</a> 
is also very thorough but is more geared towards those without much programming experience.</p>
<p>If you're into video tutorials, I have heard that <a href="https://www.youtube.com/channel/UCQ-W1KE9EYfdxhL6S4twUNw">The Cherno Project</a> is a good resource,
although I've never watched them myself. I watched <a href="https://caveofprogramming.teachable.com/courses">John Purcell</a> whose videos are at
a pace for completely new/beginner programmers.</p>
<blockquote>
<p>&quot;Software is like sex: it's better when it's free.&quot;</p>
<p>- Linus Torvalds</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Here are some examples of control flow in C++</p>
<h4 id="if"><a class="header" href="#if">If</a></h4>
<pre><code class="language-c++">if(/* condition */) {

}
</code></pre>
<pre><code class="language-c++">if(/* condition */) {

} else {

}
</code></pre>
<pre><code class="language-c++">if(/* condition */) {

} else if(/* condition */) {

} else {

}
</code></pre>
<h4 id="for-loop"><a class="header" href="#for-loop">For Loop</a></h4>
<pre><code class="language-c++">for(/* initializer */;/* guard */;/* expression */) {

}

for(auto i = 0; i &lt; 100; ++i) {

}
</code></pre>
<p>With for loops you can leave out one, or multiple of the parts of the loop such as:</p>
<pre><code class="language-c++">auto i = // complex computation
for(; i &lt; 100; ++i){

}
</code></pre>
<p>There is an actual difference between pre and post-increment (<code>++</code>). Applying <code>++</code> before a variable increments the variable and returns the new value. 
Applying <code>++</code> after the variable returns the old value and increments the variable. 
Thus, pre-increment can have better performance since it does not need to create a copy of the old value. 
For integers, the difference is negligible but for iterators or a user-defined type that implements <code>operator++()</code>, this may be important.</p>
<h4 id="while-loop"><a class="header" href="#while-loop">While Loop</a></h4>
<pre><code class="language-c++">while(/*condition*/) {

}

do {

} while(/*condition*/);
</code></pre>
<h4 id="switch"><a class="header" href="#switch">Switch</a></h4>
<pre><code class="language-c++">auto num = // ...

switch(num) {
    case 0:
    {
        // use {} to create a new scope for new variables
        auto res = /* ... */;
        break;
    }
    case 1:
        // ... 
        break;
    case 2:
    case 3:
        // this code executed when num is 2 or 3
        // ...
        break;
    case 4:
        // .. some code
    [[fallthrough]] // denote that we intend this case to fall through
    case 5:
        // code executed when num is 4 or 5
        break;
    default:
        // when num is everything else
}       


//Simpler Example:

switch(num) {
    case 0:
        //...
        break;
    case 1:
        // ...
        break;
    default:
        break;
}
</code></pre>
<p>Switches are pretty much just glorified <code>goto</code>s, and we'll talk about how they work under the hood later. 
The variable being switched upon must be an integral type such as a <code>char</code>, <code>int</code>, <code>short</code>, etc. Therefore, unlike other languages, strings don't work in switches. 
The code will jump to the case labelled with the value that is equal to the variable being switched upon. From there it will continue executing line after line until it reaches a <code>break</code>. 
This allows us to fallthrough from one case to another. Intended fallthrough should be avoided, but if necessary it should be labelled with the <code>[[fallthrough]]</code> attribute like shown above.</p>
<h4 id="infinite-loop"><a class="header" href="#infinite-loop">Infinite Loop</a></h4>
<pre><code class="language-c++">
for(;;) {

}

while(true) {

}
</code></pre>
<p>If you leave out the guard of the <code>for</code> loop like shown above, a constant which evaluates to <code>true</code> is put in its place.</p>
<h4 id="break-and-continue"><a class="header" href="#break-and-continue">Break and Continue</a></h4>
<pre><code class="language-c++">for(/*...*/) {
    if(/*...*/) break; //exit loop
    else if(/* ... */) continue; //skip rest of code and go to next loop iteration
}

for(/*...*/) {
    for(/*...*/){
        if (/*...*/) goto dblBreak;
    }
}
dblBreak:
</code></pre>
<p><code>goto</code> is not something you generally want to use (or even have to). 
Here's a funny story: the first time I needed an unconditional jump, I actually didn't know C++ had a <code>goto</code>, so instead I used inline assembly only to think how
pointless it was to write something so simple in assembly. And that's the day I discovered C++ did indeed have a <code>goto</code>. 
The only good usage I can think of off the top of my head is to break out of nested loops like so. We first create a label by typing a name followed by a colon, then we put that name after <code>goto</code> to jump to it.</p>
<h3 id="comma-operator"><a class="header" href="#comma-operator">Comma Operator</a></h3>
<p>The comma operator will execute the operations in order, from left to right but will only return the result of the last expression.</p>
<pre><code class="language-C++">const auto y = 10, 20;
// y = 20;

const auto x = y++, ++y, y++;
// y = 23
// x = 22
</code></pre>
<h3 id="ternary-operator"><a class="header" href="#ternary-operator">Ternary Operator</a></h3>
<p>This operator looks like <code>&lt;condition&gt; ? &lt;true_branch&gt; : &lt;false_branch&gt;</code>.
If the condition is true, it will evaluate the expression on the left side of the colon,
otherwise it will evaluate the expression on the right side.</p>
<pre><code class="language-C++">const auto age = 10;

const auto free_time = age &lt; 16 ? 8 : 1;
// free_time is 8
</code></pre>
<h4 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h4>
<p><a href="https://github.com/yanshengjia/cpp-playground/blob/master/cpp-primer/resource/C%2B%2B%20Primer%20(5th%20Edition).pdf">C++ Primer 5th Ed</a> 1.4 - 1.4.4 and 5.3 - 5.5.3</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th><strong>Typical</strong> Size</th></tr></thead><tbody>
<tr><td>bool</td><td>8 bits</td></tr>
<tr><td>char</td><td>8 bits</td></tr>
<tr><td>short</td><td>16 bits</td></tr>
<tr><td>int</td><td>32 bits</td></tr>
<tr><td>long</td><td>32 bits</td></tr>
<tr><td>long long</td><td>64 bits</td></tr>
</tbody></table>
</div>
<p>The standard only stipulates that <code>sizeof(char) == 1</code> and <code>sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code>.</p>
<p>Except for bool, these types can be signed or unsigned. The standard does not specify the size of <code>bool</code>.</p>
<pre><code class="language-c++">
char c; // [-2^7 to 2^7 - 1]
unsigned char c2; // [0 to 2^8]

</code></pre>
<p>We also have floating-point types: <code>float</code>, <code>double</code> and <code>long double</code>.
The standard only requires that <code>double</code> provides at least as much precision as <code>float</code> and that <code>long double</code> provides at least as much as <code>double</code>.
On x86 systems, <code>float</code> is typically 32 bits, <code>double</code> is typically 64, and <code>long double</code> is commonly 80 or 128.</p>
<p>C++ also has literal type specifiers to convert a literal value to a certain type.
A literal is something that's already a value and cannot be assigned such as <code>42</code> or <code>0.0</code>.</p>
<pre><code class="language-c++">
auto f = 0.1f; // f is a float
auto d = 0.1; // d is double
auto u = 10u; // unsigned int
auto lng = 20l; // long
auto ulng = 20ul; // unsigned long
auto ullng = 200ull; // unsigned long long
auto i = 200; // i is int
auto ch = 'H'; // char

</code></pre>
<p>Finally, we can also input numbers in different bases such as hex, octal or binary and use the single quote <code>'</code> as a digit separator to make things more readable.</p>
<pre><code class="language-c++">auto h = 0xA; //h  is the integer 10
auto oct = 024; //oct is the integer 14
auto bin = 0b11; // bin is the integer 3

auto pi = 3.14159'26535'89793'23846'26433'83279'50288;
</code></pre>
<p>Hex and binary are pretty important in systems programming so make sure you read up on that if you're unfamiliar.</p>
<h2 id="implicit-type-conversions"><a class="header" href="#implicit-type-conversions">Implicit Type Conversions</a></h2>
<p>Implicitly, signed values become unsigned when you mix the two. Thus, we never want to have signed/unsigned mismatches and that's one thing <code>auto</code> helps prevent.</p>
<pre><code class="language-c++">const auto num = 10;
auto n2 = num - 20u; // 2^32 - 10
</code></pre>
<p>The following type conversions are implicit, where a type can be converted to any type to the right of it:</p>
<p><code>char -&gt; short -&gt; int -&gt; long -&gt; long long -&gt; float -&gt; double</code>.</p>
<p><code>bool</code> can be implicitly converted to any integral type. <code>true</code> becomes <code>1</code> and <code>false</code> becomes <code>0</code>. Integral types convert to <code>bool</code> where <code>0</code> is <code>false</code> and everything else is <code>true</code>.</p>
<p>If a value goes out of range on an unsigned integral type, the value wraps back around from the lowest point in that type's range. Out of range on signed types is <em>undefined</em>.</p>
<h4 id="further-reading-1"><a class="header" href="#further-reading-1">Further Reading</a></h4>
<p><a href="https://github.com/yanshengjia/cpp-playground/blob/master/cpp-primer/resource/C%2B%2B%20Primer%20(5th%20Edition).pdf">C++ Primer</a> 2.1 - 2.1.3</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>We've already used quite a lot of variables already. So we'll skip the formalities.</p>
<h3 id="const-correctness"><a class="header" href="#const-correctness">Const Correctness</a></h3>
<p>As I previously mentioned, anything that can be <code>const</code> should be <code>const</code>. A <code>const</code> &quot;variable&quot; is one whose value cannot change. 
It's good practice to make <code>const</code> variables the default and mutable variables the exception. 
Mutability makes things harder to reason about and const correctness is another form of type safety.
Like an unsigned vs signed primitive type, a const and non-const type are two fundamentally different types. 
A non-constant can be automatically converted to a constant version of the type, but not the other way around.</p>
<pre><code class="language-c++">const auto num = 23;
auto mutNum = 32;

num += 10; //error
mutNum += 10; //good
</code></pre>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>In many languages, when you declare a variable, it is set to a default value. 
This isn't the case in C++ since there's no reason for the extra instruction to set a default if the programmer is going to set it to something else anyway. 
It's part of the &quot;pay for only what you use&quot; mentality of C++.
Thus, if you don't initialize a primitive variable to a value, it essentially holds a garbage value. 
What really happens is it will just keep whatever bytes in memory happen to be where the variable now occupies. 
Therefore, <strong>you should always initialize your variables</strong>. This is one of the reasons why it's good practice to 
declare variables to have type <code>auto</code>: the compiler needs an initial value to figure out what type the variable is,
so using <code>auto</code> will prevent you from forgetting to initialize your variables.</p>
<p>Now you might be asking: &quot;now hold on, you're saying to manually give each of my variables a default value?
So then what's the point of the compiler not doing it?&quot; Well, if you <em>introduce the variable immediately before you need it (and no earlier)</em>, 
chances are the initial value you set it to has some bearing on your computation. 
So you don't necessarily initialize a variable to some default value every time,
you initialize it with something that should be based on the logic of your program.</p>
<pre><code class="language-c++">int a;
std::cout &lt;&lt; a &lt;&lt; std::endl; // this could print any integer. We don't know what


int powi(int base, unsigned exp) {
    auto res = 1; // initial value of 1 has bearing on computation
    for(auto i = 0u; i &lt; exp; ++i) {
        res *= base;
    }
    return res;
}
</code></pre>
<p>Notice how <code>res</code> is introduced right when we need it, and therefore has an initial value which has a meaning for our computation.
Moreover, defining variables as late as possible (and in the smallest scope its needed) makes code easier to read. </p>
<p>Global and static variables, on the other hand, are initialized to their default value. For most basic data types this is <code>0</code>.</p>
<h3 id="names"><a class="header" href="#names">Names</a></h3>
<p>Part of the challenge of programming is giving good names to variables. You want your variables to be self-documenting. Consider the following:</p>
<pre><code class="language-c++">long timeout; ///&lt; socket timeout in milliseconds
</code></pre>
<p>vs</p>
<pre><code class="language-c++">long sockTimeoutMs;
</code></pre>
<p>or even better:</p>
<pre><code class="language-c++">std::chrono::milliseconds socketTimeout;
</code></pre>
<p>Notice we don't need to repeat information encoded by the type.</p>
<p>We also want to be consistent with our variable names. A good rule of thumb is one word per concept. 
For example, it's best not to have some names with <code>length</code> and others with <code>size</code> when they refer to the same idea such as the size of a container.</p>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>The variables we have seen have <em>automatic lifetimes</em>. This means that when their <em>scope</em> ends, they are popped off the stack. 
The stack is an area in memory. Each program is allocated its own stack of limited size. When a variable is declared, it
is pushed on the stack. When a variable goes out of scope, the variable is destroyed and popped off the stack. Having a stack
structure allows variables to be destroyed in the reverse order that they were declared. This allows one variable to depend on another.
We may talk more about this later but for now, know that these variables of built-in types we have been working with are pushed on the stack when 
they are declared and popped off when they go out of scope. </p>
<p>So what is this scope I talk about?
A scope roughly corresponds to a block, which are delimited by <code>{}</code> pairs. 
The local scope is the scope of a function; variables in this scope are destroyed when the function returns. 
The class scope is the scope of class members. Values in this scope are initialized when an instance of the object is created
and destroyed when that same instance is destroyed. 
Finally, the namespace scope is the scope of a namespace. Variables in this scope are destroyed when the program ends.</p>
<pre><code class="language-c++">{
    auto a = 3;
    // a can be used here


} // a goes out of scope here

// a cannot be used here
</code></pre>
<pre><code class="language-C++">class Foo {
    // start class scope
    int a;
public:
    
    void bar() {
        // start function scope
        if (a == 3) {
            // inner scope for if
            int c = a * 3;
        } else {
            // scope for else
            // c cannot be accessed here
        }

        // c cannot be accessed here


    } // end function scope


}; // end class scope


int main() {
    Foo foo; // Foo.a created here
} // Foo is destroyed here, and so is Foo.a
</code></pre>
<h3 id="globals"><a class="header" href="#globals">Globals</a></h3>
<p>Global variables are variables that are defined outside any scope (not within a function or curly braces). 
Unless they are immutable, you should avoid globals. In the words of Bjarne Stroustrup: &quot;global variables should have names starting with //&quot;. 
This is because the order of variable initialization between <em>compilation units</em> (different source files) is undefined.
So if we use a global variable outside the source file it is defined in, then there is the chance we may try to use a variable
that hasn't been created yet or has already been destroyed. Specifically, this occurs if we use a global
in the constructor or destructor of a class with a global instance. A constructor is a function that is called at
the initialization of a variable, and a destructor is called at the destruction of a variable. More on this later.</p>
<p>Globals also make code harder to reason about since it's harder to tell when a function or class depend on them.
This is something we'll talk about more later.</p>
<pre><code class="language-c++">const auto globalVar = 10;

int main() {
    auto localVar = 0;
    return 0;
}
</code></pre>
<h4 id="further-reading-2"><a class="header" href="#further-reading-2">Further Reading</a></h4>
<p><a href="https://github.com/Kikou1998/textbook/blob/master/A%20Tour%20of%20C%2B%2B%20(2nd%20Edition)%20(C%2B%2B%20In-Depth%20Series).pdf">A Tour of C++</a> 1.4 - 1.6</p>
<p><a href="https://github.com/ontiyonke/book-1/blob/master/%5BPROGRAMMING%5D%5BClean%20Code%20by%20Robert%20C%20Martin%5D.pdf">Clean Code</a> Chapter 2 (I <strong>highly</strong> suggest you read this)</p>
<p><a href="https://github.com/yanshengjia/cpp-playground/blob/master/cpp-primer/resource/C%2B%2B%20Primer%20(5th%20Edition).pdf">C++ Primer</a> 2.2 - 2.3</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>References are basically aliases for another variable. The reference refers to the data owned by a different variable.</p>
<pre><code class="language-c++">int number = 5;
int &amp; numRef = number;
numRef = 10;
std::cout &lt;&lt; number &lt;&lt; std::endl; // 10
</code></pre>
<p>Although we changed the reference, the variable <code>number</code> that it refers to also changed. 
This is because both <code>number</code> and <code>numRef</code> share the same memory location. We can think of <code>number</code> as owning the actual integer data, and <code>numRef</code> as owning an address that points to that data.</p>
<div class="table-wrapper"><table><thead><tr><th><code>number</code></th></tr></thead><tbody>
<tr><td>5</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><code>numRef</code></th></tr></thead><tbody>
<tr><td><code>&amp;number</code></td></tr>
</tbody></table>
</div>
<p>We can also demonstrate this with <code>auto</code> as well. It works the exact same as you'd expect.</p>
<pre><code class="language-c++">auto data = 0.10;
auto&amp; data2 = data;

data = 3.14;

std::cout &lt;&lt; data2 &lt;&lt; std::endl; //3.14
</code></pre>
<p>Since a reference basically just stores the address in memory of the data, then for complex types references prevents excess copying of the data. 
Instead of copying, the reference binds to the object it refers to.</p>
<pre><code class="language-c++">
std::string state = &quot;New York&quot;;

auto cpyOfState = state; // copy the string

auto &amp; noCopy = state; // reference
</code></pre>
<p>References can be <code>const</code>. A <code>const</code> reference cannot mutate the underlying data it refers to.</p>
<pre><code class="language-c++">const auto &amp; state2 = state;
state2 = &quot;Hawaii&quot;; // error

state = &quot;Alaska&quot;;

std::cout &lt;&lt; state2 &lt;&lt; &quot;\n&quot;; //Alaska
</code></pre>
<p>We cannot have references of references and references must always be bound upon initialization.</p>
<pre><code class="language-c++">int &amp; ref; // error, reference not bound
</code></pre>
<h2 id="dead-references"><a class="header" href="#dead-references">Dead References</a></h2>
<p><strong>A reference must have a lifetime that is completely within the lifetime of the object it refers to.</strong> Consider the following:</p>
<pre><code class="language-c++">std::string &amp; getStr() {
    const auto msg = &quot;Hello &quot; + std::string(&quot;World&quot;);
    return msg;
}

auto&amp; msg2 = getStr();
std::cout &lt;&lt; msg2 &lt;&lt; &quot;\n&quot;;
</code></pre>
<p><code>msg</code> goes out of scope, and its memory is freed at the end of <code>getStr()</code>. Yet we are returning a reference to <code>msg</code> past the end of its lifetime! 
So <code>msg2</code> is a <em>dangling reference</em> (or <em>dead reference</em>) because the data it refers to is invalid. 
So what's going to happen here? We don't know. Our program might terminate with a memory access violation, it might seem to work and occasionally print garbage, or it might set our computer on fire. 
It's <em>undefined behavior</em>.</p>
<p>If you're compiling on <code>-Werror</code> or <code>/WX</code> the compiler will stop you from doing this.</p>
<p>Here's another example: (which won't compile)</p>
<pre><code class="language-c++">std::vector&lt;std::string&amp;&gt; lotsOfText;

void process() {
    std::ifstream reader(&quot;someFile.txt&quot;);
    std::string book{
        std::istream_iterator&lt;char&gt;(reader),
        std::istream_iterator&lt;char&gt;()};
    // read entire file into book
    // file could be huge, we don't want to copy that
    lotsOfText.push_back(book);

}

void consume(unsigned id) {
    std::cout &lt;&lt; lotsOfText[id] &lt;&lt; std::endl; 
}
</code></pre>
<p><code>book</code> goes out of scope at the end of <code>process()</code>. Yet we have no idea when <code>consume()</code> will be called. 
By that time, the data referred to by the references in <code>lotsOfText</code> will likely have gone out of scope, and <code>consume()</code> will access a dangling reference. 
In general (and we'll talk about this later) you don't want containers (such as <code>std::vector</code>) to store references. 
In fact, the compiler won't let you. This doesn't mean you're forced to copy the data however, and we'll see some neat features that deal with this in later chapters.</p>
<p>When creating a reference to a variable. The reference must not drop any qualifiers. 
Qualifiers are things such as <code>const</code> or <code>volatile</code> that qualify the type of the variable. This rule ensures that no const variable has its data mutated out from under it.</p>
<pre><code class="language-C++">const auto num = 5;
int&amp; num2 = num; // error
const int&amp; num3 = num; //good
</code></pre>
<h1 id="pointers"><a class="header" href="#pointers">Pointers</a></h1>
<p>The <code>&amp;</code> symbol when it comes before a name can be read as &quot;address of&quot; and <code>*</code> before a name is known as the dereference operator and can be read as &quot;value of&quot;. 
The result of the <code>&amp;</code> operator is an address to the underlying value. An address is just a number, but it cannot be stored in a regular integral type. 
It must be stored in a pointer. As we saw with references, a pointer does not own the value, it owns a copy of the address which points to the underlying data.</p>
<p>Pointers are arithmetic types, and adding or subtracting from them will add or subtract the size of the type that they point to from the address. 
Unlike references, pointers don't have to be initialized. This is not very safe. At the very least, you should set invalid pointers to <code>nullptr</code>, a value reserved for invalid pointers. 
Trying to dereference an invalid/dangling/null pointer is <em>undefined behavior</em>. With references, creating such deadly situations is much harder since a reference must always be initialized with a value, 
and most compilers will stop you from taking a reference beyond the lifetime of the object it refers to in some cases.</p>
<pre><code class="language-C++">int num = 5;
int * num2 = &amp;num;
*num2; //5
*num2 = 10;

num2++; //increment the address stored in num2 by sizeof(int)
//now num2 is a dangling pointer
num2 = nullptr; // mutate the pointer itself, not its data
num; //10

</code></pre>
<p>A <code>const</code> that goes before the <code>*</code> in the type declaration of a pointer means that the data pointed to cannot change. 
A <code>const</code> after the <code>*</code> means that the address the pointer stores cannot change.</p>
<pre><code class="language-C++">const char * hello = &quot;hello&quot;;
*hello = 'g'; //error
hello = &quot;goodbye&quot;; // good

auto num1 = 5;
auto num2 = 10;
int * const num = &amp;num2;
*num = 10; //good
num = &amp;num2; //error


const int * const num3 = &amp;num2;
*num3 = 20; //error
num3 = &amp;num1; //error
</code></pre>
<p>In the use cases I've demonstrated so far, a reference is preferable to a pointer unless its data truly cannot be known when it is declared. 
Pointers are really remnants from C, and there are safer C++ mechanics to do the job of pointers in most cases.</p>
<h4 id="further-reading-3"><a class="header" href="#further-reading-3">Further Reading</a></h4>
<p><a href="https://github.com/Kikou1998/textbook/blob/master/A%20Tour%20of%20C%2B%2B%20(2nd%20Edition)%20(C%2B%2B%20In-Depth%20Series).pdf">A Tour of C++</a> 1.7</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>As we have seen, if functions are not declared and defined separately, we can use <code>auto</code> to have the compiler use type deduction on the return type. 
Otherwise, just like function parameters, the return type must be specified.</p>
<pre><code class="language-c++">void printHello(); //declaration


int main() {
    printHello();
    return 0;
}

void printHello() {
    //definition
    std::cout &lt;&lt; &quot;Hello\n&quot;;
}
</code></pre>
<p>Declaring a function ahead of its definition like in the above snippet is known as <em>forward declaring</em>. 
It allows us to not have to manually ensure that every function is defined in topological order. 
It basically tells the compiler &quot;hey, I'm going to define this later so if you see this name before you see its definition don't freak out.&quot;</p>
<p><code>void</code> is a special type that essentially means there is no type. We can use it for functions that don't return anything. </p>
<p>Functions can be <em>pass-by-value</em> or <em>pass-by-reference</em>. When a function is pass-by-value, the function parameter gets copied.
When it's pass-by-reference the actual object is not passed to the function, but the address of the object is.</p>
<pre><code class="language-c++">
void add(int a) { // pass by value (copy data)
    a += 5;
    std::cout &lt;&lt; a &lt;&lt; std::endl;
}

void addRef(int &amp; b) { // pass by reference (bind alias to same piece of data)
    b += 5;
}

int main() {
    auto num = 0;
    add(num);
    // num is still 0 but 5 is printed
    addRef(num);
    // num is now 5
    return 0;
}
</code></pre>
<p>In <code>add()</code> a new copy of <code>num</code> is created which is called <code>a</code>. <code>a</code> goes out of scope when <code>add()</code> terminates.
In <code>addRef()</code>, <code>b</code> binds to <code>num</code>, so <code>b</code> and <code>num</code> share the same object and the same data.
In <code>addRef()</code>, <code>b</code> is used as an output parameter because the result of the function is returned in one of its parameters.
<strong>You should avoid output parameters.</strong>
This is because when you're looking at the call site of <code>addRef()</code>, there's nothing to tell you that <code>num</code> is mutated,
and you may reasonably expect that <code>num</code> would retain its value.</p>
<p>Does that mean we shouldn't pass by reference? No! Far from it. We can pass by <code>const</code> reference.</p>
<pre><code class="language-c++">int addRef2(const int &amp; a) {
    // a += 4; // error, a cannot be mutated
    return a + 5;
}

int main() {
    auto num = 0;
    num = addRef2(num);
    // num is now 5
    // from just looking at this, it's pretty clear num is changing
}
</code></pre>
<p>In this example, you can look at the call site of <code>addRef2()</code> and pretty clearly see that <code>num</code> is being mutated. </p>
<p>For built-in types, passing by reference is likely tantamount to premature pessimization.
On a 32-bit OS, and address will be 4 bytes, and a 64-bit OS will have 8-byte addresses.
Therefore, there would be less data being copied if we just passed by value since an address is at best the same size as an integer (in almost all implementations, but not necessarily).
However, we will soon see how this is very useful.</p>
<h2 id="function-overloading"><a class="header" href="#function-overloading">Function Overloading</a></h2>
<p>Functions with the same name can be overloaded by having different argument types or different amount of arguments.
The function with arguments more closely matching the parameters passed is the one called.</p>
<pre><code class="language-c++">void func1(int); //version a
void func1(char); //version b
void func1(double); //version c
void func1(char, int); // version d

short ss = 10;
func1(ss); // version a
func1('H'); // version b
func1(0.1f); // c
func1(true); // a
long l = 100;
func1(l); // a
func1(false, 100ll); // d
</code></pre>
<p>If there are multiple equally good matches, the compiler won't guess and will not compile. 
Likewise, if no parameter is implicitly convertible to the type of any overload's arguments, then compilation fails.</p>
<h2 id="other-notes"><a class="header" href="#other-notes">Other Notes</a></h2>
<p>We can also define the return type after we declare the function parameters.
This is known as a trailing return type, and it looks like this:</p>
<pre><code class="language-C++">auto foo(int a, int b) -&gt; int {
    return a - b;
}
</code></pre>
<p>The evaluation order of function arguments is undefined. So given the following:</p>
<pre><code class="language-C++">int i = 0;
auto res = foo(i++, ++i);
</code></pre>
<p>There are two possible execution orders:</p>
<ol>
<li>
<ul>
<li><code>b = ++i = 1</code></li>
<li><code>a = i++ = 1</code></li>
<li><code>res = a - b = 0</code></li>
</ul>
</li>
<li>
<ul>
<li><code>a = i++ = 0</code></li>
<li><code>b = ++i = 2</code></li>
<li><code>res = a - b = -2</code></li>
</ul>
</li>
</ol>
<h2 id="function-design"><a class="header" href="#function-design">Function Design</a></h2>
<blockquote>
<p>The first rule of functions is that they should be small.</p>
<p>The second rule of functions is that <em>they should be smaller than that</em>
<sup class="footnote-reference"><a href="#1">1</a></sup></p>
</blockquote>
<p>Making functions small organizes sections of your code into named units. 
It's easy to know what your code does when it's part of a named function with a narrow scope.
So how small is small? Well most should rarely hit 20 lines. 
A good rule of thumb is 80 characters wide by 20 lines long or smaller. Not only are small functions easier to reason about and debug,
but such functions are readable for most ways in which you might be viewing it. For example, when developing on a PC with
your code fullscreened on a 27&quot; monitor, it's pretty easy to read lines of code over 150 character long. However,
if you want to do a side-by-side diff comparison, work on the codebase from your 15&quot; laptop with,
or have other developers who might use a &quot;busier&quot; IDE layout, those 150 character lines become quite annoying.
Vertical size is less annoying to deal with, but it's still quite nice when you can view an entire function in one glance
without scrolling on various different viewing modes.</p>
<p>Furthermore, functions should <strong>do one thing</strong>. 
How do you know they do one thing? Well you should be able to describe it in about one sentence without using a conjunction like &quot;and.&quot;</p>
<p>Example:</p>
<pre><code class="language-c++">if(person.getAge() &gt;= 18 &amp;&amp; person.getAge() &lt; 25 
    &amp;&amp; person.getHighestEdu() == EducationLevel::Highschool
    &amp;&amp; !person.livingAtHome()) 
{
    // if person attended college after HS
}
</code></pre>
<p>OR</p>
<pre><code class="language-c++">inline auto didAttendCollegeAfterHS(const Person &amp; person) {
    return person.getAge() &gt;= 18 &amp;&amp; person.getAge() &lt; 25 
        &amp;&amp; person.getHighestEdu() == EducationLevel::Highschool
        &amp;&amp; !person.livingAtHome();
}

// ...

if(didAttendCollegeAfterHS(person)) {

}
</code></pre>
<p>Notice how by creating a helper function, we were able to encode the comment in a name. 
Commenting what the code does is unnecessary since the function name says it all. 
If you find yourself commenting what code does, that's a good hint that you might want to make a function. 
We also see how <code>didAttendCollegeAfterHS()</code> does just one thing: it just determines if a person attended college after high school.
We also pass by <code>const</code> reference since the function only uses accessors of <code>Person</code> and doesn't do any mutations.
When passing by reference, the reference should always be <code>const</code> unless you are mutating it.</p>
<p>For another example, we saw in our guessing game how we turned this:</p>
<pre><code class="language-c++">int main() {
    const auto secretNum = getRandNumBetween(min_value, max_value);
    auto guess = 0;
    do {
        std::cout &lt;&lt; &quot;Guess a number between &quot; 
            &lt;&lt; min_value &lt;&lt; &quot; and &quot; &lt;&lt; max_value &lt;&lt; std::endl;
        guess = getUserGuess();

        if (guess &lt; secretNum) {
            std::cout &lt;&lt; &quot;Too low!&quot; &lt;&lt; std::endl;
        } else if (guess &gt; secretNum) {
            std::cout &lt;&lt; &quot;Too high!&quot; &lt;&lt; std::endl; 
        }
    } while (guess != secretNum);
}
</code></pre>
<p>into this</p>
<pre><code class="language-c++">int main() {
    const auto secretNum = getRandNumBetween(min_value, max_value);
    auto guess = 0;
    auto tries = 0;
    do {
        ++tries;
        guess = getUserGuess();
        displayGuessHint(guess, secretNum);
    } while (guess != secretNum);
    displayWin(secretNum, tries);
}
</code></pre>
<p>Once again, we see that the different tasks done during the main loop are easier to read since they essentially have labelled names. 
We could be more pedantic and make the loop its own function as well, but this function is 10 lines long, so I felt that was good enough. 
I like functions to be of a size so that in one &quot;eye-space&quot; I can take in the entire function. So no scrolling, moving my head, etc.</p>
<p>Functions should also not use output parameters, and have a small amount of arguments. 
Generally shoot for no more than 4 arguments. 
Also, if you have parameters of the same type next to each other (and order matters),
you can encode the order in the function name or separate the parameters by some argument of a different type (if there are more arguments).</p>
<p>Ex.</p>
<pre><code class="language-c++">void assertExpEqAct(int expected, int actual);
</code></pre>
<p>vs</p>
<pre><code class="language-c++">void assertEquals(int expected, int actual);
</code></pre>
<p>A user of <code>assertExpEqAct()</code> wouldn't have to look up the order of arguments in the docs since the order is encoded right into the name.</p>
<p>Here's another example:</p>
<pre><code class="language-c++">using it = std::vector&lt;char&gt;::iterator;
void copy(it dstBegin, it dstEnd, it srcBegin, it srcEnd);
</code></pre>
<p>vs</p>
<pre><code class="language-c++">using it = std::vector&lt;char&gt;::iterator;
struct Range {
    it begin, end;
}

void copyDstFromSrc(Range dst, Range src);
</code></pre>
<p>Notice how the first function was <em>missing an abstraction</em> which led to having 4 parameters. 
In the second function, we created a <code>struct</code> to organize the parameters into an <code>abstraction</code>.
In C++20, this can be done with ranges and <code>std::span</code>.</p>
<p>We should also prefer <em>pure functions</em>; a pure function has no side effects, and returns the same output for the same inputs.
It should not mutate variables or have any other effect other than the value it returns.</p>
<h2 id="inline-functions"><a class="header" href="#inline-functions">Inline Functions</a></h2>
<p>Earlier you saw me use the <code>inline</code> keyword. 
This keyword <em>suggests</em> to the compiler that the function can be inlined. 
What is an inlined function? 
Well, we'll cover the details later, but basically every time you call a function the state of the current function must be saved,
you must jump to the new function,
then you must restore the state of the old function and jump back. 
Abstractly, this process can be viewed as having to push an <em>activation record</em> onto the stack and then popping it off. 
An <em>activation record</em> basically contains all the data like arguments being passed,
where the function is called from (so it can jump back), and the state of the callee.
Sounds like a complex task? Well it sort of is. When a function is inlined, the compiler puts the body of the function right at the call site.
So all this jumping and state saving doesn't need to occur. Let's look at another example of factoring out some code into an inline function:</p>
<pre><code class="language-c++">constexpr auto expFac = 0.83;
const auto pts = (person.getAge() * person.getGPA() 
    + expFac * person.getName().size()) * year;
</code></pre>
<p>VS</p>
<pre><code class="language-c++">inline auto getExperience(const Person &amp; person) {
    constexpr auto expFac = 0.83;
    return person.getAge() * person.getGPA() 
    + expFac * person.getName().size();
}

const auto pts = getExperience(person) * year;
</code></pre>
<p>For most compilers, the generated machine instructions will be pretty much the exact same, but the second option gives us greater readability.</p>
<p>A function can only be inlined if it is defined and declared in the same place. 
So an inline function cannot have separate declarations and definitions unless the declaration and definition are in the same file.</p>
<h2 id="constexpr-functions"><a class="header" href="#constexpr-functions">Constexpr Functions</a></h2>
<p>Like <code>constexpr</code> variables have values that are available at compile time, <code>constexpr</code> function have computations that <em>can be</em> available at compile time.
If you pass non-constexpr arguments to a <code>constexpr</code> function, the function will behave normally,
but if you pass literals or <code>constexpr</code> variables to a <code>constexpr</code> function,
the result will be computed at compile time, and the literal value will be inserted in the code.</p>
<p><code>constexpr</code> functions are implicitly inline as well.</p>
<p>Ex.</p>
<pre><code class="language-c++">constexpr int fact(int a) {
    if(a &lt;= 1) return 1;
    else return a * fact(a - 1);
}

constexpr auto my_number = 10;

int num = fact(my_number);
// num = 3628800 will be in the compiled binary

int num2 = fact(4);
// num = 24 will be in the binary

int num3 = fact(nonConstexprFunc());
// will behave like a normal function
</code></pre>
<p>We will explore more about <code>constexpr</code> and other ways of performing compile time calculations later. </p>
<h4 id="further-reading-4"><a class="header" href="#further-reading-4">Further Reading</a></h4>
<p><a href="https://github.com/Kikou1998/textbook/blob/master/A%20Tour%20of%20C%2B%2B%20(2nd%20Edition)%20(C%2B%2B%20In-Depth%20Series).pdf">A Tour of C++</a> 1.3</p>
<p><a href="https://github.com/ontiyonke/book-1/blob/master/%5BPROGRAMMING%5D%5BClean%20Code%20by%20Robert%20C%20Martin%5D.pdf">Clean Code</a> Chapter 3 (I <strong>highly</strong> suggest you read this)</p>
<p><a href="https://github.com/yanshengjia/cpp-playground/blob/master/cpp-primer/resource/C%2B%2B%20Primer%20(5th%20Edition).pdf">C++ Primer</a> Chapter 6</p>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-functions">C++ Core Guidelines</a> Functions</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Clean Code p. 34</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>As we will see later, operators can be overloaded to do arbitrary things. However it is good practice to keep operators' semantic meaning. Operators are really just regular functions with a special way to call them.</p>
<h2 id="basic-binary-operators"><a class="header" href="#basic-binary-operators">Basic Binary Operators</a></h2>
<p>Binary operators operate on two arguments.</p>
<ul>
<li><code>+</code></li>
<li><code>-</code></li>
<li><code>/</code></li>
<li><code>*</code></li>
<li><code>=</code></li>
<li><code>+=</code> - add an amount to a value</li>
<li><code>-=</code></li>
<li><code>/=</code></li>
<li><code>*=</code></li>
<li><code>==</code> - check for equality</li>
<li><code>!=</code> - check for inequality</li>
<li><code>&lt;</code></li>
<li><code>&gt;</code></li>
<li><code>&lt;=</code></li>
<li><code>&gt;=</code></li>
<li><code>&amp;&amp;</code> - logical and</li>
<li><code>||</code> - logical or</li>
</ul>
<p>It's important to note that <code>=</code> operators (<code>=</code>, <code>+=</code>, etc.) all return the new value that was set. For example:</p>
<pre><code class="language-C++">auto x = 10;
auto y = 20;

x = y += 30; 
// sets y to 30 + 20 (50) and returns the new value of y (50)
// this value is then assigned to x

auto test_var = 20;

if (test_var = 30) {
    /*
    * This is a common bug to be on the look out for!
    * Here we assing test_var to 30, then the = operator
    * will return the new value of test_var (which is 30)
    *
    * Then the if statement will check if the result of the 
    * guard `test_var = 30` is true. Since this expression
    * evaluates to `30`, which is not 0, the if statement
    * sees the result of the expression as `true`
    * and enters the if-block
    *
    * To test if test_var equals 30, we want 
    * `test_var == 30`
    *
    * This is yet another reason to prefer `const` variables
    * If `test_var` was declared as `const auto`, then the
    * compiler would have given us an error.
    *
    * Most compilers will give a warning about this, so if
    * you compile with the option to treat warnings as errors
    * (which you should), the compiler will catch this
    * even if `test_var` is not a constant
    */
}
</code></pre>
<p>Here are some other quick examples:</p>
<pre><code class="language-C++">auto x = 5 / 3; 
// x is 1 (division on integers performs integer division)

auto x2 = 5 / 2.0;
// x2 is 2.5

auto b = 5 * 3 + 2;
// b is 17
b += 10;
// b is 27
b \= 2.0;
// b is an integer
// so this will do double arithmetic, then convert it
// to an int by storing it back in b
</code></pre>
<h2 id="basic-unary-operators"><a class="header" href="#basic-unary-operators">Basic Unary Operators</a></h2>
<p>Unary operators operator on one argument</p>
<ul>
<li><code>!</code> - logical negation</li>
<li><code>++</code> - prefix and postfix increment</li>
<li><code>--</code> - prefix and postfix decrement</li>
</ul>
<p>The difference between prefix and postfix increment/decrement is 
that the postfix versions increment the variable and return
the old value.</p>
<pre><code class="language-C++">auto m = 10;
auto n = m++;
// n is 10, m is 11

auto p = ++n;
// p is 11, n is 11
</code></pre>
<h2 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h2>
<ul>
<li><code>|</code> - bitwise or</li>
<li><code>^</code> - xor</li>
<li><code>&lt;&lt;</code> - logical left shift</li>
<li><code>&gt;&gt;</code> - logical right shift</li>
<li><code>~</code> - bit negation (unary)</li>
<li><code>&amp;</code> - bitwise and</li>
<li><code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code></li>
</ul>
<p>The left and right bitshift operators shift the bits to the left and right respectively, shifting in a 0. 
These operators also have the effect of multiplying or dividing by powers of two.</p>
<p>With the exception of bitwise negation, these operators are all binary 
operators.</p>
<p>The right shift and left shift operators do not take into account the two's complement sign of the number. 
In other words, they always shift in 0 bits in the &quot;empty spaces&quot; that they create.</p>
<p>You may notice that we use <code>&lt;&lt;</code> and <code>&gt;&gt;</code> for stream in and stream
out. For example (<code>std::cout &lt;&lt; &quot;Hello world\n&quot;;</code>).
This is an example of operator overloading. In C++, <code>&lt;&lt;</code> and <code>&gt;&gt;</code> 
are commonly used for streams for input (right shift), and output (left shift)</p>
<pre><code class="language-C++">0b111 &lt;&lt; 2;
// 0b11100
// shift 2 bits left
// also multiply by 2^2

0b101 &gt;&gt; 3;
// 0b000
// shift 3 bits right
// also divide by 2^3

~0b101;
//0b010

0b0111 &amp; 1;
// 0b0001

0b101110 ^ 0b010011;
//0b111101

0b1001 | 0b1010;
// 0b1011
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="headers"><a class="header" href="#headers"># Headers</a></h1>
<p>(pun intended)</p>
<p>Header files are a way to separate an interface from an implementation and declarations from definitions. We'll discuss how the compiler works in more detail later. </p>
<p>We have already seen header files with the <code>#include</code> preprocessor directive. The preprocessor is a program that runs before the compiler that handles
directives that begin with <code>#</code>. The preprocessor manipulates the text of the source code directly.</p>
<p>Header files contain the <em>declarations</em> of classes, structs, enums, and functions, and in some cases a few definitions as well.
A declaration basically tells the compiler that some class, struct, etc. exists, but doesn't tell the compiler exactly what that thing is.</p>
<pre><code class="language-C++">struct MyStruct; // declaration of MyStruct

// definition of MyStruct
struct MyStruct {
   int foo(); // declaration of foo
};

int MyStruct::foo() {
    // definition of foo
    return 0;
}
</code></pre>
<p>Remember how the compiler needs to know the definition of a function before it's used, unless it's <em>forward declared</em>?
Well a header file essentially provides the forward declarations for a bunch of functions and objects so that we only need to provide the definitions
in one source file. Header files are a way to put all the declarations in one place and use these declarations in all files that need them.
Files that need the declaration can include them by including the header file.</p>
<p>Every source file, and all header files it includes make up a single translational unit.
Each translational unit is compiled independently.
A single translational unit may only contain one declaration for each function, class, etc.
A single program may only contain one definition for each object.
The purpose of the header is to provide the declarations of objects defined one translational unit to other translational units.</p>
<p>The header/source separation is also a great way to provide separate client and implementor views of a module. 
A client need only look at the declarations and relevant comments in a header file, while an implementor would work with the source code in the source file.</p>
<p>Furthermore, <code>#include</code> directives are a good way to identify the dependencies of a module.</p>
<p>Header files typically end in <code>.h</code> or <code>.hpp</code>.
Some header files in the standard library allow the <code>.h</code> to be omitted when including them as you saw with directives such as <code>#include &lt;iostream&gt;</code>.</p>
<p>Let's take a look at an example. Let's create some basic math functions:</p>
<p>my_math.h</p>
<pre><code class="language-c++">#pragma once
#ifndef MY_MATH_H
#define MY_MATH_H

/**
* @return base^{exp}
*/
int powi(int base, int exp);

/**
* @return base^{exp} % mod
*/
int powMod(int base, int exp, int mod);
#endif
</code></pre>
<p><code>#ifndef</code> is a preprocessor director standing for &quot;if not defined&quot;. 
So if the macro <code>MY_MATH_H</code> is not defined, then we define it and declare <code>powi()</code> and <code>powMod()</code>. This is known as an <em>include guard</em>. 
The reason we need this is to prevent including a header file multiple times. 
For example: perhaps another header <code>your_math.h</code> requires one of these definitions, so it includes <code>my_math.h</code>.
Now a client might make the mistake of including both <code>your_math.h</code> and <code>my_math.h</code> separately.
The client shouldn't have to know that <code>my_math.h</code> is already included in <code>your_math.h</code>, but without include guards they would.
This is because the preprocessor basically replaces include directives with the contents of the file that's being included.
Thus, without include guards, declarations can be repeated in the same file, which will cause a compilation error.
In this example, without include guards <code>powi</code> would be declared once when <code>your_math.h</code> includes <code>my_math.h</code>,
and a second time when the user includes <code>my_math.h</code>.
We cannot have multiple declarations with the same name and parameters in the same file; include guards prevent this.
The first time the preprocessor reads a header, a macro (in this case <code>MY_MATH_H</code>) is defined.
The next time it's read, the <code>#ifndef</code> (if not defined) directive will prevent re-declaring the functions.</p>
<p><code>#pragma once</code> is a non-standard way to do the exact same thing.
All the major compilers (g++, MSVC, clang) support <code>#pragma once</code>, but it's perfectly legal for a compiler not to. 
For portability, use include guards. However <code>#pragma once</code> may be more efficient, and a compiler that doesn't support it won't complain about it; 
for maximal benefit put <code>#pragma once</code> on the first line of a header, and then include guards.
(Now do I use include guards? Hardly; I haven't ran into a compiler where <code>#pragma once</code> wasn't supported)</p>
<p>Now we need to define the functions:</p>
<p>my_math.cpp</p>
<pre><code class="language-c++">#include &lt;my_math.h&gt;

int powi(int base, int exp) {
    // ...
}

int powMod(int base, int exp, int mod) {
    // ...
}
</code></pre>
<p>To use these functions, say in main.cpp we just need to include the header file.</p>
<p>main.cpp</p>
<pre><code class="language-c++">#include &lt;my_math.h&gt;
#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; powMod(10, 13, 99);
}
</code></pre>
<p>There are a few cases where definitions can (and must) be in the header file.
An example would be a function declared <code>inline</code>.
However, normal function definitions <em>must</em> be in a separate file.
This is to prevent duplicate definitions of a function from getting into the binary.
If this happens, the <em>linker</em> will be unable to know which definition to use.
The linker is a program that is executed after the compiler which links object definitions to where they are used.</p>
<p>So how are duplicate definitions introduced?
Well consider two independent files <code>file1.cpp</code> and <code>file2.cpp</code>.
Neither depend on each other and both use <code>powi()</code> so they both need to include <code>my_math.h</code>.
If the definition for <code>powi()</code> was in the header, then we would have just introduced duplicate functions with the same name and parameters
(so they can't be overloads).
This is why definitions are in source files and declarations are in header files.
Both <code>file1.cpp</code> and <code>file2.cpp</code> need forward declarations for <code>powi()</code>.
Instead of having multiple declarations in each source file, we put them in a header file to promote code reuse.</p>
<p>Let's go back to the <code>my_math</code> example.
First the preprocessor runs to put the content of the included header files into <code>main.cpp</code> and <code>my_math.cpp</code>.
It replaces the <code>#include</code> with whatever the included file contains.
Then the compiler compilers <code>my_math</code> and <code>main</code> into object files.
The linker will then link together the definitions in <code>my_math.cpp</code> with the declarations in <code>main.cpp</code>.
Without the declarations, the compiler would fail because it wouldn't know what <code>powi</code> and <code>powMod</code> were; they would be undeclared names.
If we provided the definitions and the declarations in the header file, then the linker would fail because it would find
multiple definitions of the same thing in the program, and not know which one to use.
We could, however, scrap the header file entirely and declare and define <code>powi</code> and <code>powMod</code> in each source file.
In this case, the functions would be compiled completely independently, and the linker would not try to link the definitions
because they were not declared in a header file.
The obvious problem with this idea is that we'll end up duplicating a lot of code.</p>
<p>Avoid cyclic dependencies like the plague.</p>
<h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<pre><code class="language-c++">// single line comment

/*
    Multi line comment
*/
</code></pre>
<p>We'll soon use Doxygen to turn comments into HTML documentation. But for now, I want to point out a few small things.</p>
<ul>
<li>We should avoid duplication in comments. This includes stating the obvious and literally repeating yourself.</li>
<li>Comments should be short and sweet</li>
<li>When you write a comment, think about how you might be able to convey the information in the language itself (for example, a better variable name). If you cannot, then comment.</li>
<li>Use comments to explain a decision, and communicate information to other programmers like exception guarantees, side effects, etc.</li>
</ul>
<p>For writing documentation, you can use Javadocs style</p>
<pre><code class="language-c++">/**
* Desc
* @param
* @return
* @throw
* @author
*
*/
</code></pre>
<p>There's a lot to say about this, but others have already said it better...</p>
<h3 id="further-reading-5"><a class="header" href="#further-reading-5">Further Reading</a></h3>
<p><a href="https://github.com/Kikou1998/textbook/blob/master/A%20Tour%20of%20C%2B%2B%20(2nd%20Edition)%20(C%2B%2B%20In-Depth%20Series).pdf">A Tour of C++</a> 3.2 Separate Compilation</p>
<p><a href="https://github.com/ontiyonke/book-1/blob/master/%5BPROGRAMMING%5D%5BClean%20Code%20by%20Robert%20C%20Martin%5D.pdf">Clean Code</a> Chapter 4 Comments</p>
<p><a href="https://www.cin.ufpe.br/~cavmj/104The%20Pragmatic%20Programmer,%20From%20Journeyman%20To%20Master%20-%20Andrew%20Hunt,%20David%20Thomas%20-%20Addison%20Wesley%20-%201999.pdf">Pragmatic Programmer</a> The Evils of Duplication and It's All Writing </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-organized"><a class="header" href="#getting-organized">Getting Organized</a></h1>
<p>Functions are a great start at organizing code. But let's look at what else C++ has to offer.</p>
<blockquote>
<p>&quot;So if you want to go fast, if you want to get done quickly, if you want your code to be easy to write, make it easy to read.&quot;</p>
<p>- Uncle Bob</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>C++ provides the access modifiers <code>private</code>, <code>public</code>, and <code>protected</code>. 
These modifiers define sections of definitions that belong to that modifier instead of having to specify it for each member. 
Public members are part of the class's public interface and accessible to everyone, <code>private</code> is accessible to itself and friends only and <code>protected</code> is accessible to itself, friends, and subclasses. 
A class's members are <code>private</code> by default.</p>
<p>The class scope begins at the opening <code>{</code> after the class name and extends to the closing one. 
Members declared in this space are part of the class scope, and instances of them are destroyed when their owning instance object is destroyed. 
A special function known as a destructor is called when the owning instance is about to be destroyed, and similarly a constructor is called to create an instance of the class. </p>
<pre><code class="language-C++">class Person {
    const int ssn; //private member
public:
    // public members
    std::string name;
    int age;
protected:
    std::string homeAddress;

public:
    Person(const std::string &amp; name) {
        // constructor
        ssn = 0;
        this-&gt;name = name;
        age = 0;

    }
    ~Person() = default;
    // destructor, we don't need anything special for this class
    // so we set it equal to default to use the default implementation
    // we didn't even have to declare the destructor in this case,
    // the compiler would generate one with the behavior we need

    Person(const std::string &amp; name, int age, const std::string &amp; addr) :
        ssn(0), name(name), age(age), homeAddress(addr) {}
    // This is a constructor initialization list
    // its more efficient then setting the values in the actual
    // constructor
};


Person p1(&quot;Harry&quot;);
Person p2{&quot;Harry&quot;};

const auto p3 = Person(&quot;Joe&quot;, 20, &quot;500 Research Drive&quot;);
const auto name3 = p3.name;
const auto p4 = Person{&quot;Jimmy&quot;};

Person p5 = &quot;Kyle&quot;;

</code></pre>
<p>Like any other function, we can provide overloads for constructors so that we can construct the object with different amounts/types of parameters. 
A constructor can have a constructor <em>initialization list</em>. This is done by specifying the initial values of member variables following a colon using function syntax. 
The advantage of this is that you only set the variable once. Otherwise, the members are initialized, then the constructor is called which may assign them to a different value.</p>
<p>Members values are initialized top-to-bottom, left-to-right, and the order of initialization in the initialization list must match. 
Therefore, in this example I could not set the value of <code>ssn</code> after I set the value of <code>name</code> in the initializer list because <code>ssn</code> is above <code>name</code> and therefore is initialized first. 
The reason C++ handles initialization this way is so that if construction of an object fails and only some members were initialized, we can safely destroy the members that we did get a 
chance to initialize and ignore the ones that we didn't. 
The destruction occurs in reverse order of initialization.</p>
<p>Notice that <code>ssn</code> is a <code>const</code> member, yet I'm still able to &quot;change&quot; its value in the constructor. 
<code>const</code> members may be set once and only once, and that can occur only in the constructor initialization list or where they are declared if they are <code>inline</code> members (more on this later).</p>
<p>Finally, I'd also like to point out the constructors that takes one argument allow implicit conversion from the type of that argument to the class. 
This is demonstrated by the line <code>Person p5 = &quot;Kyle&quot;;</code>. If this is not the semantics you intend, you should declare the constructor <code>explicit</code> like so:</p>
<pre><code class="language-C++">    explicit Person(std::string &amp; name) //..
</code></pre>
<p>Another example: (not complete)</p>
<pre><code class="language-C++">class Socket {
    unsigned sock;
public:
    Socket() : sock(socket(AF_INET, SOCK_STREAM, 0)) {
        std::cout &lt;&lt; &quot;Socket initialized!\n&quot;;
    }

    ~Socket() {
        closesocket(sock);
        std::cout &lt;&lt; &quot;Socket destroyed\n&quot;;
    }

    bool writeAll(const std::string &amp; msg) const {
        unsigned written = 0;
        do {
            auto sent = send(sock, &amp;msg[written], msg.size() - written);
            if (sent &lt; 0) break;
            written += sent;
        } while (written &lt; msg.size());
    }
};

{
    const Socket sock; // Socket initialized
    sock.writeAll(&quot;Hello world&quot;);
} // Socket destroyed
</code></pre>
<p>Since <code>writeAll</code> does not modify any state of the instance, we can declare it <code>const</code>. 
Methods that are declared <code>const</code> can be used by instances declared <code>const</code>, however non-const methods cannot be used since they are allowed to modify state which would break the constness of the instance. 
The socket API is written in C, so technically <code>sock</code> is a handle which refers to a buffer in the OS that <em>is</em> mutating. 
But from our perspective we can say that <code>writeAll</code> is <code>const</code> since it doesn't change the values of members of an instance of <code>Socket</code>.</p>
<p>Also notice how the destructor is called when the object goes out of scope. This allows us to ensure our resources are freed when we're done using them. 
In this case the destructor cleans up our resources by closing the socket that was created by the constructor. Failing to do this would result in a <em>resource leak</em>.</p>
<p>As you see, we can use the dot operator (<code>.</code>) to access public members of an object with an automatic lifetime. </p>
<p>I'll dedicate an entire chapter to this topic, so we'll hit this again later.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Structs are actually the same thing as a class except that their members are public by default. 
However, structs convey the idea of a <em>data structure</em> <sup class="footnote-reference"><a href="#1">1</a></sup>, or a type with its internals known. 
Generally speaking, when you want to organize pieces of information together, but not necessarily provide an abstraction or any encapsulation, a struct is probably the best tool in the toolbox. </p>
<p>A lot of times structs will be PODs (plain old data) which means their members are laid out contiguously in memory as they are written. 
PODs are composed of primitive types, enumerations, and classes or structs with a trivial default constructor and trivial copy constructors (pretty much the compiler-generated ones). 
This makes it possible to read and write an entire struct as binary to a stream such as a socket or file provided you take things such as padding and endianness into account. 
This might not have made much sense, but don't worry about it right now.</p>
<p>If no constructor is user-defined, you can use braces to initialize the struct passing in values for each member, in the order that they are declared.</p>
<pre><code class="language-C++">struct Address {
    int zipCode, streetNumber;
    std::string city, state, country, street;
};

Address addr {
    1000, 21,
    &quot;Ithaca&quot;, &quot;NY&quot;, &quot;USA&quot;, &quot;Buffalo Rd&quot;
};

addr.zipCode = 2000;
// public members by default
</code></pre>
<p>Rules of thumb for choosing a class vs struct:</p>
<ul>
<li>If there is any encapsulation, use a <code>class</code></li>
<li>Use <code>class</code> if there are invariants that must be enforced. Use <code>struct</code> if members can vary independently.</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Using this term as Uncle Bob uses it. His idea is that a data structure has its internals public while an object doesn't. Operations on an object tell it to do something, and ones on data structures are told to get something.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h1>
<p>Suppose you have a class representing vehicles, and wanted a way to store whether the vehicle was electric, gas, or a hybrid. 
You might consider using a <code>char</code> and creating constants <code>gas = 'g', electric = 'e', hybrid = 'h'</code>. 
This isn't too bad of a system, but operations on this information would be operations on <code>char</code>s, so what's stopping a user from accidentally using <code>'f'</code>? 
As far as the compiler is concerned, nothing.</p>
<p>This is the motivation for enums, a type to represent enumerations of possible values. Here's how our original problem might look:</p>
<pre><code class="language-C++">enum class VehicleType {
    gas, electric, hybrid
};

double getBaseRefuelingCost(VehicleType typ) {
    switch (typ) {
        case VehicleType::gas:
            return 2.49;
        case VehicleType::hybrid:
            return 1.00;
        case VehicleType::electric:
            return 0.50;
    }
}

getBaseRefuelingCost(VehicleType::gas);
getBaseRefuelingCost(0); //error
</code></pre>
<p>Internally, an enum is represented as some integral type (<code>int</code> by default). 
However, as you can see the conversion is not implicit. This provides type checking to ensure that you can only use valid values of the enumeration.</p>
<p>Still, you can explicitly initialize an enum with an integer using similar syntax as initializing a <code>struct</code>.</p>
<p><code>getBaseRefuelingCost(VehicleType {0}) // be default, 0 is the value of the first enumeration value defined (so gas)</code></p>
<p>If you need to, you can actually specify the underlying integral type of the enumeration and can also specify the underlying value of the enumerated values as well. 
Each enumeration will have an underlying value of 1 more than the previous one, and by default the first underlying value is 0</p>
<pre><code class="language-C++">enum class Colors : char { //underlying type is char
    black, //0
    red = 10, 
    green, //11
    blue, //12
    orange = 20,
    yellow // 21
}
</code></pre>
<p>The above is known as a <em>scoped enum</em>. 
If you remove the <code>class</code> keyword after <code>enum</code>, you can create a &quot;regular&quot; <code>enum</code> which has implicit conversion to int and does not require qualifying the enum name.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p>Namespaces are a way to organize related pieces of code and insulate their names from 3rd parties and outside code. 
You can think of them as analogous to the zip code in a mailing address. There are multiple 330 Pine Tree Roads but there is only one 330 Pine Tree Road 14850. 
The same idea goes for namespaces.</p>
<pre><code class="language-C++">namespace a {
    int add(int a, int b);
}

namespace b {
    int add(int a, int b);
}

// Both adds are in separate namespaces so this is ok

a::add(5, 4);
b::add(7, 3);

</code></pre>
<p>The <code>::</code> operator is used to resolve names in namespaces the same way the <code>.</code> operator resolves names in class scopes.</p>
<p>Sometimes it can get annoying to constantly use <code>x::</code> where <code>x</code> is a namespace name. 
Therefore, we can use a <code>using</code> declaration to bring the names of a namespace into the current scope and allow them to be used without qualifying them with their namespace name. 
This however opens up the door to name collisions once again. An alternative is to use the <code>using</code> declaration to bring into scope only certain names instead of everything in the entire namespace.</p>
<pre><code class="language-C++">using namespace a; //bring everything from namespace a into scope
using std::cout; // bring cout into scope

cout &lt;&lt; add(5, 4) &lt;&lt; &quot;\n&quot;;
// calls a::add
// no need to qualify cout with std::

{
    using b::add;
    // brings b::add into this smaller scope, shadowing a::add
    cout &lt;&lt; add(9, 9) &lt;&lt; &quot;\n&quot;;
    // calls b::add
}

cout &lt;&lt; add(5, 5) &lt;&lt; &quot;\n&quot;;
// we left the scope b::add we used in
// so this calls a::add

</code></pre>
<p><code>std</code> is especially quite a big namespace and doing a <code>using namespace std</code> tends to bring in all sorts of issues. For example, <code>std::bind</code> will collide with the C function <code>bind</code>. 
You can specify that a name is part of the global scope by prepending <code>::</code> but it's generally best to avoid using an entire namespace that's as big as <code>std</code> and instead fully qualify names or bring in parts of it.</p>
<p>Now what to put in a namespace? Well, at the very least, if we have a class <code>X</code> in namespace <code>Y</code>, we should ensure that the entire interface of <code>X</code> is also in that namespace. 
What constitutes part of a class's interface? Well Herb Sutter's <em>Interface Principle</em> says that anything that mentions <code>X</code>, or is supplied with an <code>X</code>, is logically part of the interface of <code>X</code>. 
Thus, these things should be in the same namespace as <code>X</code>. 
This plays nicely with a C++ mechanic known as <em>ADL</em> (Argument Dependent Lookup) aka Koenig Lookup: during name resolution, if a function <code>f</code> is supplied with a type <code>Y::X</code>, 
then it can resolve the name <code>f</code> by searching in namespace <code>Y</code> and looking for <code>Y::f</code>. Therefore, any related function of a class should be in the same namespace of that class.</p>
<pre><code class="language-C++">namespace mail {
    struct MailingAddress {
        using std::string;

        string state, street, city;
        int streetNumber;
    }

    void sendMessage(const &amp; MailingAddress dst, const &amp; std::string message);
    // the using declaration for std::string is not in scope here so std::string must
    // be fully qualified
}

const auto addr = mail::MailingAddress { /* ... */};
sendMessage(addr, &quot;Hello There&quot;);
// same as 
mail::sendMessage(addr, &quot;Hello There&quot;);
// By rules of ADL lookup, the function sendMessage does not have to be fully qualified
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="recap-of-oop-language"><a class="header" href="#recap-of-oop-language">Recap of OOP Language</a></h2>
<p>As this book is mostly focused on learning C++, I will not delve into the details, designs, and principles of any programming paradigm. However, to make sure we're all on the same page, here's a quick recap of some terms I throw around quite often without definition.</p>
<ul>
<li><strong>abstract class</strong> - a class which does not contains its entire implementation.</li>
<li><strong>abstract data type</strong> - a module which defines a type</li>
<li><strong>client</strong> - a user of a type. Basically not the implementor.</li>
<li><strong>concrete class</strong> - a class that contains its implementation.</li>
<li><strong>dynamic dispatch</strong> - invoking a method based on the dynamic type of the method's owning object instance.</li>
<li><strong>dynamic/actual/runtime type</strong> - the type of the object at runtime.</li>
<li><strong>encapsulation</strong> - the principle of hiding data members or implementation details from clients that they don't need to know about.</li>
<li><strong>inheritance</strong> - language feature which enables a class to inherit the members of another. There is a technical different between this and subtyping which we'll discuss later, although sometimes I use them a bit interchangeably. </li>
<li><strong>interface</strong> - the methods and members that a client can use to perform operations on a type.</li>
<li><strong>mixin</strong> - a class which subtypes a set of narrow interfaces which define properties of a type rather than a type itself.</li>
<li><strong>module</strong> - a discrete and independent unit of a program.</li>
<li><strong>object composition</strong> - composing an object of other subobjects. Essentially a class that has a member which is another class.</li>
<li><strong>overload</strong> - a function that differes from another in the type or number of parameters to provide different ways to invoke an operation.</li>
<li><strong>override</strong> - a method that (re)defines the implementation of a base class method.</li>
<li><strong>polymorphism</strong> - the principle of using any implementation of an interface where the interface is expected.</li>
<li><strong>static/declared type</strong> - the type that is known at compile time. You can think of this as the actual type name you write in your code.</li>
<li><strong>subtype</strong> - a type that implements the same interface as another.</li>
</ul>
<h3 id="the-term-object"><a class="header" href="#the-term-object">The term 'object'</a></h3>
<p>In some languages the term 'object' refers to an instance of a class. 
But in C++, the standard defines an 'object' as a &quot;region of storage&quot;. 
Objects can consist of sub-objects, and every variable is an object. Objects take up one or more memory locations, except bit fields which are separate objects but share a memory location.</p>
<p>What is a bit field? Well, it's a member variable designated to take up a different amount of bits than the amount of bits typically used by an object of its type.</p>
<pre><code class="language-C++">struct Child {
    unsigned age : 4; //0 to 16, unsigned on its own means unsigned int
    unsigned avgGrade : 7; // 0 to 128 (maybe grade only goes to 100)
    bool sex : 1;
}
// without padding, this struct takes up 2 bytes (12 bits, but we can't have 1.5 bytes)

// age, avgGrade, and sex are 3 object taking 1 memory location
// they are also subobjects of an instance of Child, which is itself an Object

Child c;
// c is an object
</code></pre>
<p>This information won't become important until later (concurrency), but I thought I'd mention it now to avoid confusion.</p>
<blockquote>
<p>&quot;Any problem in computer science can be solved with another level of indirection&quot;</p>
<p>- David Wheeler</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h1>
<p>Let's first create a class <code>Rational</code> to see an example of overloading:</p>
<pre><code class="language-C++">class Rational {
    int num, den;
public:
    Rational(int numerator, int denominator) : num(numerator), den(denominator) {}

    Rational(int numerator) : Rational(numerator, 1) {}
    // forward call to a different constructor

    Rational(const Rational &amp; other) : num(other.num), den(other.den) {}
    // copy constructor
};

</code></pre>
<p>This class has two private integers and 3 constructors. 
The first is a constructor that passes in the values for <code>num</code> and <code>den</code>. 
The second is a conversion constructor from <code>int</code>. 
You could also have given <code>denominator</code> a default argument like so: <code>Rational(int numerator, int denominator = 1)</code>. 
Both cases allow for implicit conversion to <code>Rational</code> from <code>int</code> (and types that implicitly convert to <code>int</code>) since we don't use the <code>explicit</code> keyword. 
The third is a special kind of constructor known as a <code>copy</code> constructor. We'll talk more about this later, but basically it allows us to create a new <code>Rational</code> by copying (and not modifying) an existing one.</p>
<pre><code class="language-C++">Rational r = 5; // invoke constructor 2
auto r2 = r; // copy constructor
Rational r3(10); // ctor 2
Rational r4{20}; // ctor 2
Rational r5(10, 2); // ctor 1
Rational r6{20, 10}; //ctor 1
</code></pre>
<p>Constructors can use <code>()</code> or <code>{}</code>. This is to avoid <em>the most vexing parse</em>. Consider the following ambiguous line:</p>
<pre><code class="language-C++">Bar bar(FooBar());
</code></pre>
<p>This can be interpreted two ways: as a variable definition for <code>bar</code> which is passed a new instance of <code>FooBar</code> in its constructor,
or a function declaration for <code>bar</code> which returns an object of type <code>Bar</code> and accepts a pointer to a function that takes no input and
returns a <code>FooBar</code> object. The standard dictates that the latter interpretation must be chosen. Braces allow us to avoid
this issue: <code>Bar bar(FoorBar{})</code> or <code>Bar bar{FooBar()}</code>.</p>
<p>Back to overloading: we have already seen how to overload functions, but we can also overload operators as well.</p>
<p>Binary operator overloads take two arguments (the left and right operand), and unary operators take one. 
If the two arguments are different types, then you'd have to define two overloads in order for the operator to be commutative. 
One overload has type <code>x</code> as the left operand (first arguments) and type <code>y</code> as the right (second arguments),
and the other is the opposite with <code>y</code> for the left operand (first arg) and <code>x</code> as the right.</p>
<p>But first, it's important to realize that methods (member functions) of a class have an implicit first argument that is the context object for that function. 
So if you define a binary operator overload as a member function, the left argument will be an instance of the class.</p>
<p>Let's define the assignment operator to allow updating our object.</p>
<pre><code class="language-C++">
    //...

    Rational&amp; operator=(int num) {
        this-&gt;num = num;
        den = 1;
        return *this;
    }

    Rational&amp; operator=(const Rational &amp; num) {
        this-&gt;num = num.num;
        den = num.den;
        return *this;
    }
};
</code></pre>
<pre><code class="language-C++">Rational r = 10;
r = 20; // assignment op 1
const Rational r2(5, 2);
r = r2; //assign 2
</code></pre>
<p>All methods of a class have a <code>this</code> pointer, which refers to the calling context of the method. 
This calling context is the implicit first argument of member methods. Therefore, <code>operator=</code> is a binary operator despite its overload appearing to only have one argument. 
Moreover, <code>operator=</code> typically returns a reference to the updated object; so we return <code>*this</code>, which dereferences the <code>this</code> pointer. 
Once again notice how <code>num</code> in the second overload is <code>const &amp;</code>. It is <code>const</code> since there is no need to mutate it, and we pass by reference to avoid extra copying (plus this is the idiomatic way of defining <code>operator=</code>). 
You may also notice the strange <code>-&gt;</code> operator. This is the pointer scope resolution operator, basically the dot operator for pointers. </p>
<p>Let's define basic arithmetic operations. 
I typically like to define arithmetic operators as free functions because it's slightly more clear what the type of the left operand is (otherwise, the left operand is the implicit first argument <code>this</code>). 
Let's look at both ways:</p>
<pre><code class="language-C++">    // ...
    // member method
    Rational operator+(const Rational &amp; other) const {
        return {num * other.den + other.num * den, den * other.den};
        // No need to specify &quot;Rational {...}&quot; because the compiler can see
        // that this function returns a Rational
    }

};

//free function
Rational operator*(const Rational &amp; a, const Rational &amp; b) {
    return { a.num * b.num, a.den * b.den };
}

</code></pre>
<p>Since we are creating a new <code>Rational</code> we declare the member function to be <code>const</code>, this way it takes <code>const this</code> as its implicit first argument.</p>
<p>Now you might be curious: &quot;Aren't <code>num</code> and <code>den</code> private members? How can we access them outside the class <code>Rational</code>?&quot; 
The answer is we can't. Well, not without declaring the function a <code>friend</code>. 
<code>friend</code> classes and functions are classes and functions do not have to be defined in the class scope, but are essentially part of the class they are friends with. 
They have access to all private, protected, and public members. 
They should be used sparingly, as it is the strongest coupling relation available. In this case, it's a good choice since we want <code>operator*</code> to behave like a member of the class itself.</p>
<p>Now as currently written, you would expect addition to be commutative, however:</p>
<pre><code class="language-C++">Rational r(5, 3);

auto r2 = r + 10; // good
r2 = 10 + r; // error
</code></pre>
<p>It's not! That's because, as defined, <code>operator+</code> expects its first argument to be a Rational object and member functions will not do implicit conversions on the implicit first argument. 
However, in the third line we pass an integer. Therefore, we'll need to define a free function which has <code>int</code> as the left-hand argument.</p>
<pre><code class="language-C++">Rational operator+(int a, const Rational &amp; b) {/*...*/}


Rational operator+(const Rational &amp; a, int b) {/*...*/} 
// equivalent to the operator+ we just defined as a member
</code></pre>
<p>Or, we can just define one free function which takes <code>Rational</code> since <code>int</code> can be implicitly converted to <code>Rational</code>.</p>
<p>Let's also make <code>Rational</code> able to be printed to <code>cout</code>. For that we can overload <code>operator&lt;&lt;</code>, which takes a reference to an <code>std::ostream</code>, a super type of the class that <code>std::cout</code> is an instance of.</p>
<pre><code class="language-C++">std::ostream&amp; operator&lt;&lt;(std::ostream &amp; stream, const Rational &amp; r) {
    stream &lt;&lt; r.num &lt;&lt; &quot;/&quot; r.den;
    return stream;
}
</code></pre>
<p>Two final overloads I want to give special attention to are the increment/decrement operators. 
Both of these have a postfix and prefix version which do different things. 
The prefix version directly increments the object while the postfix version makes a copy, increments the object, and returns the copy made. 
Therefore, unless you need the old value, it's good practice to use the prefix increment/decrement by default. 
Furthermore, to make compiler optimizations easier, it's smart to implement the postfix operators in terms of their prefix counterparts (it's good code reuse as well).</p>
<pre><code class="language-C++">    //...
    Rational&amp; operator++() {
        num += den;
        return *this;
    }

    //postfix increment
    Rational operator++(int) {
        const auto cpy = *this;
        ++(*this);
        return cpy;
    }
};
</code></pre>
<p>Here's a completed Rational class:</p>
<pre><code class="language-C++">#include &lt;numeric&gt;
#include &lt;ostream&gt;

class Rational {
    // Invariant: num and den are in simplest form
    int num, den;
    friend Rational operator+(const Rational&amp;, const Rational&amp;);
    friend Rational operator*(const Rational&amp;, const Rational&amp;);
    friend Rational operator/(const Rational&amp;, const Rational&amp;);
    friend Rational operator-(const Rational&amp;, const Rational&amp;);
    friend bool operator==(const Rational&amp;, const Rational&amp;);
    friend bool operator&lt;=(const Rational&amp;, const Rational&amp;);
    friend bool operator&gt;=(const Rational&amp;, const Rational&amp;);
    friend bool operator&lt;(const Rational&amp;, const Rational&amp;);
    friend bool operator&gt;(const Rational&amp;, const Rational&amp;);
    friend bool operator!=(const Rational&amp;, const Rational&amp;);
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Rational&amp;);
public:
    Rational(int numerator, int denominator) : num(numerator / std::gcd(numerator, denominator)),
        den(denominator / std::gcd(numerator, denominator)) {}

    Rational(int numerator) : Rational(numerator, 1) {}
    // forward call to a different constructor

    Rational(const Rational&amp; other) : num(other.num), den(other.den) {}
    // copy constructor

    Rational&amp; operator=(int num) {
        this-&gt;num = num;
        den = 1;
        return *this;
    }

    Rational&amp; operator=(const Rational&amp; num) {
        this-&gt;num = num.num;
        den = num.den;
        return *this;
    }

    Rational&amp; operator++() {
        num += den;
        return *this;
    }

    //postfix increment
    Rational operator++(int) {
        const auto cpy = *this;
        ++(*this);
        return cpy;
    }

    Rational&amp; operator--() {
        num -= den;
        return *this;
    }

    //postfix decrement
    Rational operator--(int) {
        const auto cpy = *this;
        --(*this);
        return cpy;
    }

    


};

Rational operator+(const Rational&amp; a, const Rational&amp; b) {
    return { a.num * b.den + b.num * a.den, a.den * b.den };
}

Rational operator-(const Rational&amp; a, const Rational&amp; b) {
    return { a.num * b.den - b.num * a.den, a.den * b.den };
}

Rational operator/(const Rational&amp; a, const Rational&amp; b) {
    return a * Rational { b.den, b.num };

}

Rational operator*(const Rational&amp; a, const Rational&amp; b) {
    return { a.num * b.num, a.den * b.den };
}

bool operator==(const Rational&amp; a, const Rational&amp; b) {
    return a.num == b.num &amp;&amp; a.den == b.den;
}

bool operator!=(const Rational&amp; a, const Rational&amp; b) {
    return !(a == b);
}

bool operator&lt;=(const Rational&amp; a, const Rational&amp; b) {
    return a &lt; b || a == b;
}

bool operator&gt;=(const Rational&amp; a, const Rational&amp; b) {
    return a &gt; b || a == b;
}

bool operator&lt;(const Rational&amp; a, const Rational&amp; b) {
    return a.den &gt; b.den || (a.den == b.den &amp;&amp; a.num &lt; b.num);
}

bool operator&gt;(const Rational&amp; a, const Rational&amp; b) {
    return !(a &lt; b) &amp;&amp; a != b;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Rational&amp; r)
{
    stream &lt;&lt; r.num &lt;&lt; &quot;/&quot; &lt;&lt; r.den;
    return stream;
}
</code></pre>
<p>In C++20, we can let the compiler generate all those comparison functions for us by just defining a single function: <code>operator&lt;=&gt;</code>.</p>
<hr />
<h3 id="possible-exercises"><a class="header" href="#possible-exercises">Possible Exercises</a></h3>
<ol>
<li>Create a Vec3d class (or whatever you'd like to call it) which stores 3 doubles and represents a 3D vector in the Cartesian plane. It should support the following operations:
<ul>
<li><code>operator+</code> and <code>operator-</code> (for vectors and scalars)</li>
<li><code>operator*</code> and <code>operator/</code> for scalars</li>
<li><code>operator*</code> for vectors which will be the dot product</li>
<li><code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code></li>
<li><code>operator+=</code>, <code>operator-=</code> for vectors and scalars</li>
<li><code>operator[]</code> where index 0 gets the <code>x</code> value, index 1 <code>y</code>, and 2 <code>z</code>.
<ul>
<li>Out of bounds is undefined behavior, and you can do (or not do) whatever you see fit</li>
</ul>
</li>
<li>Its data may or may not be encapsulated</li>
<li>Separate the interface and implementation into a header and code file
<ul>
<li>Can you do this without any include directives in the header file?</li>
</ul>
</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<p>What we saw last chapter was a <em>concrete</em> class. Concrete types have their representation part of their definition. 
Unlike concrete types, abstract types cannot be instantiated, but instead provide an interface for other concrete classes to implement. </p>
<p>An interface is the contract between clients (users of the interface), and implementors. A client doesn't know or 
care how an interface is implemented. The client just assumes that the implementation does what the interface says it does.
An analogy for an interface might be a menu. A menu gives you a general gist of the dishes available and lists the costs and 
maybe some key ingredients. But each chef is free to make the dish however they want. If the head chef calls in sick,
someone else might be able to take over. Multiple people might work on different parts of the dish and things like 
spice combinations, oven temperatures, how long the pan is preheated, and the ordering of some steps might differ. 
All of these details are abstracted from the client, which allows the implementors (the kitchen in this analogy)
to be free to change things up.</p>
<p>Abstract types must be used via pointers or references, while concrete types can be used directly. Concrete types can be placed on the stack, and be members of other classes much more simply than abstract types.</p>
<p>A function that you want a derived class to be able to override must be declared <code>virtual</code>. 
The reason is that the presence of a <code>virtual</code> function requires something known as a virtual table or vtable. This is an area in memory that each instance has access to that allows the 
compiler to perform dynamic dispatch by looking up the specific function to call at runtime. More accurately, each instance has a pointer to its respective virtual table. 
Since C++ is &quot;pay for what you use&quot;, this vtable isn't created unless a class declares a function <code>virtual</code> which enables dynamic dispatch for that function and allows subclasses to override it.</p>
<p>An abstract type contains at least one <em>pure virtual</em> functions, which is a function that subclasses <strong>must</strong> override because the superclass does not implement it. </p>
<pre><code class="language-C++">class Person {
public:
    virtual std::string speak() const = 0; // pure virtual function

    virtual int walk() { return 10; }
    // overrideable with default implementation
};

class Child : public Person { // child implements Person
public:
    std::string speak() const override {
        return &quot;Hiya&quot;;
    }
};

Child c;
c.speak(); //Hiya
c.walk(); // 10
Person p; //error
</code></pre>
<p>When overriding a function, it's good practice to explicitly denote it as such with <code>override</code>. 
This prevents you from accidentally creating a new function and <em>shadowing</em> the super class's functions. 
Since you cannot overload superclass functions, creating a function with the same name as a superclass's function in a subclass shadows that function and prevents it from being called.</p>
<pre><code class="language-C++">class Machine {
public:
    long serialNumber() { /* ... */ }
};

class Computer : public Machine {
public:
    long serialNumber(long default) { /* ... */ }
};

Computer pc;
pc.serialNumber(10); // good
pc.serialNumber(); // error, superclass method shadowed
</code></pre>
<p>Inheritance enables us to use polymorphism and let subclasses behave like their superclasses. 
A user would not need to care about the concrete class or its implementation, they can just use the interface defined in the supertype without regard to the specific implementation. 
However, in order to fully support this, we need to ensure that the destructor is virtual. 
Otherwise, there will be no dynamic dispatch on the destructor which will cause undefined behavior if we destroy a subclass through a reference or pointer to the superclass. 
Another alternative is to make the base class destructor protected and non-virtual. This will prevent deletion of a derived type through a pointer or reference to the base class.</p>
<p>Constructors on the other hand, cannot be virtual. This is because construction requires complete type information; the static type is the type being constructed. 
Furthermore, the class doesn't exist as an object at runtime yet, so you can't call a virtual method on it.</p>
<p>As an addendum, you should not call virtual functions in constructors or destructors. 
This is because the actual type of the object changes during these two operations, and the actual type is always the type being created/destroyed. 
During construction of a derived class, we first start by constructing the base class and running the base class constructor. 
In this constructor, the actual type of the object is the base class type and not yet the derived class type. 
Then we build off the base and construct the derived class by calling the derived class constructor. 
During this second constructor call, the actual type changes to be that of the derived type. 
For destruction, the process is similar but in reverse, destroying the derived object before destroying the base.
Therefore, if you call a virtual function in the base class constructor, it will dispatch to the implementation in the base class and not the derived class. This is because, when the base class constructor is being run, the dynamic type is still the base type.
So calling virtual functions in constructors/destructors is technically safe so long as the virtual function is not pure virtual and you don't expect it to dispatch to a derived type, but it's not a good idea.</p>
<pre><code class="language-C++">class Vehicle {
protected:
    std::string name;
public:
    Vehicle(const std::string &amp; name) : name(name) {}

    virtual ~Vehicle() = default;
    // need a virtual destructor, but don't need any custom behavior
    // so mark it = default

    std::string description() { return name; }

    virtual void move() = 0;
};

class Car : public Vehicle {
private:
    int horsePower;
public:
    Car(int hp) : Vehicle(&quot;Car&quot;) {
        // cannot set variables in initializer list
        // when using a delegating constructor
        horsePower = hp;
    }

    Car(const std::string &amp; name, int hp) : Vehicle(name) {
        horsePower = hp;
    }

    void move() override {
        // name is protected so it can be accessed
        std::cout &lt;&lt; name &lt;&lt; &quot; went &quot; 
            &lt;&lt; horsePower / 10 /* some calculation, idk */ 
            &lt;&lt; &quot; mph&quot;;
    }

    void honk() {/* ... */}
};


auto moveIt(Vehicle &amp; vehicle) {
    vehicle.move();
    return vehicle.description();
}

Car c(700);

moveIt(c);

</code></pre>
<p><code>Vehicle</code> has a constructor, but it is an abstract type so it still can't be constructed directly. 
Instead, subclass constructors must delegate one of the superclass constructors like shown. 
When delegating a call from one constructor to another, we cannot use the initializer list to instantiate extra variables.</p>
<p>Also, notice how <code>moveIt</code> takes a <code>Vehicle</code> by reference. 
This is paramount to avoid <em>object slicing</em>. In memory, a concrete derived class is formed by taking its state and tacking it on to the data of the superclass. </p>
<div class="table-wrapper"><table><thead><tr><th>&amp;Car</th></tr></thead><tbody>
<tr><td>Vehicle Data</td></tr>
<tr><td><code>std::string name</code></td></tr>
<tr><td>Car Data</td></tr>
<tr><td><code>int horsePower</code></td></tr>
</tbody></table>
</div>
<p>Passing the derived class by value as a superclass instance will only copy the data that the subclass shares with the superclass. If the derived class adds additional data members, then these data members won't be copied because the compiler thinks its just dealing with an instance of the superclass. Hence the name object slicing, because the data specific to the subclass is sliced off. Another piece of information which is sliced off the the virtual table pointer of the base class. Consider the following:</p>
<pre><code class="language-C++">class Base {
public:
	virtual ~Base() = default;

	virtual void speak() {
		printf(&quot;Hello\n&quot;);
	}
};

class Derived : public Base {
public:
	void speak() override {
		printf(&quot;Derived\n&quot;);
	}
};

void slice(Base b) {
	b.speak();
}

Derived d;
slice(d);
</code></pre>
<p>What we'll end up with is <code>Hello</code> being printed to the console. When we copy an object like this, behind the scenes the compiler invokes the copy constructor, which is not virtual. Moreover, copies don't copy the virtual table pointer. Why? Well, suppose that it did. Then invoking virtual methods like <code>speak()</code> would dispatch to the derived type. But the derived type implementation might use data members that are not shared between the base and derived class. Since we already discussed that these members could not be copied over, then such a function invocation would give us undefined behavior by accessing invalid memory.
Therefore, object slicing prevents dynamic dispatch from operating as expected. </p>
<p>In the <code>Vehicle</code> example, if <code>Vehicle</code> was passed by value, the compiler would complain since that would require it to construct a new instance of <code>Vehicle</code>, and <code>Vehicle</code> is abstract and cannot be constructed.</p>
<p>Now even with references we can run into a bit of a conundrum:</p>
<pre><code class="language-C++">Car c1(300), c2(&quot;car 2&quot;, 500);
Vehicle&amp; v = c1; //reference v being bound to c1, good
v = c2; //operator=, uh oh
v.move(); // ?
</code></pre>
<p>As we saw in the last chapter, <code>operator=</code> is not normally virtual. We can make it virtual and overload it ourselves, but by default it's not. 
Therefore, the above example causes object slicing as well! This is because <code>operator=</code> gets called on the static (declared) type which is <code>Vehicle</code> and not the dynamic (actual) type which is <code>Car</code>. 
So here, <code>operator=</code> will copy only the members it knows about (the ones that are part of the static type) and leave the rest unchanged. So the output of <code>v.move()</code> is &quot;car 2 went 30 mph&quot;. And since <code>v</code> is basically an alias for <code>c1</code>, that's the same output for <code>c1.move()</code>. So we see here that we &quot;half-copied&quot; <code>c2</code> to <code>c1</code>!</p>
<h2 id="covariance-and-contravariance"><a class="header" href="#covariance-and-contravariance">Covariance and Contravariance</a></h2>
<p>Suppose we had a function <code>clone</code> in our previous hierarchy. In the interface, we might define it as follows:</p>
<pre><code class="language-C++">    virtual Vehicle* clone() = 0;
</code></pre>
<p>But in <code>Car</code>, we know that if we clone a <code>Car</code> we'll get another <code>Car</code> back, so it would sure be nice to override it like such:</p>
<pre><code class="language-C++">    Car* clone() override {/* ... */ }
</code></pre>
<p>Well we actually can! This is known as <em>covariant</em> return types and it permits derived classes to return an object that is derived from the return type of the virtual function. 
This is not an overload, and in fact, two functions that differ in <strong>only</strong> their return types are not overloads.</p>
<p>Similarly, derived objects can take arguments that are supertypes of the defined arguments of the virtual function. This is known as contravariance. </p>
<pre><code class="language-C++">    // in Vehicle:
    virtual void fix(const Car &amp; c) {/*...*/}

    //in Car:
    void fix(const Vehicle &amp; v) override {/* .. */}
</code></pre>
<h3 id="possible-exercises-1"><a class="header" href="#possible-exercises-1">Possible Exercises</a></h3>
<ol>
<li>Create a <code>Logger</code> interface and at least two concrete subtypes. One for logging to the console and one for logging to a file. (<code>std::fstream</code> may help out). Also create a <code>LogLevel</code> enum that allows differentiating the severity of the message between at least 3 severity levels. The <code>LogLevel</code> should change the display of the log in their respective medium. Perhaps for the console logger you can change the color with ANSI escape codes and for the file logger use textual features such as capitals or markdown symbols like underscores and asterisks. The interface should have at least 1 function, which could take a string message and log level. Try using the <code>Logger</code> polymorphically.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h1>
<p>We've seen public inheritance in the last chapter. It has the syntax <code>: public Base</code> and models an &quot;is-a&quot;/&quot;subtype-of&quot; relationship. 
Before going further, let's look at a classic example of where the wording &quot;is-a&quot; can lead us astray. Is a square a rectangle? Mathematically, yes. But in computer science, that depends...</p>
<p>Consider:</p>
<pre><code class="language-C++">class Rectangle {
protected:
    int length, width;
public:
    Rectangle(int l, int w) : length(l), width(w) {}
    virtual ~Rectangle() = default;

    virtual void setLength(int l) {
        length = l;
    }

    virtual void setWidth(int w) {
        width = w;
    }

    int area() const {
        return length * width;
    }

    int perimeter() const {
        return 2 * length + 2 * width;
    }

    int getWidth() const { return width; }
    int getLength() const { return length; }
};

class Square : public Rectangle {
public:

    Square(int sideLen) : Rectangle(sideLen, sideLen) {}

    void setLength(int l) override {
        length = width = l;
    }

    void setWidth(int w) override {
        length = width = w;
    }
};


Square s(5);

Rectangle &amp; r = s;
// ...

// Now image we don't know that r is a square
// which is the entire point of Polymorphism
r.setLength(10);
// image the surprise when we find that the width changes as well!
r.getWidth();

</code></pre>
<p>In this example, the interface of Rectangle doesn't match Square. If we wrote specs for Rectangle's <code>setLength</code> and <code>setWidth</code>, the likely specification &quot;sets the Rectangle's length/width&quot; 
clearly doesn't match the behavior of setting both the length and width! While a square <em>is a</em> rectangle by definition, it does not adhere to the interface. 
Based on this code snippet, we are inheriting from Rectangle for code reuse. A much better alternative would be to make <code>area()</code> and <code>perimeter()</code> free functions. 
In this simplistic case, we can make <code>Square</code> and <code>Rectangle</code> separate <code>structs</code> with their internals known.</p>
<pre><code class="language-C++">struct Square { 
    int sideLen;
};

struct Rectangle {
    int length, width;
};

int area(int length, int width) {
    //...
}

int perimeter(int length, int width) {
    //...
}

// or if you'd prefer:

int area(const Square &amp; s) { 
    return area(s.sideLen, s.sideLen); 
}

int area(const Rectangle &amp; r) {
    return area(r.length, r.width);
}

</code></pre>
<p>Now I'd like to distinguish between implementation and interface inheritance. 
Interface inheritance is when a class inherits from an interface (pure virtual functions) to provide decoupling between the interface and implementation(s). 
Implementation inheritance is inheritance in order to share code (square and rect example). 
We want to be wary of implementation inheritance. 
Inheritance is a very strong coupling relationship, and therefore implementation inheritance should be avoided when possible. 
Instead of implementation inheritance, we can factor out shared functionality into functions like in the above example, or use object composition. 
Here's an example of interface inheritance:</p>
<pre><code class="language-C++">class Port {
public:
    /**
    * Writes the entire buffer to the port
    * @throw std::runtime_exception if the write failed
    */
    virtual void write_all(const std::vector&lt;std::byte&gt; &amp; data) = 0;

    /**
    * Blocks until it reads the specified amount of bytes
    * @param size the amount of bytes to wait for
    * @throw std::runtime_exception on fail
    */
    virtual std::vector&lt;std::byte&gt; read_all(size_t size) = 0;

    /**
    * Reads data currently available on the port
    * May or may not read all the data available
    * @return the data read from the port or an empty vector if nothing
    *   is available
    */
    virtual std::vector&lt;std::byte&gt; read_nonblock() = 0;


    /**
    * Gets the amount of bytes &lt;= to the amount of bytes available to be read
    * Guaranteed to return at least 1 if there is any data available
    */
    virtual size_t available() const noexcept = 0;

    virtual ~Port() = default;
};

class MemoryPort : public Port {
    // Implement methods for reading/writing to an area in memory
    // useful for testing
};

class Socket : public Port {
    // Implement interface for reading/writing to a socket
};

class Serial : public Port {
    // Read/write to a serial port
};

class FDPort : public Port {
    // Read/write to a pipe or file
};

void logError(Port &amp; port, const std::string &amp; str) {
    // do some logging
    
    // log doesn't know or care the implementation of Port
    // Are we logging to the console? a file? logging to a pipe to another
    // program which will respond to the errors?
    // are we a remote service logging to another service via sockets?
    // are we a slave logging to the master over a serial connection?
    // don't know and don't care!
}

</code></pre>
<p>All of these types are subtypes of <code>Port</code>. 
They can be used polymorphically and prevent users from depending on or knowing about any implementation. 
This is the hallmark of OOP and is known as <em>dependency inversion</em>, which we'll discuss later.</p>
<p>With all that being said, let's look at a tool specifically designed for implementation inheritance: private inheritance. 
Private inheritance is the same as public inheritance, but all public members of the base class become private members in the derived class. 
This models an &quot;implemented-in-terms-of&quot; or a &quot;has-a&quot; relationship which is the same relationship modelled by object composition. 
Therefore, you should prefer composition to private inheritance. Truthfully, I can't remember a time when I've used private inheritance.</p>
<p>One super nit picky usage of private inheritance is to take advantage of EBO or the empty base optimization. In C++, a variable must at least take up 1 byte, regardless if its type actually needs this space. 
So if we instantiate a class with no data members for object composition, that instance will take up at least a byte. Private inheritance is a way to circumvent this and get access to the 
member functions of a class without paying for unnecessary space. Would I recommend using private inheritance for EBO? No, probably not, but I thought I'd mention it.</p>
<p>Private inheritance is not polymorphic. 
This intuitively makes sense since every part of the Base class's interface is private. 
If it were polymorphic, then you could break encapsulation by changing the static type of the Derived class to the Base class and call the Base class member functions.</p>
<p>Syntactically, the only difference is <code>: private Base</code> instead of <code>: public Base</code>.</p>
<h2 id="multiple-inheritance"><a class="header" href="#multiple-inheritance">Multiple Inheritance</a></h2>
<p>C++ allows inheriting from multiple base classes. This should really only be used for interface inheritance.</p>
<pre><code class="language-C++">class Drawable {
public:
    virtual void draw() = 0;
};

class Entity {
public:
    virtual bool isAggro() = 0;
    virtual void takeTurn() = 0;
};

class Player : public Drawable, public Entity {
    // multiple interface inheritance


    // implement functions
};

</code></pre>
<p>If used for interfaces only, multiple inheritance is straightforward. But consider the following:</p>
<pre><code class="language-C++">struct A {
 protected:
    int aVar;
    void doA();
 }
 class B : public A {}
 class C : public A {};
 class D : public B, public C {};
</code></pre>
<p>This diamond shaped hierarchy is best avoided, but if it does happen it might not be clear how it will behave. 
Remember, derived classes and their members are simply tacked on to the base class. 
Therefore, here we inherit from <code>A</code> twice and get two copies of the variable <code>aVar</code>. To use it, we must explicitly qualify which parent's <code>aVar</code> to use.</p>
<pre><code class="language-C++"> D d;
 d.B::aVar = 0;
 d.C::aVar = 1;
 // two copies of the same variable
 
 // or from within D:
 void D::doStuff() {
    int a1 = B::aVar;
    int a2 = C::aVar;
 }
</code></pre>
<p>The way to avoid this is <em>virtual inheritance</em>. 
Virtual inheritance enforces that a base is only inherited once. 
Implementations vary but this generally could be implemented by derived classes holding pointers to their parent classes. 
Virtual inheritance is beefier and more expensive.</p>
<pre><code class="language-C++"> class A {};
 class B : public virtual A {};
 class C : public virtual A {};
 class D : public B, public C {};
</code></pre>
<p>It's good to know these features exist, but the best method for dealing with these problems is to not create them in the first place. 
Multiple inheritance should be used mainly for representing subtypes of multiple distinct interfaces.</p>
<h2 id="final"><a class="header" href="#final">Final</a></h2>
<p>You can use the <code>final</code> keyword to declare a function to be the final overrider. Subclasses of the class where the method was declared <code>final</code> will no longer be able to override it. 
<code>final</code> should be used sparingly.</p>
<pre><code class="language-C++">class Base {
public:
   virtual void doIt() = 0;
};

class Derived1 : public Base {
private:
   virtual void doA() = 0;
   virtual void doB() = 0;
public:
   void doIt() final {
       doA();
       doB();
   }
};

class Derived2 : public Derived1 {
   void doA() override { /*... */}
   void doB() override {/*...*/}

public:
   void doIt() override {} //error!
}
</code></pre>
<p>It's best to only have 1 of <code>final</code>, <code>virtual</code>, or <code>override</code>. qualifiers for a given function declaration. 
For the declaration of a virtual function, use <code>virtual</code>. Then all derived classes should use <code>override</code> or <code>final</code> (and not both).</p>
<h2 id="default-arguments"><a class="header" href="#default-arguments">Default Arguments</a></h2>
<p>Default arguments of methods are determined by the static type of the context object. 
To avoid problems, do not override the default arguments of virtual functions.</p>
<pre><code class="language-C++">class Logger {
public:
   virtual void log(const std::string &amp; msg = &quot;Hello&quot;) = 0;
};

class ErrorLogger : public Logger {
public:
   void log(const std::string &amp; msg = &quot;Error!&quot;) override {
       // bad practice, should not override default arguments
       //...
   }
};

ErrorLogger log;
log.log(); // default argument &quot;Error!&quot;

Logger &amp; l2 = log;
l2.log(); // default argument &quot;Hello&quot;

</code></pre>
<h2 id="alternatives-to-inheritance"><a class="header" href="#alternatives-to-inheritance">Alternatives to Inheritance</a></h2>
<ul>
<li>Object composition and delegation
<ul>
<li>Object's members are other classes which it delegates some responsibility to by calling its methods</li>
</ul>
</li>
<li>Interfaces
<ul>
<li>Subtyping</li>
</ul>
</li>
<li>Mixins
<ul>
<li>Think of creating a set of related, reusable functions, naming this set, and extending a class with it</li>
<li>In C++ this can be realized by inheriting from abstract classes that <strong>do not</strong> have <code>protected</code> data members.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casts"><a class="header" href="#casts">Casts</a></h1>
<p>With our <code>Rational</code> class, we saw how we can convert integers to <code>Rational</code> implicitly. What about making a conversion that goes the other way? Can we make <code>Rational</code> convert to something like a <code>double</code>?</p>
<p>Well yes, yes we can.</p>
<pre><code class="language-C++">    // in the Rational class
    operator double() const { return num / static_cast&lt;double&gt;(den); }
</code></pre>
<p>This conversion is implicit. Which can lead to a problem:</p>
<pre><code class="language-C++">Rational r(10, 2);
if (r == 10) {
    // do we promote 10 to Rational and call operator==(Rational, Rational)
    // or de we convert r to a double and do operator==(double, int)?
}
</code></pre>
<p>Implicit conversions (either constructor or conversion operator) are not really the best practice. 
Especially when that conversion is to/from integral types. Consider some things that these implicit conversions allow, but don't make much semantic sense:</p>
<pre><code class="language-C++">Rational r(10, 20);
if (r == 'h') {
    // convert 'h' to an integer, then to a Rational
    // or convert r to double and compare with integral value of 'h'
}

r = true; 
//convert true to int and int to Rational, then update via operator=
</code></pre>
<p>Now with a Rational, most things make sense except <code>char</code>s and <code>bool</code>s. But, just like we can make the conversion constructor <code>explicit</code>, we can make the conversion operator <code>explicit</code>.</p>
<pre><code class="language-C++">    explicit operator double() const { return num / static_cast&lt;double&gt;(den); }
</code></pre>
<p>Now we can use <code>static_cast&lt;double&gt;</code> to explicitly convert a <code>Rational</code>.</p>
<pre><code class="language-C++">Rational r(10);

const auto rd = static_cast&lt;double&gt;(r);
</code></pre>
<p><code>static_cast&lt;T&gt;(E)</code> is mostly safe and only permitted if there is a valid conversion from the type of <code>E</code> to <code>T</code>. Such a conversion may be implicit or explicit. 
<code>static_cast</code> cannot cast away qualifiers such as <code>const</code>. Moreover <code>static_cast</code> can perform upcasts (casting a Derived class reference to a base class reference) 
and downcasts (casting a base class reference to a derived class reference) 
provided the cast is unambiguous (no duplication due to diamond hierarchies, multiple inheritance, or virtual inheritance). 
However <code>static_cast</code> performs no checks that the Base class's actual type is the Derived class during a downcast.</p>
<pre><code class="language-C++">const auto i = static_cast&lt;int&gt;(54.078);
const auto d = static_cast&lt;float&gt;(true);

class B { 
public:
    virtual ~B() = default; 
};
class D : public B {};

D d;
B &amp; b = d;

auto d2 = static_cast&lt;D&amp;&gt;(b);
// notice that we are casting to a reference to D and not to D itself
// dangerous

auto b2 = static_cast&lt;B&amp;&gt;(d);
// upcast, safe
</code></pre>
<p>For a safer way to downcast, C++ provides <code>dynamic_cast&lt;T&gt;(E)</code>. 
Like static casts, <code>dynamic_cast</code> can perform upcasts and adding <code>const</code>. But where it differs greatly is during downcasts. 
<code>dynamic_cast</code> only works on polymorphic hierarchies (those which have at least one virtual function). 
Given <code>dynamic_cast&lt;T&gt;(E)</code>, if <code>T</code> is a pointer or reference to a type derived from the static type of <code>E</code>, and the dynamic type of <code>E</code> is <code>T</code> or a derived type of <code>T</code>, the cast succeeds. 
Otherwise, the cast fails and throws <code>std::bad_cast</code> if used on references or returns <code>nullptr</code> if used on pointers. 
<code>dynamic_cast</code> works with virtual inheritance, unlike <code>static_cast</code>, and costs an extra type check at runtime. 
Furthermore, the cast returns <code>nullptr</code> if <code>E</code> evaluates to <code>nullptr</code>.</p>
<pre><code class="language-C++">class B { 
public:
    virtual ~B() = default; 
};
class D : public B {};
class C : public D {};

D d;
B &amp; b = d;
C c;

auto d2 = dynamic_cast&lt;D&amp;&gt;(b);
// notice that we are casting to a reference to D and not to D itself
// now safe, will perform a runtime type check

auto b2 = dynamic_cast&lt;B&amp;&gt;(d);
// upcasts incur no runtime check


auto c2 = dynamic_cast&lt;C&amp;&gt;(b); 
// std::bad_cast
// undefined behavior if this were static_cast
</code></pre>
<h2 id="dangerous-casts"><a class="header" href="#dangerous-casts">Dangerous Casts</a></h2>
<p>First up on the &quot;bad boy&quot; side of town is <code>const_cast&lt;T&gt;(E)</code>. This one allows you to strip qualifiers off the type of <code>E</code>.</p>
<pre><code class="language-C++">const int a = 10;
auto t = static_cast&lt;int&gt;(a); //error, a is const

auto t2 = const_cast&lt;int&gt;(a); //works

auto t3 = const_cast&lt;const int&gt;(t2);
</code></pre>
<p>It also allows you to add qualifiers as well.</p>
<p><code>reinterpret_cast&lt;T&gt;(E)</code> completely reinterprets the bytes of <code>E</code> as the bytes of <code>T</code>.</p>
<pre><code class="language-C++">double d = 58.01;
auto d2 = *reinterpret_cast&lt;long long*&gt;(&amp;d);
// d2 is not 58
// instead, it will read the floating point representation of d
// and interpret that as twos-complement

int num = 100;
auto bytes = reinterpret_cast&lt;std::byte*&gt;(&amp;num);
bytes[0]; 
// most likely 100 for little endian, 0 for big endian

const double dub = 10;
auto bytes = reinterpret_cast&lt;std::byte*&gt;(&amp;dub);
// error, cannot cast away const

</code></pre>
<p>Finally, there is the C-style cast. This guy should be avoided because you will never know what type of cast is actually being performed. 
The C-style cast has the most power and can pretty much convert anything to anything else. 
An example problem: You want to use a conversion function but forgot to implement it. 
A C-style cast won't complain and will reinterpret the bytes which is <strong>not</strong> what was intended! A <code>static_cast</code> would fail to compile.</p>
<h3 id="possible-exercises-2"><a class="header" href="#possible-exercises-2">Possible Exercises</a></h3>
<ol>
<li>Add explicit conversions to/from <code>std::vector</code> for the <code>Vec3D</code> class exercise.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oop-and-class-guidelines"><a class="header" href="#oop-and-class-guidelines">OOP and Class Guidelines</a></h1>
<h2 id="prefer-non-member-non-friend-functions"><a class="header" href="#prefer-non-member-non-friend-functions">Prefer Non-member non-friend functions</a></h2>
<p>A non-member, non-friend function can only use the public interface of a class. 
This promotes encapsulation by only allowing the function to access data it needs. 
Of course, there are plenty of functions that need to be a member or access private data. 
These types of functions can be kept as members, but convenience functions and other operations that can be implemented with the public interface should be non-members so long as they don't incur 
<em>premature pessimization</em>. This helps promote the <em>coherence</em> of a class. Coherence is basically a measure of how many member variables are used in a member function. 
Ideally, every method of a class uses every member variable. Poor coherence indicates that the class may be doing too many things and therefore exposing members to functions which are unrelated.</p>
<pre><code class="language-C++">class RingBuffer {
public:
    size_t size() { /* ... */}
};

bool empty(const RingBuffer &amp; rb) {
    return rb.size() == 0;
}
</code></pre>
<p>There's actually a TS (technical specification, basically a proposal for a language or library feature) for <em>unified function calls</em> which would allow <code>empty()</code> 
to be called as if it were a member function or <code>size()</code> to be called as if it were a free function. Will this ever be part of a future version of C++? Not sure.</p>
<h2 id="nvi-idiom"><a class="header" href="#nvi-idiom">NVI Idiom</a></h2>
<p>NVI stands for non-virtual interface, and it's basically an application of GOF's Strategy Pattern. 
The idea is to have a public interface which is non-virtual (public virtual destructor not included) and provide private or protected methods which serve as hooks of customization by subtypes. 
This allows breaking up a complex computation into smaller customizable steps and/or enforcing pre and post conditions which all subtypes must uphold in the supertype.</p>
<p>A private virtual function can be overriden by subtypes, but unlike protected functions, the subtype cannot call it directly.</p>
<pre><code class="language-C++">class MsgFormatter {
    virtual std::vector&lt;std::byte&gt; _format(const std::vector&lt;std::byte&gt; &amp; data) = 0;
    virtual std::vector&lt;std::byte&gt; str_to_bytes(const std::string &amp; str) = 0; 
public:
    void std::vector&lt;std::byte&gt; format(const std::string &amp; data) {
        // assert preconditions
        auto res = _format(str_to_bytes(data));
        // assert postconditions
        return res;
    }

    virtual ~MsgFormatter() = default;
};

class AsciiMsgFormatter : public MsgFormatter {
    //..
    // override _format and str_to_bytes
};
</code></pre>
<p>In this example, if <code>_format</code> were independent of <code>str_to_bytes</code> it might be better to use <em>mixins</em> or <em>policy based design</em> (we'll talk about this later) but that's kind of the idea.</p>
<h2 id="other-guidelines"><a class="header" href="#other-guidelines">Other Guidelines</a></h2>
<ul>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-protected">C.133</a> - Avoid <code>protected</code> data. This is a sign of implementation inheritance and, as shown, can be quite annoying when used with multiple inheritance.</li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion">C.164</a> - Avoid implicit conversions</li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-get">C.131</a> - Classes should generally be told to do something, not get at their internals. If a class has quite a few trivial getters and setters, then that could be a sign that the internals should be public and a <code>struct</code> might be a better choice.</li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-constref">C.12</a> - Class members probably shouldn't be <code>const</code> or references. These types of members can only be set once. So we can construct object with these types of members by setting them in the constructor, but we can't copy them using <code>operator=</code>.</li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conventional">C.160</a> - Don't be cute with overloads. Overload operators for operations that make sense in C++. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructors-and-destructors"><a class="header" href="#constructors-and-destructors">Constructors and Destructors</a></h1>
<p>We've seen these a bit before, but let's take a closer look.</p>
<p>The constructor is called when an instance of the class is created, and the destructor when the instance is destroyed. 
If the user does not define any, they are auto-generated by the compiler. 
In C++, we have the &quot;normal&quot; constructor, copy constructor, move constructor and destructor. We also have move and copy assignment which are overloads of <code>operator=</code>.</p>
<p>If you define none of these functions, the compiler will generate them for you. 
If you write any constructor (copy, move, or direct) then the compiler will not generate the default (no parameter) constructor. 
Furthermore, auto generation of copy constructor and copy assignment is deprecated if a user defines a destructor or another copy operation. 
The compiler may still generate them however, and this is to preserve backwards compatibility since prior to C++11 these auto generation rules weren't enforced. 
Auto generation of all constructors and assignment operations are forbidden when a move constructor or move assignment is defined. 
Finally, move constructors are auto generated only if the class contains no other copy or move methods, destructors, or constructors. 
Since move operations are a C++11 feature, defining them indicates that the class isn't legacy code, and the compiler can enforce auto generation rules.</p>
<p>Generally, if you need to write 1 of the resource management functions, your class's resource handling is probably nontrivial, and you should probably write or explicitly delete the rest. </p>
<pre><code class="language-C++">class One {
public:
    One(int a);
    // move constructor and assignment not generated
    // copy assignment and constructor gen deprecated
    // no gen of default constructor
};

class Two {
public:
    ~Two();
    // move constructor and assignment not generated
};

class Three {
    // all auto gen done
};

class Four {
public:
    Four(const Four &amp; f); //copy constructor
    // no move ops gen 
    // no default ctor
    // deprecated copy assignment
};

class Five {
public:
    Five&amp; operator=(const Five &amp; other); //copy assignment
    // no move ops
    // deprecated copy gen
};

class Six {
public:
    Six(Six &amp;&amp; other); //move constructor, more on this later
    // nothing else generated
};

</code></pre>
<p>Constructors are called to create a new object. Assignment operators are called to update an existing object.</p>
<pre><code class="language-C++">{
    MyInteger myInt(10); // direct constructor
    MyInteger myInt2 = myInt; // copy constructor, myInt2 is a new instance
    MyInteger myInt3(myInt); // also copy constructor
    myInt3 = myInt2; // copy assignment, myInt3 already exists
} // myInt, myInt2, and myInt3 go out of scope here -&gt; call destructors of all of them
</code></pre>
<p>There are cases when we need to define an operation because we defined a function that blocks its generation yet we don't need any special logic. For that, as we have already seen, we can use <code>= default</code>.</p>
<pre><code class="language-C++">class MyClass {
public:
    MyClass(MyClass &amp;&amp; other) { /* .. */}
    // all other operation generation prohibited

    MyClass() = default;
    MyClass&amp; operator=(const MyClass &amp;) = default;
    MyClass(const MyClass &amp;) = default;
    MyClass&amp; operator=(MyClass &amp;&amp;) = default; // move assignment (more on this later)

};
</code></pre>
<p>On a slightly similar note, if generation is prohibited and we don't want our class to have those functions (or even if generation isn't forbidden but we just don't want them), 
we should explicitly <code>= delete</code> them to make our intentions clear.</p>
<pre><code class="language-C++">class Class2 {
public:
    Class2(const Class2 &amp; other) { /* ... */ }
    // default ctor and move ops not generated

    Class2() = default;

    Class2&amp; operator=(Class2 &amp;&amp;) = delete;
    Class2(Class2 &amp;&amp;) = delete;
    Class2&amp; operator=(const Class2 &amp;) = delete;
};
</code></pre>
<p>Pre C++11, you can imitate this effect by defining functions you didn't want as private. Don't do that, but if you come across legacy code that uses this pattern now you know what it's doing.</p>
<h2 id="move-basics"><a class="header" href="#move-basics">Move Basics</a></h2>
<p>Now I talk about this move constructor. But what is moving exactly? Well, instead of performing a copy, we move the internals from one object to another, leaving behind an empty shell of an object to be destroyed. 
When the old object is destroyed, nothing happens because the object's internal state has been moved out and put into a new object.</p>
<p>The double ampersand is an <em>rvalue reference</em>, and basically it is a reference to temporary values. 
For example, the return value of a function is moved (well, sometimes, more on this later) into a temporary value and that temporary is returned. 
The temporary gets destroyed at the end of the statement that called the function. We can also manually move non-temporaries with the <code>std::move</code> function. 
However, once a value has been moved, you <strong>must not</strong> use it again since all of its state has been put into a different object.</p>
<p>Now frankly, I've told you a flat out lie, but we'll discuss this in way more detail later.</p>
<pre><code class="language-C++">std::string getString() {
    return &quot;Hello&quot;;
}

std::string greet(std::string &amp;&amp; name) {
    return &quot;Hello &quot; + name;
}

std::string myStr = getString(); // move constructor
std::string myStr2 = std::move(myStr); // move constructor again
const auto myStr3 = myStr2; // copy constructor

std::string myName = &quot;Jacob&quot;;
auto greeting = greet(std::move(myName));
    // move ctor for name in the greet() function
    // move ctor for greeting
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raii"><a class="header" href="#raii">RAII</a></h1>
<p>RAII is probably the most important idiom in C++. It stands for Resource Acquisition is Initialization, although it has more to do with destruction than initialization. 
Objects stored on the stack have automatic lifetimes and are automatically popped off the stack when they go out of scope. 
RAII is the idea of wrapping some resource in an object with an automated lifetime so you never have to worry about cleaning it up. Here's the basic idea:</p>
<pre><code class="language-C++">class Socket {
private:
    unsigned int sock;
    bool open;
public:
    Socket() : sock(socket(AF_INET, SOCK_STREAM, 0)),
        open(false) {}
    ~Socket() {
        closesocket(sock);
    }
};
//...


//In some function
{
    Socket s;
    //...
} // socket closed when s is destroyed
</code></pre>
<p>So what's the advantage of RAII you ask? Well now you need not worry about <code>Socket</code> being cleaned up. 
If an exception is thrown or the variable goes out of scope, the resource is automatically released. </p>
<p>When you have behavior that must run on every single execution path, think RAII! 
If you have to cleanup a resource or call a resource freeing function (something like <code>free</code>, <code>delete</code>, <code>cleanup</code>, etc.), think RAII.</p>
<pre><code class="language-C++">class BlanketErrorLogger {
    std::optional&lt;std::string&gt; msg;
public:
    BlanketErrorLogger(const std::string &amp; errorMsg) : msg(errorMsg) {}

    void succeed() { msg = std::nullopt; } // make the optional empty

    ~BlanketErrorLogger() {
        if (msg) {
            std::cerr &lt;&lt; msg.value() &lt;&lt; &quot;\n&quot;;
        }
    }

};

// DISCLAIMER: not necessarily the actual Ws2 API
class WinsockContext {
    inline static unsigned ctxCount = 0;
public:
    WinsockContext() {
        if (ctxCount++ == 0) {
            WSAData data;
            WSAStartup(MAKEWORD(2, 1), &amp;data);
        }
    }

    ~WinsockContext() {
        if (--ctxCount == 0) {
            WSACleanup();
        }
    }
};

int main(int argc, char ** argv) {
    WinsockContext wsa;
    std::stringstream ss;
    // argv[0] is the current filepath
    for(auto i = 1; i &lt; argc; ++i){
        ss &lt;&lt; argv[i] &lt;&lt; &quot; &quot;;
    }
    BlanketErrorLogger err(&quot;Command: \&quot;&quot; + ss.str() + &quot;\&quot; failed!&quot;);
    //
    // Complex socket operations
    //
    err.succeed();
    return 0;
}
</code></pre>
<p>In this example, no matter what happens we cleanup the Windows Socket API. If execution stops before <code>err.succeed()</code> is called, then we'll also get a log message with the command line arguments that caused the error.</p>
<p>Now you may be wondering why <code>ctxCount</code> is defined as <code>inline</code> and <code>static</code>. 
Well a <code>static</code> variable means there is only one copy of the data. We can have static variables in functions and classes. 
Here, we define <code>ctxCount</code> static so that we retain a count of all instances of <code>WinsockContext</code>. 
This allows us to check in the destructor if the current instance being destroyed is the last existing instance, and if so cleans up WSA. 
This check allows us to nest instances of <code>WinsockContext</code> without accidentally cleaning up the resource while other code is still using it.</p>
<pre><code class="language-C++">int amtOfCalls() {
    static int count = 0; //only assigned once
    return ++count;
}

amtOfCalls(); // 1
amtOfCalls(); // 2
amtOfCalls(); // 3
</code></pre>
<p>A static variable is initialized the first time the path of execution goes through the static variable's definition. 
It's destroyed when the program ends, however the order of de-initialization between static variables when the program terminates is undefined. 
Therefore, using a static variable in the destructor of a class which has a static instance can lead to problems. 
This issue commonly arises in Singletons, and as such is referred to as the Singleton Dead Reference problem, which we'll discuss later.</p>
<p>Ok so that's <code>static</code>. Then what's the deal with <code>inline</code>? 
Well let's say that <code>WinsockContext</code> was defined in a header, and we include this header in multiple source files. 
Then if <code>ctxCount</code> weren't inline then we'd have multiple definitions of <code>WinsockContext::ctxCount</code>. 
<code>inline</code> variables allow us to declare and define variables in a header file by telling the compiler that if multiple definitions are generated, they're all the same and to choose one of them. 
Without <code>inline</code>, we'd have to do something like this:</p>
<p>WinsockContext.h</p>
<pre><code class="language-C++">class WinsockContext {
    static unsigned ctxCount;
public:
    WinsockContext() {
        if (ctxCount++ == 0) {
            WSAData data;
            WSAStartup(MAKEWORD(2, 1), &amp;data);
        }
    }

    ~WinsockContext() {
        if (--ctxCount == 0) {
            WSACleanup();
        }
    }
};
</code></pre>
<p>WinsockContext.cpp</p>
<pre><code class="language-C++">#include &quot;WinsockContext.h&quot;
static int WinsockContext::ctxCount = 0;
</code></pre>
<p>Just to ram RAII into your head a tad bit more, here's another example:</p>
<pre><code class="language-C++">// DISCLAIMER: Not necessarily the actual stb_image or OpenGL API
// I'm just doing this from memory
struct LoadImg {
    stb_uchar* img;
    int width, height, channels;
    LoadTexture(const char * file_path) {
        img = stbi_load(file_path, &amp;width, &amp;height, &amp;channels, NULL);
        if (!img) {
            throw std::runtime_error(std::string(&quot;Failed to load image at &quot;) +
                file_path);
        }
    }

    ~LoadTexture() {
        if (img) {
            stbi_free(img);
        }
    }

    // copy operations could delete data we are still using
    // delete it
    LoadTexture(const LoadTexture &amp;) = delete;
    LoadTexture&amp; operator=(const LoadTexture &amp;) = delete;
    LoadTexture(LoadTexture &amp;&amp;) = delete;
    LoadTexture&amp; operator=(LoadTexture &amp;&amp;) = delete;
};

GLuint channelsToImgFmt(int channels) {
    switch(channels) {
        case 4:
            return GL_RGBA;
        case 3:
            return GL_RGB;
        case 1:
            return GL_RED;
        default:
            throw std::runtime_error(
                std::string(&quot;Invalid number of img channels: &quot;) + channels);
    }
}

class Texture {
    GLuint tex;
public:
    Texture(const char * file) {
        LoadImg img(file);
        glGenTextures(1, &amp;tex);
        glBindTexture(GL_TEXTURE_2D, tex);
        const auto fmt = channelsToImgFmt(img.channels);
        glTexImage2D(GL_TEXTURE_2D, 0, fmt, img.width, img.height, fmt, GL_BYTE, img.data);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTIRE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    }

    ~Texture() {
        if(tex != GL_INVALID) {
            glDeleteTextures(1, &amp;tex);
        }
    }

    // copy operations could delete data we are still using
    // delete it
    Texture(const Texture &amp;) = delete;
    Texture&amp; operator=(const Texture &amp;) = delete;
    Texture(Texture &amp;&amp;) = delete;
    Texture&amp; operator=(Texture &amp;&amp;) = delete;
};
</code></pre>
<p>Now I mention that copy operations can delete data we are still using. 
How? Well suppose we copied <code>Texture</code> by copying <code>tex</code>. 
<code>tex</code> is just a handle to memory allocated in VRAM, so we're copying the handle but not the actual data. 
But now we have two instances of classes that claim to own the data and will delete it when they are destroyed. 
This isn't good! The second destructor to get called will delete invalid data! 
If we wanted, we could override the copy operations to perform deep copies, but for simplicity, it's easier to just prevent those operations from occurring.</p>
<p>However, we could easily make <code>Texture</code> moveable.</p>
<pre><code class="language-C++">    Texture(Texture &amp;&amp; other) {
        tex = other.tex;
        other.tex = GL_INVALID;
        // invalidate the temporary's data
        // so that when it's destroyed it doesn't delete our data
        // other is a temporary or value we don't care about, so it's safe to
        // invalidate its handle
    }

    Texture&amp; operator=(Texture &amp;&amp; other) {
        if(tex != GL_INVALID) {
            glDeleteTextures(1, &amp;tex);
        }
        tex = other.tex;
        other.tex = GL_INVALID;
    }
</code></pre>
<p>You may be wondering: &quot;If the program is going to terminate anyway, must we be so careful with releasing resources?&quot;. 
In today's day and age, no, probably not. The OS should be able to cleanup any resources that a program doesn't when it terminates. 
But that's only <em>when</em> it terminates. What if we decide to catch texture loading errors and then try again with a lower resolution image? 
Perhaps whatever image we are trying to load is nonessential, so if it fails to load we just ignore it. 
This might not be something we are currently doing at the time of writing the code, but maybe months or years down the line that might change. </p>
<h3 id="possible-exercises-3"><a class="header" href="#possible-exercises-3">Possible Exercises</a></h3>
<ol>
<li>Try writing a RAII class that prints to standard out during constructions and destruction. Ensure that proper resource deletion occurs when exceptions are thrown.</li>
<li>Can you make the previous RAII class work with copying?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<p>C++ provides the ability to <code>throw</code> and <code>catch</code> exceptions. Actually, you can throw and catch any value.
When you throw something. The stack <em>unwinds</em> until it reaches a caller which handles the exception.</p>
<pre><code class="language-C++">try {
    throw &quot;Hello&quot;;
} catch (const char * msg) {

}

</code></pre>
<p>The C++ standard library provides the base class <code>std::exception</code> which other standard exceptions are derived from and which you can use as a base class for user defined exceptions. 
<code>std::exception</code> provides a virtual function <code>what()</code> which is used to return a C string that contains a description of the error that occurred.</p>
<pre><code class="language-C++">class TextureLoadException : public std::exception {
    std::string errorMsg;
public:
    explicit TextureLoadException(const std::string &amp; file) {
        errorMsg = &quot;Could not create a texture from the image at: &quot; + file;
    }

    const char * what() const noexcept override {
        return errorMsg.c_str();
    }
};

// from RAII example: in constructor of LoadImage

    img = stbi_load(file, &amp;width, &amp;height, &amp;channels, NULL);
    if (!img) {
        throw TextureLoadException(file);
    }

</code></pre>
<p>In this example, we may throw an exception in a constructor. Is that safe? Yes! And in fact it's recommended.
If the object cannot be constructed, throwing an exception is often the best solution.</p>
<p>When catching exceptions, typically we often want to catch exceptions by reference. This allows us to catch exceptions polymorphically. 
So if we catch <code>const std::exception &amp;</code> we can catch <code>std::exception</code> and all its subtypes without object slicing. 
Furthermore, when catching polymorphic exceptions, we want to catch the most derived type first and least derived type last. 
If we did it the other way, derived types will be caught by the super type catch block preventing the code from ever reaching the derived type catch block.</p>
<pre><code class="language-C++">try {
    // do something
} catch (const std::invalid_argument &amp;) {
    // invalid_argument derives from logic_error

} catch (const std::logic_error &amp;) {

} catch (const std::exception &amp; e) {
    e.what(); // polymorphic what()
} catch (...) {
    // catch anything
}
</code></pre>
<p>Exceptions do incur a cost. So they should be used for <em>exceptional</em> circumstances, not things that are expected to happen or commonplace. 
For example, using an exception to signal the end of a file is probably not the best choice because it would be raised every time a file is read. 
For a situation like this, an <code>std::optional</code> would be a better choice which is something we'll discuss later.</p>
<p>C code typically uses error codes to indicate errors. This is <strong>not</strong> a good practice in C++, although it is still prevalent. Why?</p>
<ul>
<li>
<p>It's far cleaner, and cleaner code is easier to reason about</p>
<p>Compare </p>
<pre><code class="language-C++">const uint8_t size = narrow_cast&lt;uint8_t&gt;(
    sensor.parser.expectedLength());
const auto resp = sendFrameAndCheckResp(
    fmt-&gt;formatQueryMsg(sensor.message_id, size, motor), size);
auto ret = 
sensor.parser.parse&lt;double&gt;({ resp.begin(), resp.end() });
return ret;
</code></pre>
<p>with</p>
<pre><code class="language-C++">const uint8_t size = narrow_cast&lt;uint8_t&gt;(
    sensor.parser.expectedLength());
if (auto msg = fmt-&gt;formatQueryMsg(sensor.message_id, size, motor), size)) {
    if (const auto resp = sendFrameAndCheckResp(msg)) {
        auto ret = sensor.parser.parse&lt;double&gt;(
            { resp-&gt;begin(), resp-&gt;end() });
        return ret;
        // callee must verify return isn't nullptr
    } else
        //some error handling..
}
else
    // some error handling...
</code></pre>
<p>We just doubled the amount of code, and we didn't even get to whatever would need to be done for error handling. Next, the callee must then check the return isn't
nullptr, so they don't dereference null.</p>
</li>
<li>
<p><u>It's just as efficient or more efficient.</u> Yes there's some overhead to exceptions. But it's minuscule, and besides &quot;Premature optimizations are the root of all evil&quot;. 
And furthermore, exceptions are designed to be exceptional. That means that the compiler can easily optimize for the common case where no exceptions are thrown. 
Even with branch prediction, excessive if statements are going to cause a slowdown as well.</p>
</li>
<li>
<p><u>Callee's can't ignore them.</u> In the previous example, we required the callee to check the return value to make sure it wasn't nullptr. Are they going to do that? Maybe, maybe not. 
With exceptions, they either handle it, or they don't. But unlike returning nullptr or error codes, if they don't handle it, the exception safely propagates out of the callee. Remember, &quot;dead programs tell no lies.&quot; </p>
</li>
</ul>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<p>Assertions are a way to cause an error if some condition isn't true. In C++, we have the <code>static_assert()</code> which tests if a <code>constexpr</code> expression is true. 
If it isn't, compilation halts with a compiler error, and a user defined error message if one is specified.</p>
<pre><code class="language-C++">static_assert(sizeof(int) == 4, &quot;Requires that integers are 32 bits&quot;);

static_assert(sizeof(short) != sizeof(int)); //no user defined message
</code></pre>
<p>The C standard library also provides an <code>assert()</code> macro in <code>asssert.h</code>. This performs runtime checks only in Debug mode.
During release mode, they aren't part of the compiled binary. 
This was a commonplace practice in the old days, however today, many regard being able to assert in production
(or at least enable them from a test window/compiler flag) to be a good thing.
Furthermore, <code>assert</code> only takes one parameter. Thus, to get an error message we need to boolean AND our condition with a static string error message. 
Static string constants are <code>const char *</code>s, which like integers, are true for nonzero numbers and false for 0 (NULL). 
Truthfully, <code>assert</code> is old and generally if you need runtime assertions it's probably better to write your own.</p>
<pre><code class="language-C++">assert(!myString.empty());

assert(myVec.size() == 2 &amp;&amp; &quot;Expected a point&quot;);
// &quot;Expected a point&quot; is a static string, which, when converted to an integral value is non-zero
// thus it is considered 'true'
// since true is the null element for AND, it does not affect the test
</code></pre>
<hr />
<blockquote>
<p>&quot;Programs are meant to be read by humans and only incidentally for computers to execute.&quot;</p>
<p>- Donald Knuth</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="noexcept"><a class="header" href="#noexcept">Noexcept</a></h2>
<p>We saw how <code>std::exception::what()</code> is defined as <code>noexcept</code>. This means that it cannot throw an exception, or a thrown exception indicates a fatal error. 
Any exception that propagates out of a <code>noexcept</code> function calls <code>std::terminate</code> and ends the program. 
So you should declare functions that do not throw, or only throw to indicate program-terminating failures (like memory allocation failures), as <code>noexcept</code>. 
Furthermore, a <code>noexcept</code> function permits the compiler to optimize away error handling infrastructure for that function.
So it's a good idea to declare everything that you can as <code>noexcept</code>.</p>
<pre><code class="language-C++">int add(int a, int b) noexcept {
    return a + b;
}
</code></pre>
<p>We can also make functions <em>conditionally noexcept</em>. This means that the function will be <code>noexcept</code> if and only if some compile time expression is true.</p>
<pre><code class="language-C++">void x() noexcept; //noexcept

template&lt;typename T&gt;
void f() noexcept(sizeof(T) &lt; 4); //noexcept if sizeof(T) &lt; 4

void k();

constexpr bool isNoexcept = noexcept(k()); //false
// using noexcept() has a conditional operator
// noexcept(f) is true if f is a noexcept callable object
// otherwise the result is false

bool t() noexcept(noexcept(f&lt;char&gt;)); //t is noexcept
// noexcept(f&lt;char&gt;) is a constant expression that evaluates to true since f&lt;char&gt; is noexcept
// because sizeof(char) &lt; 4

bool s() noexcept(noexcept(f&lt;double&gt;)); //s is not noexcept

bool d() noexcept(noexcept(k())); //d is not noexcept

constexpr auto testNoexcept = noexcept(t()); //true
</code></pre>
<p>Notice how when we test if a function is noexcept, we need to have two <code>noexcept</code>s. This is because the inner <code>noexcept</code> is a conditional test, which returns <code>true</code> or <code>false</code> if the function passed is <code>noexcept</code> or not. 
The outer noexcept takes a <code>constexpr</code> boolean expression, and makes a function <code>noexcept</code> if the condition is <code>true</code>. 
Thus, when we pass the expression <code>sizeof(T) &lt; 4</code>, we only need one since this is a <code>constexpr</code> expression. </p>
<p>We'll talk about templates and <code>constexpr</code> more later, but basically all of these conditions are determined at compile time. This incurs no runtime cost.</p>
<h2 id="exception-guarantees"><a class="header" href="#exception-guarantees">Exception Guarantees</a></h2>
<p>There are 3:</p>
<ul>
<li>
<p>Nothrow Guarantee</p>
<p>This is denoted by <code>noexcept</code> on the function declaration. This is the strongest exception guarantee, and it doesn't necessarily mean the function does not throw. 
What it means is that if the function does throw, some disastrous and non-recoverable error just occurred. Use this more often than you might think, since &quot;dead programs tell no lies&quot;</p>
</li>
<li>
<p>Strong Guarantee</p>
<p>This guarantees that an operation is atomic with respect to exceptions. The operation either completes, or an exception is thrown and nothing happened. 
If an operation with this guarantee fails, the state of the program will be exactly what it was before the operation.</p>
</li>
<li>
<p>Basic Guarantee</p>
<p>This guarantees that if an operation does fail, no invariants are broken and the program will return to some valid state. 
This is the weakest of the three, and the minimum guarantee required for a correct program.</p>
</li>
</ul>
<p>C++'s STL always offers the strong guarantee (or noexcept when denoted as such) except for range insertions (offers the basic guarantee), 
insert and erase on deque and vector (which are strong only if their elements' copy and assignment offer that guarantee), and the streams library (which only offers the basic guarantee).</p>
<p>It's good to document when a function has the strong or basic guarantee. No need to document nothrow in most cases since <code>noexcept</code> is self-documenting.</p>
<p>Destructors and move operations should be <code>noexcept</code>.</p>
<pre><code class="language-C++">
void logExn(const char * information, const std::exception &amp; caughtExn) {
    std::cout &lt;&lt; &quot;An exception has occurred!&quot;
        &lt;&lt; &quot; (&quot; &lt;&lt; information &lt;&lt; &quot;)\n&quot;
        &lt;&lt; caughtExn.what()
        &lt;&lt; std::endl;
    //operator&lt;&lt;(std::ostream&amp;, _) has the basic guarantee
    //so this function will only have the basic guarantee
    // Ex. An error could occur printing caughtExn.what() after
    // &quot;An exception has occurred&quot; has already been printed
    // furthermore, an error could occur on outputting &quot;occurred!&quot;
    // after &quot;An exception has&quot; may already have been displayed
}

void logExnImproved(const char * information, const std::exception &amp; caughtExn) {
    std::stringstream ss;
    ss &lt;&lt; &quot;An exception has occurred!&quot;
        &lt;&lt; &quot; (&quot; &lt;&lt; information &lt;&lt; &quot;)\n&quot;
        &lt;&lt; caughtExn.what();
    const auto msg = ss.str(); //convert to string
    // If any of the above fails, state remains unchanged

    std::cout &lt;&lt; msg &lt;&lt; std::endl; 

    // Slightly improved by buffering the message first
    // but still basic
}

/// Appends c to both outStr and outVec
void appendToBoth(std::string &amp; outStr, std::vector&lt;char&gt; &amp; outVec, char c) {
    outStr += c; // strong
    outVec.push_back(c); // strong
    /* This code is broken
     An error may occur appending c to outVec after c was already appended to outStr
     This violates the postcondition and hence our function is broken
    */
}

/// Gets a tuple of (strBuffer, vecBuffer) after c has been appended to both
auto appendToBoth2(const std::string &amp; strBuffer, const std::vector&lt;char&gt; &amp; vecBuffer, char c) {
    std::string strCpy = strBuffer; // copy ctor, strong
    std::vector vecCpy = vecBuffer; // strong
    strCpy += c;
    vecCpy.push_back(c);
    return std::make_tuple(strCpy, vecCpy);

    // Now we achieved the strong guarantee!
    // It cost 2 extra copies and a few extra moves but this isn't something to worry about
    // worry about performance only if a profiler tells you to
}

// Member function of some queue class

    /// Peek and pop the front of the queue
    /// Requires the queue is not empty
    T ppop() { 
        queue.pop(); // strong
        return t;
        // Pre C++11, this return would invoke a copy, which may throw
        // if this threw, then we would completely lose the front element since it had already been popped from the queue
        // Post C++11 this invokes a move which is noexcept

        // So for our purposes, this function is strong
    }
</code></pre>
<p>Exception safety shouldn't be an afterthought. We'll return to this topic again later.</p>
<p>Before we move on, how many paths of execution can you find in this code segment? (Answer in next chapter, from Herb Sutter's GOTW and Exceptional C++).</p>
<pre><code class="language-C++">string EvaluateSalaryAndReturnName( Employee e )
{
    if( e.Title() == &quot;CEO&quot; || e.Salary() &gt; 100000 )
    {
      cout &lt;&lt; e.First() &lt;&lt; &quot; &quot; &lt;&lt; e.Last()
           &lt;&lt; &quot; is overpaid&quot; &lt;&lt; endl;
    }
    return e.First() + &quot; &quot; + e.Last();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="exercise-from-last-time"><a class="header" href="#exercise-from-last-time">Exercise From Last Time</a></h3>
<pre><code class="language-C++">string EvaluateSalaryAndReturnName( Employee e )
{
    if( e.Title() == &quot;CEO&quot; || e.Salary() &gt; 100000 )
    {
      cout &lt;&lt; e.First() &lt;&lt; &quot; &quot; &lt;&lt; e.Last()
           &lt;&lt; &quot; is overpaid&quot; &lt;&lt; endl;
    }
    return e.First() + &quot; &quot; + e.Last();
}
</code></pre>
<ol>
<li>title of <code>e</code> is <code>&quot;CEO&quot;</code> and we enter the if</li>
<li>title of <code>e</code> is not <code>&quot;CEO&quot;</code> but salary of e is <code>&gt; 100000</code> and we enter the if</li>
<li>neither of the above is true, and we don't enter the if</li>
</ol>
<p>Now, here's the exceptional paths of execution:</p>
<ol start="4">
<li><code>e</code> is passed by value. Thus, its copy constructor may throw</li>
<li><code>e.Title()</code> may throw</li>
<li><code>e.Salary()</code> may throw</li>
<li><code>==</code> may be an overloaded function and may throw</li>
<li><code>&quot;CEO&quot;</code> might be implicitly converted to whatever is returned by <code>e.Title()</code> (likely a <code>std::string</code>), and the conversion could fail</li>
<li><code>&gt;</code> might be a user-supplied function and throw</li>
<li><code>100000</code> might be implicitly converted to whatever is returned by <code>e.Salary()</code></li>
<li><code>||</code> might also be a user supplied function and throw</li>
<li><code>e.First()</code> may throw, or it may return something that must be implicitly converted to something printable</li>
<li><code>e.Last()</code> has same reasoning as above</li>
<li>Any of the five <code>&lt;&lt;</code> may throw</li>
</ol>
<p>And lastly:</p>
<ol start="19">
<li>In the final return <code>e.First()</code> may throw</li>
<li>In the final return <code>e.Last()</code> may throw</li>
<li><code>&quot; &quot;</code> likely has to converted to string or whatever is returned by <code>e.First()</code> and <code>e.Last()</code>. This conversion can throw.</li>
<li>the first <code>+</code> has to construct a new string which may throw</li>
<li>the second <code>+</code> may also throw for the same reasoning</li>
</ol>
<p>This is from GotW 20 and Exceptional C++. In writing this out right now, I still missed one (the <code>||</code>). 
23! That's a lot for 5 lines of code. If we wanted to be pedantic, we could even count more.</p>
<h1 id="swap"><a class="header" href="#swap">Swap</a></h1>
<p>Consider that you are writing a RAII class. How can we make the following exception safe?</p>
<pre><code class="language-C++">MyString&amp; operator=(const MyString&amp; other) {
    delete[] buffer;
    buffer = new char[other.size()]; //We'll talk about this later
    _size = other._size;
    std::copy(other.buffer, other.buffer + other._size, buffer);
    return *this;
}

~MyString() {
    delete[] buffer;
}
</code></pre>
<p>There's quite a few problems with this. First, what if we self-assign (assign the same object to itself)? 
We'd destroy the memory, then try to copy from the memory we just deleted. 
Of course, we can add a check for self-assignment, but that's what considered a &quot;code smell&quot;, or code that &quot;smells&quot; funny and likely indicates a flaw in the design. 
We can also see that if the allocation fails, the buffer still is deleted; the state of the program still changed!
The failed allocation will not only put the object in a broken state, but the object's destructor will try to delete the memory again! 
A solution could be to assign the buffer to <code>nullptr</code> right after the call to <code>delete[]</code> and check for <code>nullptr</code> in the destructor. 
Furthermore, what if the copy fails? We won't break any invariants, but it would only give us a basic guaranteed copy operator.</p>
<pre><code class="language-C++">// basic guarantee with anti-patterns
MyString&amp; operator=(const MyString&amp; other) {
    if(this == &amp;other) return *this;
    delete[] buffer;
    buffer = nullptr;
    buffer = new char[other.size()];
    _size = other.size;
    std::copy(other.buffer, other.buffer + other._size, buffer);
    return *this;
}

~MyString() {
    if (buffer) { // if buffer is not nullptr
        delete[] buffer;
    }
}
</code></pre>
<p>Applying the above fixes would give us a constructor that satisfies the basic guarantee but can we do better? Yes we can! With the <em>copy-and-swap idiom</em>!</p>
<pre><code class="language-C++">// Not entire class definition
class MyString {
    char * buffer;
    friend void swap(MyString&amp;, MyString&amp;) noexcept;
// note you could define the function right here 
// instead of declaring it and defining it separately
public:
    MyString() : buffer(nullptr) {}

    MyString&amp; operator=(MyString other) {
        // notice other is now passed by-value!

        // make a copy, noexcept swap with the copy
        swap(*this, other);
        return *this;

        // strong
    }
    // Move constructor just for fun
    MyString(MyString&amp;&amp; other) noexcept
        : MyString() // call default constructor to initialize
    {
        swap(*this, other);
    }

    MyString(MyString other) : MyString() {
        swap(*this, other); //same idea as operator=
    }

    ~MyString() {
        if (buffer) {
            delete[] buffer;
        }
    }
}
void swap(MyString&amp; a, MyString&amp; b) noexcept {
    using std::swap;
    
    swap(_size, other._size);
    swap(buffer, other.buffer);
    // just swaps the pointers, cheap
}
</code></pre>
<p>Let's first turn our attention to <code>operator=</code>. 
We are passing by value and letting the compiler do the copy for us via the copy constructor. If you need to copy something, a good optimization is to pass it by value and let the compiler handle it. 
This might not work for every situation, but it works here! Do we have to pass by value? No. We could pass by reference and do the copy ourselves as well.</p>
<p>Now, if the copy fails, we're all good; no state was changed. 
Next we just swap the internals, which we declared noexcept. Therefore, we got our code up to the strong guarantee! 
Like move operations, <code>swap</code> should be <code>noexcept</code>. Beyond the exception reasoning, <code>noexcpet</code> swap and move operations enable them to be used in STL containers like <code>std::vector</code>.</p>
<p>Swap often is implemented either as a nonmember friend function, a member function, or via a template specialization to <code>std::swap</code>. 
The problem with the member function route is that it's not idiomatic: the STL containers won't take advantage of the custom swap function; furthermore swap seems more natural taking two arguments. 
A template specialization of <code>std::swap</code> is viable, but has a few flaws which we'll see later when discussing templates. 
I tend to go the nonmember friend route as that allows users that use <code>swap</code> on our class to take advantage of our <code>swap</code> function instead of the standard implementation. 
The standard implementation isn't too bad: it's implemented in terms of move assignment but will require the introduction of one extra variable to store the intermediate step between the moves. </p>
<p>Now notice the use of <code>using std::swap</code> in our swap function. The point of this is to take advantage of ADL. 
As a reminder, ADL states that if a specific namespace qualification isn't specified for a function,
it will first look in the namesapce of the arguments of that function. 
Thus, the purpose of <code>using std::swap</code> is to provide a fallback on the standard's default implementation if a type does not define a swap function. 
Therefore, unlike most cases where it is a good practice to qualify standard library functions with <code>std::</code>,
it's better to leave swap unqualified and manually bring in <code>std::swap</code> into the smallest scope possible as shown above.</p>
<h3 id="possible-exercises-4"><a class="header" href="#possible-exercises-4">Possible Exercises</a></h3>
<ol>
<li>
<p>A RingBuffer is a fixed size buffer that loops around on itself. If you append an element past the end of the buffer, that element overwrites the first element in the buffer. Can you make a RingBuffer that stores <code>int</code> using <code>new[]</code> and <code>delete[]</code>? 
The class should:</p>
<ul>
<li>Have a constructor taking the size of the RingBuffer to make</li>
<li>Be copyable (strong) and moveable (noexcept)</li>
<li>Overload <code>operator[]</code> to be read only indexable (strong)
<ul>
<li>If an out of bounds index is passed, take the modulo of that index and return the element at that location
<ul>
<li>Throw an error if that location has yet to be set</li>
</ul>
</li>
<li>Note: taking the modulo of a negative number in C++, and many programming languages, results in a negative number</li>
</ul>
</li>
<li>Have a <code>push_back</code> function that will overwrite previous elements as earlier described (strong)</li>
<li>Have a <code>pop_back</code> function which returns the last element and removes it (strong)
<ul>
<li>Copying primitive types cannot fail</li>
</ul>
</li>
<li>Define <code>size()</code> which gets how many valid elements are in the buffer (noexcept)</li>
<li>Have a <code>noexcept</code> nonmember swap</li>
<li>You can augment this interface in any other way you'd like</li>
</ul>
<pre><code class="language-C++">int * buffer = new int[size];
delete[] buffer;
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointers-1"><a class="header" href="#pointers-1">Pointers</a></h1>
<p>I've been skirting around this topic for a bit because I wanted to start with the modern C++ smart pointers, and then mention the C style raw pointers. 
However, I think understanding the smart pointers takes some groundwork, which I think we finally have laid out.</p>
<p>The C++ smart pointers are template types, that is to say they are classes which take template type arguments. Like raw pointers and references, smart pointers enable the class they wrap to behave polymorphically. 
The three smart pointers (<code>unique_ptr</code>, <code>shared_ptr</code>, and <code>weak_ptr</code>) all have slightly different semantics and uses, but taken as a whole they have a few key advantages over &quot;dumb&quot; pointers:</p>
<ol>
<li>Firstly, smart pointers are RAII classes for regular pointers. The smart pointer itself has an automatic lifetime, so when it goes out of scope it handles any resource management it may need to do. 
This is a huge benefit and motivator for smart pointers, and already enough reason to prefer smart pointers to normal pointers.</li>
<li>Smart pointers make the relationship between the pointer and data clear. 
For example, a raw pointer may be something you cannot delete such as an address to data managed by another object or an address of an automatic object like a static or local variable. 
It can also be something you must delete such as a resource the pointer owns. On top of that, for each of these categories, a pointer can be a pointer to a single piece of data or an array. 
And if it does point to an array there's no way of knowing the amount of elements in that array from just the pointer alone. Put simply, without comments or more context, raw pointer are ambiguous.</li>
<li>Smart pointers prevent heap mismatches. On top of remembering to delete the allocated memory, you must remember to match the correct method of deletion to the way it was allocated. 
<code>new</code> pairs with <code>delete</code>, <code>new[]</code> pairs with <code>delete[]</code>, and <code>malloc()</code> or <code>calloc()</code> pairs with <code>free()</code>. 
AND, the component that performed the allocation should be the component to perform the deallocation as well. Let's say you use a library that allocated data with <code>new</code> and gives you back a pointer to that data. 
Although <code>delete</code> is the matching de-allocation function, you shouldn't call it directly! Instead, you should call a delete method provided by the library. 
The reason is that the library may have been built with a different STL implementation that does different housekeeping for resource management, the library allocation may be occurring on a different heap, 
or the library may do house-keeping of its own that assumes you call its own resource cleanup function. 
These are the types of bugs that may not show up for a while and then suddenly rear their head after you make some completely unrelated change.</li>
<li>Less time developing your own RAII. You yourself may need a custom allocator or extra logic for allocations and de-allocations. 
Instead of writing your own RAII, smart pointers provide an out-of-the box and tested solution.</li>
</ol>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>Smart pointers belong in the memory header which is included with <code>#include &lt;memory&gt;</code>.</p>
<p>Smart pointers overload <code>operator*</code> and <code>operator-&gt;</code> in order to be used similarly to a raw pointer. 
As a reminder, <code>operator*</code> is the dereference operator and it returns a reference to the underlying data. <code>operator-&gt;</code> is like the dot operator, but for pointers. 
It gets members that belong to the underlying data. <code>operator-&gt;</code> is repeatedly applied until it gets to an object that does not overload it. 
So calling <code>operator-&gt;</code> on the smart pointer gets you right at the member functions of the internal pointer instead of having to do something like <code>-&gt;-&gt;</code>. 
In truth, <code>operator-&gt;</code> is implemented the same way as <code>operator*</code> (by returning a reference to the underlying data), however they differ semantically.</p>
<p>Smart pointers also are comparable with <code>nullptr</code> and convertible to <code>bool</code>. A smart pointer that evaluates to <code>true</code> has non-null data while one that evaluates to <code>false</code> is essentially a <code>nullptr</code>.</p>
<pre><code class="language-C++">struct MyStruct {
    int a, b, c;
};

std::unique_ptr&lt;MyStruct&gt; structPtr = new MyStruct(10, 20, 30);
structPtr-&gt;a; //10
structPtr-&gt;b = 50;
MyStruct cpy = *structPtr;
cpy.b; // 50
</code></pre>
<h3 id="const-smart-pointers"><a class="header" href="#const-smart-pointers">Const Smart Pointers</a></h3>
<p>Declaring the smart pointer itself <code>const</code> prevents changing the data the smart pointer points to, but does not make the data itself <code>const</code>. 
This is akin to putting <code>const</code> after the <code>*</code> for a normal pointer declaration.
To make the data constant, the template argument to the smart pointer must be <code>const</code>.</p>
<pre><code class="language-C++">const std::unique_ptr&lt;int&gt; ptr = new int(5);
*ptr = 20; // good
ptr = nullptr; //error

std::unique_ptr&lt;const int&gt; ptr2 = new int(10);
*ptr2 = 20; //error
ptr2 = nullptr; // good
</code></pre>
<h3 id="make-functions"><a class="header" href="#make-functions">Make Functions</a></h3>
<p>As I've shown, the constructor for a smart pointer takes a raw pointer to take ownership of.
Now, the evaluation order of function arguments are unspecified. This is to allow,
the compiler to perform optimizations it otherwise wouldn't be allowed to do.
So consider the following:</p>
<pre><code class="language-C++">void foo(std::unique_ptr&lt;X&gt; &amp;&amp; x, std::unique_ptr&lt;Y&gt; &amp;&amp; y) {}

foo(std::unique_ptr(new X()), std::unique_ptr(new Y());
</code></pre>
<p>We can think of <code>new</code> as performing two operations. Allocating memory, and calling the constructor.
So one possible execution order is the following:</p>
<ol>
<li>Allocate memory for <code>X</code></li>
<li>Construct an <code>X</code></li>
<li>Allocate memory for <code>Y</code></li>
<li>Construct a <code>Y</code></li>
<li>Construct a smart pointer of <code>Y</code></li>
<li>Construct a smart pointer of <code>X</code></li>
<li>Call <code>foo</code></li>
</ol>
<p>What if the constructor to <code>Y</code> throws in step 4? Memory for <code>X</code> is already allocated!
Now we can have a memory leak!</p>
<p>Another downside is we are stuck manually matching the correct allocation function with deletion function.</p>
<p>To solve this, the C++ library has <code>std::make_unique</code> and <code>std::make_shared</code> template functions to help us. 
Whatever you pass as arguments to these functions are <em>forwarded</em> (more on this later) to the constructor of the object you are wrapping in a smart pointer. 
Like smart pointers themselves, these functions are templated on the type that they are creating a smart pointer of.</p>
<p>Using make functions, the allocation, construction, and adoption by a smart pointer steps occur in a single step. This prevents the
unspecified evaluation order memory leak.</p>
<pre><code class="language-C++">auto smartPtr = std::make_unique&lt;int&gt;(100);
*smartPtr; // 100

auto shared = std::make_shared&lt;MyStruct&gt;(20, 30, -10);
shared-&gt;c; // -10
</code></pre>
<hr />
<blockquote>
<p>&quot;If debugging is the process of removing software bugs, then programming must be the process of putting them in.&quot;</p>
<p>- Edsger Dijkstra</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unique-pointers"><a class="header" href="#unique-pointers">Unique Pointers</a></h1>
<p>Unique pointers, and really anything else that's &quot;unique&quot; in C++, model exclusive ownership. 
They offer practically no space or time overhead as compared to raw pointers. Because they model exclusive ownership, they cannot be copied, only moved. 
Here's a bad, quick, and dirty example of how something like this might be implemented.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
class BadUniquePtr {
    T * data;

    void freeData() {
        if (data) {
            delete data;
            data = nullptr;
        }
    }
public:
    BadUniquePtr(T * owningPtr) : data(owningPtr) {}
    BadUniquePtr() : data(nullptr) {}

    BadUniquePtr(const BadUniquePtr &amp;) = delete;
    BadUniquePtr&amp; operator=(const BadUniquePtr &amp;) = delete;

    BadUniquePtr(BadUniquePtr &amp;&amp; other) : BadUniquePtr() {
        swap(data, other.data);
    }

    BadUniquePtr&amp; operator=(BadUniquePtr &amp;&amp; other) {
       freeData();
       swap(data, other.data);
    }

    ~BadUniquePtr() {
        freeData();
    }
}
</code></pre>
<p><code>std::unique_ptr</code> is a template, and so when you instantiate it with a type it replaces every template argument (<code>T</code> in <code>BadUniquePtr</code>) with whatever type you are instantiating it with.</p>
<p><code>std::unique_ptr</code> provides the <code>reset()</code> member function to manually free the data or swap the internal pointer with a different one. 
If we need to, we can get access to the internal pointer with <code>get()</code> or <code>release()</code>. The latter returns the pointer and releases it from the <code>unique_ptr</code>s management. 
We can also swap the owning data between two <code>unique_ptr</code>s with the <code>swap()</code> <strong>member function</strong>. <code>std::unique_ptr</code> also provide <code>operator*</code> and <code>operator-&gt;</code> so they can be de-referenced just like raw pointers.</p>
<pre><code class="language-C++">auto unique = std::make_unique&lt;double&gt;(6.28);
double* ptr = unique.get(); // the unique ptr is a class itself
// to access the unique_ptrs members use the dot operator
// to access the underlying data's members use -&gt;

//ptr is not an owning pointer

auto u2 = std::make_unique&lt;double&gt;(3.14);
unique.swap(u2);
// Smart pointers must be pointers to the same type to swap

double* owningPtr = u2.release();
// u2 no longer manages the data

unique.reset(); // free data and set to nullptr
// which is the same as
unique = nullptr;

auto u3 = std::make_unique&lt;double&gt;(2.67);

unique = u3; // error, cannot copy
unique = owningPtr; // takes ownership of pointer

unique.reset(new double(-1.12)); // free data and take ownership of new raw ptr


// ---

auto getPtr() {
    return std::make_ptr&lt;long long&gt;(19474579);
    // move (Pre C++17), good
}

auto u4 = getPtr(); // move ctor, good
auto u5 = std::move(u4); // move ctor, good

u4 = std::move(u5); // move assignment, good
</code></pre>
<p>Smart pointers can store arrays as well. 
They handle calling the correct delete too. A smart pointer wrapped around an array overloads <code>operator[]</code> to provide index access. 
While this is slightly better than unmanaged arrays, an <code>std::vector</code> would be better because the smart pointer still does not store the size of the array.</p>
<p>A pointer of an array is a pointer to the first element in the array since arrays are stored contiguously in memory. 
A C string is a <code>char *</code> (or <code>const char *</code>) that is an array of characters with the last one being the null terminator ('\0' which is 0).</p>
<pre><code class="language-C++">std::unique_ptr&lt;char[]&gt; string = std::make_unique&lt;char[]&gt;(100);
// 100 length char array
string[0] = 'h';
string[1] = 'i';
string[2] = '\0';
*string; // 'h'
// pointer is to the first element of the array

const char * cStr = string.get();

std::cout &lt;&lt; cStr; // &quot;hi&quot;
</code></pre>
<h1 id="deleters"><a class="header" href="#deleters">Deleters</a></h1>
<p>This is all well and good if we want to use C++'s <code>delete</code> or <code>delete[]</code>. But what if we have a custom allocator or want to use C style allocation. 
Well luckily, smart pointers abstract away how they delete the data and delegate that responsibility to a deleter. 
The default deleter uses <code>delete</code> or <code>delete[]</code> depending on the type it wraps (<code>delete</code> for <code>T</code>, <code>delete[]</code> for <code>T[]</code>). The actual definition of <code>std::unique_ptr</code> is</p>
<pre><code class="language-C++">template&lt;typename T, typename Deleter = std::default_delete&lt;T&gt;&gt;
class unique_ptr // ..
</code></pre>
<p>In reality there is a second template argument! This type should be the type of a callable object that overloads <code>operator()</code> to accept a pointer to the underlying data. 
<code>operator()</code> would then be responsible for performing the logic to cleanup the passed pointer. 
With a custom deleter, we cannot use <code>std::make_unique</code> because this function abstracts away the usage of the default deleter's matching allocation functions. 
Thus, we must use the <code>unique_ptr</code> constructor, passing a pointer as the first argument and an instance of the deleter type as the second.</p>
<pre><code class="language-C++">struct Foo {
    int num;

    Foo() : num(0) {}
}

struct FooDeleter {
    void operator()(Foo * ptr) {
        ptr-&gt;~Foo();
        free(ptr);
    }
}

Foo * makeFoo() {
    const auto mem = malloc(sizeof(Foo));
    return 
        new (mem) Foo(); // placement new, calls constructor and constructs object
        // in already allocated memory
        // once again, more on this later

}

std::unique_ptr&lt;Foo, FooDeleter&gt; fooPtr(makeFoo(), FooDeleter());
// use fooPtr like normal

fooPtr-&gt;num = 100;
</code></pre>
<p>Now this seems like a bit of boilerplate just for two function calls. Well, we'll explain the following soon enough, but here's some other ways of doing the same thing:</p>
<pre><code class="language-C++">
void freeFoo(Foo * ptr) {
    ptr-&gt;~Foo();
    free(ptr);
}

std::unique_ptr&lt;Foo, std::function&lt;void(Foo*)&gt;&gt; fp2(makeFoo(), [](Foo * ptr) {
    ptr-&gt;~Foo();
    free(ptr);
});

// Use a lambda as the callable object
// passes a Foo* and returns void

std::unique_ptr&lt;Foo, void(*)(Foo*)&gt; fp3(makeFoo(), &amp;freeFoo);
// function pointer is the deleter, pass free directly
// pointer to a function that takes a void* and returns void

std::unique_ptr&lt;Foo, decltype(&amp;freeFoo)&gt; fp4(makeFoo(), &amp;freeFoo); 
// same as fp3, just slightly easier since function pointer syntax is a pain

std::unique_ptr&lt;Foo, std::function&lt;void(Foo*)&gt;&gt; fp5(makeFoo(), &amp;freeFoo);
// same as fp3 and fp4 but instead use a generalized function as the type
</code></pre>
<p>Here's another example of a custom deleter that adds some housekeeping to the standard C++ allocation.</p>
<pre><code class="language-C++">// There's a few issues with this, but this is mainly to demonstrate deleters
/// Invariant: contains pointers to active allocations or nullptr to indicate freed memory
std::vector&lt;Bar*&gt; allocations;

auto makeBar() { // strong
    allocations.push_back(nullptr); //may reallocate and move entire vector (more on this later), strong
    auto ptr = new Bar();
    const auto idx = allocations.size() - 1; // no throw
    allocations[idx] = ptr; //copying pointer cannot throw
    const auto deleter = [idx, &amp;allocations](Bar * del) {
        delete del;
        allocations[idx] = nullptr;
    }; // noexcept (construction of lambda and deleter itself)
    return std::unique_ptr&lt;Bar, std::function&lt;void(Bar*)&gt;&gt;(ptr, deleter); //noexcept
}

auto barPtr = makeBar();
</code></pre>
<p>By the way, deleters work the same for <code>shared_ptr</code> too</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-pointers"><a class="header" href="#shared-pointers">Shared Pointers</a></h1>
<p>While unique pointers model exclusive ownership, shared pointers model shared ownership. </p>
<p>The shared pointer uses reference counting to keep track of the amount of other pointers referencing a piece of data. 
During the constructor, the reference count is incremented and during destruction the count is decremented. 
When that reference count goes to 0, the data is cleaned up. 
Because of this reference counting ability, shared pointers do have an added space and time overhead. 
Unlike a unique pointer, a shared pointer doesn't hold a pointer directly to the data but instead has a pointer to a control block containing the underlying pointer and meta-data such as the reference count. 
Furthermore, the shared pointer's reference counting logic is atomic and thread safe. 
This does not mean it synchronizes accesses to the data, but it does guarantee that only one thread will ever attempt to free the data. 
So you should not mutate the pointer or its underlying data from multiple threads without synchronization, but there's no need to synchronize the creation or deletion of shared pointers 
since the reference counting is atomic. 
The atomicity of the reference counting operation also incurs some extra overhead since atomic instructions are typically more expensive than non-atomic ones. </p>
<p>Unlike unique pointers. Shared pointers are copyable. 
During a copy the pointer to the control block is copied and the reference count in this control block is incremented. 
The old data's reference count is also decremented.</p>
<p>Shared pointers have an interface that's extremely similar to unique pointers but with some differences. 
You can use the <code>use_count()</code> member function to get the current data's reference count. 
Since a shared pointer models shared ownership, there is no <code>release()</code> member function since this could free data out from under other shared pointer instances. 
Finally, we can move a <code>unique_ptr</code> into a <code>shared_ptr</code> via its constructor to start shared management of exclusively owned data. 
This makes <code>unique_ptr</code> great for factory functions since it's easily convertible to any type of pointer you may want to use.</p>
<pre><code class="language-C++">auto ptr = std::make_shared&lt;int&gt;(20);
auto ptr2 = ptr; // copy, increment reference count
*ptr2 = 50;
*ptr; //50

ptr.use_count(); //2

std::vector&lt;std::shared_ptr&lt;Foo&gt;&gt; foos;

{
    auto p = std::make_shared&lt;Foo&gt;();
    // use p
    foos.push_back(p);
    // p goes out of scope here
    // no problem though because we copied the pointer and incremented the reference count
    // so the data in the vector remains valid
}

std::shared_ptr&lt;Bar&gt; barShared = std::make_unique&lt;Bar&gt;();
// upgrade from unique_ptr
auto b2 = barShared; // copy ctor
</code></pre>
<h1 id="weak-pointers"><a class="header" href="#weak-pointers">Weak Pointers</a></h1>
<p>Consider this linked list implementation</p>
<pre><code class="language-C++">class LinkedList {
    struct Node {
        std::shared_ptr&lt;Node&gt; next, prev;
        int data;

        Node(int data, std::shared_ptr&lt;Node&gt; prev = nullptr) : 
            next(nullptr), prev(prev), data(data) {}
    }
    std::shared_ptr&lt;Node&gt; root;
public:
    /// ...
}
</code></pre>
<p>When creating recursive data types, we must use pointers otherwise the data type would have infinite size. 
But there's a problem with the implementation above. When we try to delete a node, we'll find that there's another reference to it via the next node's <code>prev</code> pointer. 
Therefore, the reference count will drop from 2 to 1, and the memory will not be freed. When we go to delete the next node, 
we'll find there's an existing reference in the previous node's <code>next</code> pointer since the previous node was not freed yet. Once again the reference count will not drop to 0.</p>
<p>This means that we cannot use <code>shared_ptr</code> in cyclic situations like the one above! 
This would create a memory leak. If we'd like to retain copy semantics, we can't use a <code>unique_ptr</code> so that leaves us with a <code>weak_ptr</code>.</p>
<p>A <code>weak_ptr</code> holds a non-owning reference to data managed by a <code>shared_ptr</code>. 
The difference is that during copy of a <code>shared_ptr</code>, the reference count is incremented while operations of <code>weak_ptr</code> do not touch the reference count at all. 
This means that <code>weak_ptr</code> may dangle! The last <code>shared_ptr</code> may go out of scope, destroying the underlying data while a <code>weak_ptr</code> is still active!</p>
<p>This isn't a problem however because a <code>weak_ptr</code> cannot access the underlying data directly. 
Instead, it must use the member <code>lock()</code> which will return a <code>shared_ptr</code> to the underlying data if it still is valid, or a default constructed <code>shared_ptr</code> for the underlying data if it isn't. 
Like a <code>shared_ptr</code>, you can also check the amount of active owning references with <code>use_count()</code> and you can also check if the underlying data is still valid with the <code>expired()</code> member function. 
Finally, you can pass a reference to a <code>shared_ptr</code> to the <code>weak_ptr</code> constructor.</p>
<pre><code class="language-C++">std::vector&lt;std::weak_ptr&lt;Foo&gt;&gt; foos;

{
    auto fPtr = std::make_shared&lt;Foo&gt;();
    std::weak_ptr fRef = fPtr;
    fPtr.use_count(); // 1
    fRef.expired(); // false;

    auto fPtr2 = fRef.lock();
    fPtr.use_count(); // 2
    auto fRef2 = fRef; // copy
    fPtr2.use_count(); // 2
    foos.push_back(fRef2);
} // data goes out of scope here

foos[0].expired(); // true

</code></pre>
<p>Using a <code>weak_ptr</code>, we can break cyclic references of <code>shared_ptr</code> and easily model non-owning references.</p>
<pre><code class="language-C++">auto personFactory(std::string &amp;&amp; name, int age) {
    return std::make_unique&lt;Person&gt;(std::move(name), age);
    // unique_ptr is great for factory functions
}
std::vector&lt;std::shared_ptr&lt;Person&gt;&gt; people;
std::vector&lt;std::weak_ptr&lt;Person&gt;&gt; pplRefs;

{
    std::shared_ptr&lt;Person&gt; ps = 
        personFactory(&quot;Bill&quot;, -1);
    // unique_ptr rvalue can be converted into a shared_ptr
    // this is because rvalues are temporaries and the
    // unique_ptr is being destroyed.
    // Since unique_ptrs model exclusive ownership, take means
    // it's safe to change the ownership model of the data

    people.push_back(ps);
    // ps can be copied and the internal data will 
    // persist past the scope

    pplRefs.emplace_back(ps);
    // shared pointers can be converted to weak ptrs
}

//after ps has gone out of scope
//use of the -&gt; scope resolution operator to get access 
// to the object's functions
people[0]-&gt;getName();
//still works, data still persists

// use of . scope resolution operator to use methods of 
// the smart pointer itself
if(!pplRef[0].expired()){
    // check if data is destroyed or not
    std::shared_ptr&lt;Person&gt; person = pplRefs[0].lock();
}

//later...

throw std::runtime_error(&quot;Something bad&quot;);

// all smart pointers are cleaned up properly
</code></pre>
<h3 id="possible-exercises-5"><a class="header" href="#possible-exercises-5">Possible Exercises</a></h3>
<ol>
<li>
<p>Create a doubly linked list of integers (or a template if you desire) using only smart pointers with the following interface</p>
<ul>
<li><code>push_back</code>, <code>push_front</code>, <code>pop_front</code>, and <code>pop_back</code> in <code>O(1)</code> time with the strong guarantee</li>
<li><code>size()</code> member function in <code>O(1)</code> with no throw guarantee</li>
<li><code>empty()</code> convenience function in <code>O(1)</code> that's <code>noexcept</code></li>
<li><code>find()</code> - may return a <code>bool</code> or an index. If you go for an index, you may use <code>-1</code> to indicate it doesn't exist in the list or you may return an <code>std::optional</code>. Strong</li>
<li><code>erase()</code> - may take a value or index. Should do nothing if the element doesn't exist. Strong</li>
</ul>
</li>
<li>
<p>Create a reference counted pointer RAII class that is non-atomic. The implementation should match <code>std::shared_ptr</code> (the points we talked about, you don't have to make every single constructor, overload, or non member). <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">cppreference</a> may help.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h1>
<p>Function pointers allow us to pass functions as values. We'll discuss this a lot more later but I did want to introduce the topic here.</p>
<p>Functions are static data. So <strong>do not</strong> free them. 
All function pointers essentially represent non owning references. Function pointers behave like normal pointers, but you can also apply <code>operator()</code> to call them like a normal function.</p>
<p>The syntax for a function pointer is as follows: <code>&lt;return type&gt;(*[optional name])(&lt;comma separated list of argument types&gt;)</code>.</p>
<pre><code class="language-C++">int add(int a, int b) {
    return a + b;
}

int sub(int a, int b) {
    return a - b;
}

auto elementWiseOp(int(* func)(int, int), const std::vector&lt;int&gt; &amp; a, const std::vector&lt;int&gt; &amp; b) {
    std::vector&lt;int&gt; result;
    if (a.size() != b.size())
        return std::invalid_argument(&quot;Element wise operations must be performed on equal sized vectors&quot;);
    result.reserve(a.size()); //allocate memory but don't initialize it
    std::transform(a.begin(), a.end(), b.begin(), std::back_inserter(result), func);
    // iterates over a and b together calling `func` with an element from each
    // taking the result of `func` and inserting it into the back of `result`
    return result;
}

int(* addPtr)(int, int) = &amp;add;
addPtr(5, 3); // add

using arit_func_t = int(*)(int, int); // type alias

arith_func_t addPtr2 = &amp;add;

std::vector vecA = {10, 20, 30, 40, 50};
std::vector vecB = {1, 2, 3, 4, 5};

auto aSubB = elementWiseOp(&amp;sub, vecA, vecB);
auto bSubA = elementWiseOp(&amp;sub, vecB, vecA);
auto aPlusB = elementWiseOp(addPtr2, vecA, vecB);
</code></pre>
<p>Function pointers aren't as powerful as the modern <code>std::function</code>, which can use ANY callable object.
I showed a bunch of things I haven't discussed yet, so we'll talk about that later.</p>
<p>Finally, function pointers to methods are a little different. 
We need to encode the method's owning class in the type of the pointer and pass an instance of that class to the function pointer via dot syntax when calling it.</p>
<pre><code class="language-C++">class Foo {
    int doA(bool sw, int flag) {
        if (sw) return flag;
        else return flag * 100;
    }

    static int doB(int a, int b) {
        return a * b - a;
    }
}

int(Foo::* fooMethodPtr)(bool, int) = &amp;Foo::doA;
// need the Foo:: to encode that the function pointer points to a method
// getting the address also needs the Foo:: since an unqualified doA would be a free function


Foo f;

(f.(*fooMethodPtr))(true, 10); // 10
// we must dereference fooMethodPtr and get the instance's version of the method
// we need parenthesis around the f.(*fooMethodPtr) as well so we apply the instance method and not
// the function pointer



// static method function pointers are basically the same as free function pointers

int(* myFunc)(int, int) = &amp;Foo::doB;

myFunc(1, 2); // 1
</code></pre>
<p>Again, prefer <code>std::function</code> to dealing with function pointers directly.</p>
<h1 id="raw-pointers"><a class="header" href="#raw-pointers">Raw Pointers</a></h1>
<p>Prefer smart pointers, <code>std::vector</code>s, <code>std::array</code>s, and other modern C++ features. 
With raw pointers, you must ensure to match the corresponding de-allocation function with the allocation function used to allocate the memory.</p>
<pre><code class="language-C++">
struct Bar {
    int a, b, c;

    Bar(int a, int b, int c) : a(a), b(b), c(c) {}
}

Bar * bar = new Bar(20, 30, 40);
// arguments after new are arguments to constructor

bar-&gt;a;
delete bar;


Bar ** bars = new Bar[30];
// amount of elements passed in to new[]
// allocates an array of pointers

for(int i = 0; i &lt; 30; ++i) {
    bars[i] = new Bar(i, 2 * i, 3 * i);
    // allocate elements
}

// later

for (int i = 0; i &lt; 30; ++i) {
    delete bars[i]; //delete elements
}

delete[] bars; // delete array



Bar bc(10, 10, 10);
Bar * bar2 = &amp;bc;
// ref, do not delete
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pimpl"><a class="header" href="#pimpl">PIMPL</a></h1>
<p>PIMPL stands for pointer to implementation and is also known as a compiler firewall. Consider the following header file:</p>
<pre><code class="language-C++">#include &lt;ie_core.hpp&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace InferenceEngine;
class NeuralNetwork {
    Core ieCore;
    ExecutableNeuralNetwork net;
    std::string modelPath;
public:
    SemanticSegmentationNetwork(const char * model, const char * device = &quot;CPU&quot;);
    std::vector&lt;float&gt; infer(const std::vector&lt;float&gt; &amp; input);
};
</code></pre>
<p>Firstly, every client of this code is going to end up including <code>string</code>, <code>vector</code> and OpenVino's <code>ie_core.h</code>. 
Since <code>std::string</code> and <code>std::vector</code> are part of the standard library, they're not really an issue. 
But clients shouldn't know or care about the implementation of <code>NeuralNetwork</code> and they shouldn't need to depend on the <code>ie_core.hpp</code> header file since they never directly use it. 
However, the above implementation will include headers from OpenVino for anything that uses a <code>NeuralNetwork</code>. 
Now, if we decide to update our version of OpenVino and there is a change to <code>ie_core.hpp</code> (which may also include other header files) we'll have to recompile everything that uses the <code>NeuralNetwork</code> 
interface even though the changes to the library only affect the implementation of <code>NeuralNetwork</code>.</p>
<p>We can ameliorate some of these issues by forward declaring the OpenVino classes we use. 
Instantiating a template or an object of a class requires that class's definition. 
But declaring the signature of functions that accept/return a forward declared type (known as an incomplete type) or declaring (but not initializing) variables of a forward declared type is legal.</p>
<pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;string&gt;
// no include for ie_core.h
namespace InferenceEngine {
    class Core;
    class ExecutableNeuralNetwork;
}

class NeuralNetwork {
    InferenceEngine::Core ieCore;
    InferenceEngine::ExecutableNeuralNetwork net;
    std::string modelPath;
    class MyClass myClass; // can forward declare type and declare member in one line too
public:
    SemanticSegmentationNetwork(const char * model, const char * device = &quot;CPU&quot;);
    ~SemanticSegmentationNetwork();
    std::vector&lt;float&gt; infer(const std::vector&lt;float&gt; &amp; input);

};
</code></pre>
<p>With this method, we no longer are able to define the default constructors and destructors in the header file. 
This is because at the time the class is defined, <code>Core</code> and <code>ExecutableNeuralNetwork</code> don't have definitions. 
So the compiler has no idea how exactly to destroy or create these members. 
Instead, we must declare the destructor in the header file, and define it separately in the source file after the compiler has definitions for all the class's members.</p>
<p>This is an improvement, but clients still have visibility of <code>NeuralNetwork</code>'s internals. 
While access modifiers prevent client code from using internal members, it can do nothing to stop clients from knowing it exists. 
Private members participate in name lookup even if they are encapsulated away. 
Furthermore, a client using this class that comes to the header file to read documentation is fully exposed to all private and protected data members. 
They could also see any implementor comments that correspond to internal members.</p>
<p>We can create a compiler firewall and improve encapsulation with the pimpl idiom (<strong>p</strong>ointer to <strong>impl</strong>ementation).</p>
<p>In the header file:</p>
<pre><code class="language-C++">#include &lt;memory&gt;
#include &lt;vector&gt;
class NeuralNetwork {
    struct Impl; // declaration for Impl
    std::unique_ptr&lt;Impl&gt; pimpl;
public:
    NeuralNetwork(const char * model, const char * device = &quot;CPU&quot;);
    ~NeuralNetwork();
    std::vector&lt;float&gt; infer(const std::vector&lt;float&gt; &amp; input);

    // forward declaration in function
    class MyClass doIt(const class MyClass &amp; cl);
};
</code></pre>
<p>In the source file:</p>
<pre><code class="language-C++">#include &quot;NeuralNetwork.h&quot;
#include &lt;string&gt;
#include &lt;ie_core.hpp&gt;
using namespace InferenceEngine;
class MyClass {}

struct NeuralNetwork::Impl {
    Core core;
    ExecutableNeuralNetwork net;
    std::string modelPath;
    MyClass m

    Impl(const char * path) : modelPath(path) {}
};

NeuralNetwork::NeuralNetwork(const char * model, const char * device) : pimpl(std::make_unique&lt;Impl&gt;(model)) {}
// Note: do not redefine default arguments

~NeuralNetwork::NeuralNetwork() = default;
// need to define the dtor after we create a definition for Impl
// since the compiler needs to know how to destroy it

std::vector&lt;float&gt; NeuralNetwork::infer(const std::vector&lt;float&gt; &amp; input) {
    // ...
}

MyClass NeuralNetwork::doIt(const MyClass &amp;) {
    //..
}
</code></pre>
<p>C has &quot;true&quot; encapsulation.
Foo.h</p>
<pre><code class="language-C">
struct Foo * foo_make();

int foo_getSomething(struct Foo *);

void foo_doSomething(struct Foo *, int);

void foo_free(Foo *);
</code></pre>
<p>Foo.c</p>
<pre><code class="language-C++">struct Foo {
    int bar;
};

struct Foo * foo_make() {
    Foo * ptr = (Foo*)malloc(sizeof(Foo));
    ptr-&gt;bar = 0;
    return ptr;
}

int foo_getSomething(struct Foo * foo) {
    return foo-&gt;bar;
}

void foo_doSomething(struct Foo * foo, int a) {
    foo-&gt;bar = a;
}

void foo_free(Foo * ptr) {
    free(ptr);
}
</code></pre>
<p>The internals of <code>Foo</code> are <strong>completely</strong> encapsulated away. 
A client has no idea what <code>Foo</code> is, they just see they can make and free it, along with <code>doSomething</code> and <code>getSomething</code>. 
A client is protected from whatever header files <code>Foo</code> needs because the implementation is isolated in its own file.</p>
<p>C++ classes cannot do this because a compiler needs to know their size. 
Pimpl gives us a way to achieve this by making the actual class relatively small and just contain a pointer to a struct that contains all the internal members.</p>
<p>Of course, pimpl does incur the cost of the indirection and the heap allocation, and probably isn't necessary in every class you develop. 
However, with that being said, it's a great idiom to provide increased encapsulation and isolation. 
Private member variables and functions could be left out of the header file, leaving the header easy to read for clients to get information on the public interface of the class.</p>
<h1 id="smart-pointer-polymorphism"><a class="header" href="#smart-pointer-polymorphism">Smart Pointer Polymorphism</a></h1>
<p>It works like they were regular pointers or references. However, covariant return types only work with pointers and references. 
Furthermore, <code>std::unique_ptr&lt;T&gt;</code> and <code>std::unique_ptr&lt;const T&gt;</code> are two completely different instantiations of the template class and therefore not implicitly convertible. 
On top of that, while the type <code>D</code> may subtype <code>B</code>, it is <strong>not</strong> true that <code>smart_ptr&lt;D&gt;</code> subtypes <code>smart_ptr&lt;B&gt;</code> 
even though certain function such as constructors permit using a smart pointer or regular pointer to a derived type.</p>
<pre><code class="language-C++">class Base {
public:
    virtual std::unique_ptr&lt;Base&gt; clone() = 0;
    virtual int getInt() const = 0;
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    std::unique_ptr&lt;Base&gt; clone() override {
        return std::make_unique&lt;Derived&gt;();
    }

    int getInt() const override {
        return 10;
    }
};

std::unique_ptr&lt;Base&gt; useBase(std::unique_ptr&lt;Base&gt; &amp;&amp; b) {
    std::cout &lt;&lt; b-&gt;getInt() &lt;&lt; std::endl;
    return b;
}

std::unique_ptr&lt;Base&gt; obj = std::make_unique&lt;Derived&gt;();

obj = useBase(std::move(obj));
</code></pre>
<p>The only part of a smart pointer that can act polymorphically is its constructor, assignment operator, and swap member function. So if type <code>D</code> subtypes <code>B</code>, 
we can construct a <code>smart_ptr&lt;B&gt;</code> from a <code>smart_ptr&lt;D&gt;</code> or <code>D*</code>.</p>
<pre><code class="language-C++">void funcA(std::unique_ptr&lt;B&gt; &amp;) {}
void funcB(std::unique_ptr&lt;B&gt; &amp;&amp;) {}

void funcC(std::unique_ptr&lt;const D&gt; &amp;) {}

auto d_ptr = std::make_unique&lt;D&gt;();

funcA(d_ptr); // error!, std::unique_ptr&lt;D&gt; is not a subtype of std::unique_ptr&lt;B&gt;
funcB(std::move(d_ptr)); // fine, constructs a std::unique_ptr&lt;B&gt; from std::unique_ptr&lt;D&gt;
// since D subtypes B

funcC(d_ptr); // error! std::unique_ptr&lt;D&gt; is not std::unique_ptr&lt;const D&gt;
</code></pre>
<p>For polymorphic function arguments, it's best to just accept references. This allows automatic variables, smart pointers, and raw pointers to use the function. 
It also allows implicit conversion to <code>const</code>.</p>
<pre><code class="language-C++">void funcD(const B &amp;) {}

auto d_ptr2 = std::make_unique&lt;D&gt;();

funcD(*d_ptr2); // good
// D&amp; is convertible to const B &amp;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-wrappers"><a class="header" href="#reference-wrappers">Reference Wrappers</a></h1>
<p>Earlier I alluded to some limitations of pure C++ references: they must always be initialized, most containers cannot hold 
references, and references cannot be rebound.</p>
<p>Here's an example:</p>
<pre><code class="language-C++">class MyList::iterator {
private:
    MyList&amp; parent;
    // we must either set the value of a reference when its declared
    // or set the reference in a constructor initializer list (done below)
    //  if the reference is a class member

    size_t index;
public:
    iterator(MyList&amp; owner, size_t idx) : parent(owner), index(idx) {}

    iterator&amp; operator=(const iterator&amp; other) {
        // ...
    }
};

// ...

    MyList a = //...
    MyList b = //...

    MyList::iterator it = a.begin();
    it = b.begin();

</code></pre>
<p>References must either be assigned a value when they are declared or, in the case of references as class members, they
can also be initialized in a constructor initializer list.</p>
<p>Now an iterator is something you'd expect to be able to be copied. But reference members (along with <code>const</code> members) prevent the use of compiler generated copy operations. To see why, try to come up with a way to define <code>operator=</code> that makes sense.</p>
<p>You might first think to define it like so:</p>
<pre><code class="language-C++">iterator&amp; operator=(const iterator&amp; other) {
    index = other.index;
    parent = other.parent;
    return *this;
}
</code></pre>
<p>But now, what happens when we assign <code>it = b.begin()</code>? Well, we actually change the data of <code>a</code> to be that of <code>b</code>
through the line <code>parent = other.parent</code>.
So instead of copying iterators, we ended up copying the entire list and overwriting <code>a</code>'s data.</p>
<p>So references cannot be copied. This is one of the reasons (along with the inability to have pointers to references) that 
containers can't store references.</p>
<p>This doesn't mean that if we need references with value semantics that we are forced to use old-style pointers. We can use <code>reference_wrapper</code>.</p>
<p>A <code>reference_wrapper</code> acts like a non-owning pointer. It can be rebound and copied. It's interface is quite simple, 
you can use the <code>get()</code> member method to get a reference to the data it wraps, 
and if it holds a reference to a callable object, you can invoke <code>operator()</code> on the <code>reference_wrapper</code> directly.
A <code>reference_wrapper</code>, like a smart pointer is actually a template class where its template type is the type of the
reference it holds.</p>
<pre><code class="language-C++">int n = 5;
std::reference_wrapper n_ref = n;
// same as: 
// std::reference_wrapper&lt;int&gt; n_ref(n);

int n2 = 10;
auto n2_ref = std::ref(n2); 
// convenience function for creating reference wrappers

n_ref = n2_ref;
n_ref.get() = 20;
// n is still 5
// n2 is now 20
n2_ref.get(); // 20


auto foo(int x) {
    return 5 * x;
}

auto foo_ref = std::ref(foo);
foo_ref(10); // 50
</code></pre>
<p>As seen in these examples, instead of calling the constructor directly, its more common to use the <code>std::ref</code> function
to create a <code>reference_wrapper</code>. This function is a template too, but the compiler can easily deduce the 
template type parameter based on the type of the argument we pass to it.</p>
<p>As a quick aside, I want to mention the type of <code>foo_ref</code>; it's <code>std::reference_wrapper&lt;int(int)&gt;</code>.
The <code>int(int)</code> is the type of a function that returns an <code>int</code> and has one integer argument. You may recall
that the type of a function pointer to such a function would be the same thing with an added &quot;<code>(*)</code>&quot;: <code>int(*)(int)</code>.
This is very much like every other type, however for functions we need the parentheses around the asterisk so we know
that it's a function pointer and not a function returning an <code>int *</code>. So then <code>void()</code> would be the type of a function
that has no arguments and no return value, and <code>std::string(const char *, const std::vector&lt;char&gt;&amp;)</code> would be the type
of a function that returns a string and takes a <code>const char *</code> and reference to a vector of characters.</p>
<p>Returning back to <code>reference_wrapper</code>: let's say, in the spirit of const correctness, that we don't want to change
the data the reference refers to and so we want to make the reference wrapper <code>const</code>. The first attempt at this might
be to just add <code>const</code> to the type declaration like a normal reference.</p>
<pre><code class="language-C++">const auto n = 10;
const auto m = 20;
const auto r = std::ref(n);

r = std::ref(m); //compiler error!

r.get() = 50; // and this still works!
</code></pre>
<p>But when we do that, we're making the <code>reference_wrapper</code> itself be <code>const</code>, and not the data it refers to.
This may be desireable in some situations when we don't want to be able to rebind the reference through
<code>operator=</code>, but it isn't at all what we intended here.</p>
<p>Just like smart pointers, the solution here is to make the template type be <code>const</code>. So instead of
<code>reference_wrapper&lt;int&gt;</code>, we want <code>reference_wrapper&lt;const int&gt;</code>. Intuitively you can think of this
as the data being constant versus the reference itself (which has its own data stored in a different
are of memory) being constant.</p>
<p>The standard library provides a nice <code>std::cref()</code> function for constructing const reference wrappers.
As with smart pointers, <code>std::reference_wrapper&lt;int&gt;</code> and <code>std::reference_wrapper&lt;const int&gt;</code> are <em>not</em>
the same type.</p>
<pre><code class="language-C++">int n = 2;
auto r = std::cref(n);
int m = 5;

r.get() = 10; //error, const 

r = std::cref(m); // works

auto j = std::ref(n);

r = j;
// This does a bit more than before
// This first uses an implicit conversion constructor and make a
//  new std::reference_wrapper&lt;const int&gt;
// Then it will call operator= on this newly created object
//
// As we'll see later, move semantics and rvalue reference overloads
// allows this process to be relatively efficient.
</code></pre>
<p>The standard library does a pretty good job making templates of <code>const</code> and non-const types, along with 
templates of polymorphic types behave like normal via conversion constructors, but it's important to remember
that these templates do not have the exact same relationship they would if we used references directly.</p>
<pre><code class="language-C++">auto foo(std::reference_wrapper&lt;int&gt;);
auto bar(std::reference_wrapper&lt;int&gt;&amp;);

int n = 10;
auto rf = std::ref(n);
auto crf = std::cref(n);

foo(rf);
foo(crf);
// works, in both cases we construct a new 
// std::reference_wrapper&lt;int&gt;
// which is relatively cheap

bar(rf);
bar(crf); 
//^ doesn't work since crf is a reference_wrapper&lt;const int&gt;
</code></pre>
<p><code>std::reference_wrapper</code> does no lifetime checking, and its up to you to ensure that the data it refers to
is not destroyed while the reference is in use. The main advantage <code>reference_wrapper</code>s have over raw pointers
is that they are unambiguous. It's very clear that a reference wrapper doesn't own the data it refers to,
and a reference wrapper to an array will have a different type than a reference wrapper to a single
value. But to reiterate, reference wrappers have no mechanisms to know if they're still valid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containers"><a class="header" href="#containers">Containers</a></h1>
<p>Containers are classes in C++ that, well, contain things. The C++ standard library is great at adhering to the principle of &quot;one word per concept&quot;. 
Although the containers don't share a common base class, do indeed share a common static interface. 
For example, while different containers have different notions of size, the <code>size()</code> member function is always a <code>const noexcept</code> function that gets the size of the container. 
We don't have some classes with a <code>size()</code> function, others with a <code>length()</code> function, and still others with a <code>length</code> member variable. 
This consistency makes the STL pretty easy to use once you get the hang of it. In designing your own classes, you should also strive to stay consistent with this style. 
Even outside C++, &quot;one word per concept&quot; is a good rule of thumb for naming things, functions with different names should have different meanings. 
Staying consistent like this makes an interface easier to use, and easy to use interfaces are less error prone.</p>
<p>Furthermore, STL containers are templates. (They are part of the standard template library). This means that they aren't limited to containing only one type but instead can be instantiated on many different types.</p>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>We'll discuss iterators more in depth later, but STL containers define functions <code>begin()</code> and <code>end()</code> to return iterators to the beginning and end of the container respectively. 
An iterator must define, at minimum, an <code>operator*</code> to get the current element from the iterator, <code>operator++</code> to advance the iterator to the next element in the container, and <code>operator!=</code> 
to compare iterators for equality. There are actually different types of iterators, each with a set of functions they must implement. 
The iterator returned from <code>end()</code> is known as a <em>sentinel</em> and is typically an iterator the points to the slot off the back of the container. 
When iterating, an iterator is advanced, element by element, until it equals the sentinel, indicating that the iterator has reached an invalid element off the back of the container and iteration has finished.</p>
<p>The reason why iterators have this somewhat convoluted interface is because for many containers that are contiguous in memory, pointers are their iterators. 
Thus, pointers must be valid iterators, so we can't require all iterators to define something like a <code>next()</code> method.</p>
<p>When a class defines a <code>begin()</code> and <code>end()</code> method, we can use that class in an <em>enhanced for loop</em>. 
The compiler will manage the incrementing for us, and give us the actual value of the element to use in the body of the loop.</p>
<pre><code class="language-C++">std::string name = &quot;Kathy&quot;;
*name.begin() = 'H';

for (char c : name) {
    std::cout &lt;&lt; c;
}
// prints &quot;Hathy&quot;

// same as:
for (auto it = name.begin(); it != name.end(); ++it) {
    char c = *it; // get the element the iterator &quot;points to&quot;
    std::cout &lt;&lt; c;
}
</code></pre>
<p>Iterators are an area where you really want to use prefix <code>++</code> rather than postfix unless you actually need the old value. 
While iterators for containers will most likely be pointers moving along a buffer in memory, that's not always the case and using postfix <code>++</code> rather than prefix may cause excess copying.</p>
<p>Some containers allow iterating in reverse. This can be done by using the <code>rbegin()</code> and <code>rend()</code> methods. Using these reverse iterators, you would still use <code>operator++</code>, 
but that operator would cause the iterator to go backwards. Many containers also define <code>cbegin()</code> and <code>cend()</code> functions to get constant iterators which prevent you from mutating the element they point to. 
However, in order to enable iteration of <code>const</code> objects in an enhanced for loop, the container must define overloads of <code>begin()</code> and <code>end()</code> which are <code>const</code> member functions that return <code>const</code> iterators.</p>
<pre><code class="language-C++">std::vector nums = {10, 20, 30, 40, 50};
auto numIt = nums.cbegin();
*numIt; // 10
*numIt = 20; // error, const iterator
std::advance(numIt, 3); // advance iterator by 3 spaces
*numIt; //40

for (auto it = numIt; it != nums.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
} // &quot;40 50 &quot;

for (auto it = nums.rbegin(); it != nums.rend(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
} // &quot;50 40 30 20 10 &quot;

for (auto it = nums.rbegin(); it != nums.begin(); ++it) {
    // BAD: mismatch iterators
    // must use corresponding begin and end methods
    // also must not use begin from two different instances of a container
    // or two different containers
}

for (auto num : nums) {
    std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
} // &quot;10 20 30 40 50 &quot;
</code></pre>
<h2 id="emplace"><a class="header" href="#emplace">Emplace</a></h2>
<p>The <code>emplace</code> series of member functions (<code>emplace()</code>, <code>emplace_back()</code>, <code>emplace_front()</code>, etc.) allows constructing an element directly in the container rather than copying one. 
The arguments of an <code>emplace</code> function are <em>forwarded</em> to the constructor. 
Therefore, any series of arguments that can be used in a constructor to construct a new object that the container holds can be passed to an <code>emplace</code> function. 
This also includes the move constructor. Therefore <code>emplace</code> should be used to move an element into the container rather than copy it. 
This allows us to have containers of move-only types such as <code>std::unique_ptr</code>. We'll discuss how this works later.</p>
<pre><code class="language-C++">struct MyStruct {
    int a, b, c;

    MyStruct(int a, int b, int c) : a(a), b(b), c(c) {}
};

std::vector&lt;MyStruct&gt; structs;

structs.emplace_back(5, 20, 30);
// construct a new MyStruct with a = 5, b = 20, and c = 30 onto the back of structs
structs[0].c; // 30

MyStruct s2 = {0, 0, 0};
structs.emplace_back(std::move(s2));
// move s2 into the container by using the move constructor

MyStruct s3 = {1, 1, 1};
structs.push_back(s3); // copy s3 into the container
s3.a; //1 - s3 was copied so it's still valid to use
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>Let's start with the modern array. A C++ array is a fixed-sized container of elements of a fixed type stored contiguously is memory. 
The size of the array must be known at compile time and cannot change. This because the memory for an array is allocated on the stack statically, so the compiler needs to know how much space to make.
While this means that arrays aren't as flexibly as a dynamically sized container, it also means that the memory allocations are much more efficient.
<code>std::vector</code> would be your go-to dynamically sized container in C++. Arrays are a class, and part of the STL (standard template library). 
We'll discuss templates a lot more later, but for now simply think of them as a parameter that can be supplied to classes or functions at compile time. Unlike normal function parameters, template parameters can be, and often are, types.
This allows us to create one class for the concept of an array, and <em>instantiate</em> that class on any type we want such as <code>int</code> or <code>std::string</code> or a custom user-defined type. 
Templates are a big topic we'll discuss later. The interface for the array is declared in the <code>array</code> header and therefore must be included via <code>#include &lt;array&gt;</code>.</p>
<pre><code class="language-C++">#include &lt;array&gt;


int main() {
    std::array nums = {1, 2, 3, 4, 5};
    nums.size(); //5
    nums[0]; //1
    nums[4] = 20;

    for(auto n : nums) {
        std::cout &lt;&lt;  n &lt;&lt; &quot; &quot;;
    }
    // prints &quot;1 2 3 4 5 &quot;
    return 0;
}
</code></pre>
<p>We could not declare <code>nums</code> to be <code>auto</code> because by default a list of elements surrounded by braces will be deduced as something else called an <code>std::initializer_list</code>. 
After <code>nums</code> has been created, we cannot change the size of <code>nums</code>, or the type of elements <code>nums</code> store.</p>
<p>In fact, the full definition of <code>nums</code> in reality looks like this: <code>std::array&lt;int, 5&gt; nums = //...</code>. 
But the compiler is smart enough to deduce the type and size of <code>nums</code> since we initialize it with values. 
If we did not have the data we want to store in the array at the ready, we would have to specify the size and type to be stored in it.</p>
<pre><code class="language-C++">std::array&lt;int, 3&gt; nums;
nums.empty(); // false - array has elements, we just didn't set them
std::array&lt;int, 0&gt; nums2;
num2.empty(); // true

std::array&lt;char, 5&gt; letters('a', 'b', 'c', 'd', 'e');
std::array&lt;double, 3&gt; dbls = {3.14, 2.17, 6.28};
const std::array&lt;std::string, 5&gt; names(/*...*/);

for(auto n : letters) {
    // ...
}
</code></pre>
<p>An array is <em>iterable</em> (more on that later) and therefore we can use an <em>enhanced for-loop</em> to iterate over it. The for loop shown above will go through each element in the array, copy the value into <code>n</code>, and then execute the code in the for loop. This is much less error prone then using the C style indexing loops. If we didn't want to copy the value, we could have declared <code>n</code> to be a reference like so:
<code>for(const auto&amp; n : nums)</code>. And since we aren't modifying the data, it's good practice to declare the reference <code>const</code> as well.</p>
<p>We can also have arrays of arrays as well.</p>
<pre><code class="language-C++">std::array&lt;std::array&lt;int, 3&gt;, 3&gt; twoDArray = {
    {1, 2, 3},
    {2, 2, 3},
    {3, 2, 3}
};

twoDArray[0][1]; //2
twoDArray.front().front(); //1
twoDArray.back(); // {3, 2, 3}
twoDArray.empty(); // false
</code></pre>
<p>Why are arrays so limiting? Well the compiler does not dynamically allocate arrays. The memory is allocated on the stack like other variables with automatic lifetimes, which is much more efficient then dynamic allocations. 
Obviously, there are times when dynamic allocation is necessary and for those times we have the <code>std::vector</code>.</p>
<h2 id="c-array"><a class="header" href="#c-array">C Array</a></h2>
<p>Before looking at more STL containers, first I want to take some time to look at the C array. 
The C array is a more primitive version of the C++ STL array. Like its STL counterpart, the size must be known at compile time. 
However, the STL array is a class, which has member functions such as <code>size()</code> while the C array does not. Instead, we can use the <code>sizeof()</code> operator to get the size of the array <strong>in bytes</strong>.</p>
<pre><code class="language-C++">
int nums[] = {1, 2, 3};
float vertices[27];

sizeof(vertices) / sizeof(float); //27
vertices[0] = 0.1f;

int classes[3] = {2112, 3110, 4280};
</code></pre>
<p><code>sizeof()</code> can get us the size of a variable or type, and the compiler does this by looking at the declaration of the variable and seeing how much space that variable takes up. 
It should be noted that <code>sizeof()</code> includes padding, so the <code>sizeof()</code> a struct or class may be greater than the <code>sizeof()</code> all the members because the compiler may add padding to align the data to make it more efficient to use.</p>
<p>C arrays have another problem: they are implicitly convertible to a pointer to the first element of the array and will <em>decay</em> into a pointer when it is passed by value. 
When an array decays into a pointer, the compiler loses the dimensionality information of the array and instead of returning the size of the array, <code>sizeof()</code> will return the size of the pointer.</p>
<pre><code class="language-C++">
int nums[3] = {0, 0, 0};

sizeof(nums); // (4 or 8) * 3


void useArray(int nums[] /* same as: int * nums */) {
    std::cout &lt;&lt; sizeof(nums); // sizeof(int *) (typically 4 or 8)
}

useArray(nums);
</code></pre>
<p>Passing an array by value (<code>int nums[]</code>) is actually the same as passing a pointer by value <code>int * nums</code>. We say that an array <em>decays</em> into a pointer.
However, like function pointers, since you didn't manually allocate this pointer you should not manually free it. 
Once decayed into a pointer, it is no longer possible to use <code>sizeof</code> to compute the size of the array. This is because the compiler is longer keeping track of that information.
We can prevent this decay by using modern arrays, or by passing an array by pointer or reference.</p>
<pre><code class="language-C++">
// pass by const reference to array of size 3
void useArrayRef(const int (&amp; myArray)[3]) {
    std::cout &lt;&lt; sizeof(myArray) / sizeof(int);
}

// pass by const ptr to array of size 3
void useArrayPtr(const int (* myArray)[3]) {
    std::cout &lt;&lt; sizeof(*myArray) / sizeof(int);
}

int nums[3];
nums[0] = 1;
nums[2] =  10;

sizeof(nums) / sizeof(int); // 3

useArrayRef(nums); // 3
useArrayPtr(&amp;nums); // 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>A string isn't typically classified as a container, but it's close enough to one to put it in this chapter. We've seen a lot of these so far, so I'll save you some excessive explanations. </p>
<p>Most of the interface for <code>std::string</code> is pretty self-explanatory. </p>
<pre><code class="language-C++">std::string name = &quot;Why are all my string variables in this book called name?&quot;;

name.front(); // 'W'
name.back(); // '?'

name.at(3); // ' '
// at() performs bounds checking

name[5] = 'k';
// operator[] does not

names.size(); // get length of string

names.insert(0, 'W');

names.push_back('?');
names.pop_back();

names.append(&quot;Addendum&quot;);
names += &quot;Hello&quot;; // same as append()

names.clear(); // erase

names = &quot;Hello&quot; + std::string(&quot; World&quot;);
names.substr(1, 4); // &quot;ell&quot;
// takes start index, end index

names.replace(names.begin(), names.begin() + 2, &quot;Je&quot;);
// start iterator, end iterator

names.replace(4, 1, &quot;y&quot;); // &quot;Jelly World&quot;
// starting index, length

if (names.find(&quot;Joe&quot;) == std::string::npos) {
    // does not contain &quot;Joe&quot;
    // find returns an index or std::string::npos if it is not found
}

const auto startIndex = names.rfind('l'); 
// search for string or char starting from end of string

names.erase(names.begin() + startIndex); // &quot;Jelly Word&quot;
</code></pre>
<p>In <code>std::string</code> and other containers, there is a separate notion of <code>size</code> and <code>capacity</code>. <code>size</code> is the actual amount of elements in the container that are valid, 
<code>capacity</code> is the amount of memory currently allocated for the container including uninitialized memory. <code>size</code> can be increased and decreased with the <code>resize()</code> method while <code>capacity</code> can be increased using the 
<code>reserve()</code> method. The capacity grows at a rate of <code>2x</code> the previous capacity, and is increased automatically when the size of the container goes beyond the current capacity. 
When the container needs to reallocate memory, it has to first, allocate the amount of memory equal to the increased capacity, then move the current elements into this new area of memory and 
finally delete the old memory. Because of the cost of allocating memory and moving the container, by increasing the capacity by <code>2x</code> each time methods like <code>push_back</code> and <code>append</code> have an 
<em><a href="http://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/eff/amortized.html">amortized</a></em> time complexity of <code>O(1)</code>.</p>
<p><code>std::string</code> stores a pointer to a dynamically allocated buffer. The address of this pointer may change for the aforementioned reason. 
However, a <code>std::string</code> also typically contains a buffer of 10 to 15 characters which is allocated on the stack. This is known as the small string optimization or SSO and allows strings of a small length to 
get by without ever making a dynamic memory allocation. Dynamic allocations are very expensive compared to stack allocations so this optimization helps improve performance even though it requires more data to copy during move operations. 
Thus, you may find <code>sizeof(std::string)</code> to be quite a bit more than one might expect.</p>
<p>Concatenation with the plus operator creates a new string that is the combination of the two operands. This renders long chains of concatenations pretty inefficient. 
Luckily we have the <code>std::stringstream</code> to help us. We'll discuss streams later, but <code>std::stringstream</code> has similar usage as <code>std::cout</code>. We can use <code>operator&lt;&lt;</code> to append to the stream and then use the <code>str()</code> member method to convert everything to a string.</p>
<pre><code class="language-C++">std::stingstream ss;
ss &lt;&lt; &quot;Hello World!&quot; &lt;&lt; greeting 
    &lt;&lt; &quot;It's &quot; &lt;&lt; hour &lt;&lt; &quot; o'clock where I am and the weather is &quot;
    &lt;&lt; weatherDescription; 

const auto st = ss.str();
</code></pre>
<p><code>std::string</code> also contains a <code>c_str()</code> method to convert itself to a C string. A C string is a pointer to a contiguous buffer of characters ending in the null terminator ('\0'). 
This special byte serves as a sentinel for functions to know when they reached the end of the string. String literals are all C strings. This is why I've never used the plus operator on two string literals and 
always converted at least one to an <code>std::string</code> first because <code>operator+(const char*, const char*)</code> is not a defined function. By the way, you can actually concatenate two string literals by 
just putting them right next to each other. </p>
<p>Like function pointers, string literals don't have to be freed since they're never manually allocated. 
Actually, literals are stored directly in the compiled binary, and the pointer is an address to where that literal is.</p>
<pre><code class="language-C++">const char * concatLits = &quot;Hello&quot; &quot; World&quot;;

std::string concatStr = &quot;Hello&quot; + std::string(&quot; &quot;) + &quot;World&quot;;

auto rawStringLiteral = R&quot;DELIM(
    Raw string here
    &quot;&quot; fjedjsd
    new lines part of string too 
    \n will not be a new line but instead the literal character \n
)DELIM&quot;;
// DELIM can be whatever you want it to be

const wchar_t * wideStr = L&quot;2 bytes per character&quot;;

const auto utf8String = u8&quot;UTF-8&quot;;
const auto utf16String = u&quot;UTF-16&quot;; 
// NOT the same thing as a wideStr
// wide string is always 2 bytes per character
// utf-16 is 2 bytes per code point and at least 1 code point per character with at least 1 character per glyph

const auto utf32String = U&quot;UTF-32&quot;;
</code></pre>
<p>Since a C string is not a class and has no <code>size()</code> method, we must use a function from the C standard library to get its length: <code>strlen()</code>. 
Unlike <code>size()</code>, this function is <code>O(n)</code> since it has to keep looking at each byte following the pointer of the string (which points to the first character) until it finds the null terminator which has the value 0.</p>
<p>For non-owning references to strings, C++17 introduces the <code>std::string_view</code>. A <code>string_view</code> has a very similar interface to <code>std::string</code> but one major difference: it does not own its data. 
This means that the lifetime of <code>std::string_view</code> must be totally within the lifetime of whatever string-like object it was constructed from. 
A <code>std::string_view</code> can be constructed from an <code>std::string</code>, a C string, a pointer and a length, or a begin and end iterator. 
The typical implementation of a <code>string_view</code> would only have it store a pointer and a size. Thus, copying an <code>std::string_view</code> is likely more efficient than moving an <code>std::string</code> due to the SSO. 
But once again, <code>std::string_view</code> <strong>cannot</strong> exist past the lifetime of whatever data it was constructed from. C++20 introduces the <code>std::span</code> which is to <code>std::vector</code> what <code>std::string_view</code> is to <code>std::string</code>. </p>
<p>One difference with <code>std::string_view</code> is that methods that would normally return a <code>std::string</code> such as <code>substr()</code> return a non-owning <code>std::string_view</code>.</p>
<pre><code class="language-C++">
std::string message = &quot;wee woo wee woo&quot;;

std::string_view msgView(message.data(), message.rfind(&quot; wee&quot;)); // &quot;wee woo&quot;
// construct from pointer and size
// find returns an index, which is basically the size 0f a substr from start of string
// to the argument passed to find/rfind

std::string_view wee = msgView.substr(0, msgView.find(' '));

wee[1] = 'w';

std::cout &lt;&lt; message; // wwe woo wee woo

auto getStr() {
    std::string msg = &quot;Hello&quot;;
    return std::string_view(msg);
    // BAD: msg is a local variable and goes out of scope
}

auto msg2 = getStr();
// undefined behavior!
</code></pre>
<p>Finally, C++ strings are part of the standard template library, so it's not too much of a surprise to realize that <code>std::string</code> is an alias for 
<code>std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;</code>. We'll explore the ramifications of this more later, but for now you should know that this means we can use 
<code>std::string</code> for a string of <code>char</code>, <code>wchar_t</code> (2 byte characters), <code>char8_t</code> (utf-8), <code>char16_t</code> (utf-16), and <code>char32_t</code> (utf-32). 
Since the second and third template parameters have default arguments, you can customize the type simply as follows:</p>
<pre><code class="language-C++">std::basic_string&lt;char8_t&gt; utf8String;
</code></pre>
<p>However, since <code>std::basic_string&lt;char8_t&gt;</code> and <code>std::string</code> have different template parameters, they are different types and thus don't fit together as easily.</p>
<pre><code class="language-C++">auto result = std::string(&quot;Hello&quot;) + std::basic_string&lt;wchar_t&gt;(L&quot; World&quot;); // error
</code></pre>
<p>Furthermore, members operate on their type parameter, not on abstract notions defined by multi-byte encodings. 
So for example, the size of a utf8 string will be how many bytes it is which is not necessarily how many characters it has, using characters in the sense that a human would likely use the term character. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-rest"><a class="header" href="#the-rest">The Rest</a></h1>
<p>I think we covered enough ground to make the rest of the containers pretty self-explanatory. I'll point out a few things in each and if you want more details I suggest checking out their respective chapters 
in A Tour of C++ or their documentation on cppreference or cplusplus.com.</p>
<p>One thing I will point out is that <code>std::string</code>'s <code>find()</code> member is the oddball, returning an index or <code>std::string::npos</code>. 
The other containers' <code>find()</code> method returns an iterator to the element or the sentinel. Some containers don't have a <code>find()</code> member function. 
For those containers you can use <code>std::find()</code> passing in an iterator to the beginning and end of the range in the container you want to search. We'll talk more about STL algorithms like <code>std::find()</code> later.</p>
<h3 id="stdvector"><a class="header" href="#stdvector"><code>std::vector</code></a></h3>
<p>Stores elements contiguously in memory. The class typically just contains a pointer to the first element and size of the vector.</p>
<p>Accessing an invalid index using <code>operator[]</code> is undefined behavior but doing the same using the member function <code>at()</code> with throw an <code>std::out_of_range</code> exception.</p>
<p>As we discussed in the last chapter, appending elements to the back of a vector is cheap since capacity grows at a rate of <code>2x</code> giving us an amortized cost of <code>O(1)</code>. 
Likewise, popping elements off the back or removing a range of contiguous elements that includes the last element is also cheap because the vector can just decrease the value of its <code>size</code> member. 
It likely won't even free the memory yet because common use cases tell us that it is very likely the user will add more element to the vector.</p>
<p>Removing or inserting elements in the middle or beginning of the vector, on the other hand, is quite expensive. 
The vector will have the move all the elements coming after the insertion/removal point forward or backwards, respectively, the same amount of spaces as elements removed or inserted.</p>
<p>As with <code>std::string</code>, you cannot index an element that is off the back of the vector (index <code>&gt;= size()</code>) but still in the allocated area of memory (index <code>&lt; capacity()</code>) 
because that memory is not necessarily initialized.</p>
<p><code>std::vector&lt;bool&gt;</code> differs greatly from <code>std::vector</code> because it does not adhere to the interface exactly. For space optimization reasons, an <code>std::vector&lt;bool&gt;</code> is basically a dynamic bitset, 
with each element taking up one bit. Functions like <code>operator[]</code> and <code>at()</code> do not return references to elements anymore, because you cannot take the address of a bit. 
Instead, they return proxy objects for manipulating the bit at the specified index. </p>
<pre><code class="language-C++">// Most containers:
std::vector ints = {1, 2, 3};
int* data = &amp;ints[0];
int* end = data + ints.size();

for(; data != end; ++data) {
    std::cout &lt;&lt; *data &lt;&lt; std::endl;
} // 1 2 3

// std::vector&lt;bool&gt;
std::vector&lt;bool&gt; bools = {true, false, true};
bool* data = &amp;bools[0]; // error
bools.size() * sizeof(bool); // not the amount of memory taken up!
</code></pre>
<h3 id="stdbitset"><a class="header" href="#stdbitset"><code>std::bitset</code></a></h3>
<p><code>std::bitset</code> is basically an array of bits. The size is a template parameter like <code>std::array</code> and must be known at compile time.</p>
<pre><code class="language-C++">std::bitset&lt;32&gt; nums;
nums.reset(); // set all to 0
nums.set(); // set all to 1
nums.flip(); // flips each bit

nums[0] = 1; // no bounds checking

nums.set(2, 1); // set bit at index 2

nums.size(); // 32, num bits

nums.count(); // 2, number of set bits

nums.test(2); // 1, gets bit at index specified

if (nums.all() || nums.none()) {
    // if all bits set or no bits set
}

if (nums.any()) {
    // if at least 1 is set
}

std::string bitString = nums.to_string();
unsigned long u32 = nums.to_ulong();
unsigned long long u64 = nums.to_ullong();
</code></pre>
<h3 id="stdmap"><a class="header" href="#stdmap"><code>std::map</code></a></h3>
<p>Implemented with balanced binary search trees (typically Red-Black Trees). <code>std::map</code> stores key value pairs, so an iterator to an <code>std::map</code> returns <code>std::pair&lt;K, V&gt;</code> where <code>K</code> is the key type and <code>V</code> is the value type. A pair has <code>first</code> and <code>second</code> member variables for accessing the respective element.</p>
<p>If the key passed to <code>operator[]</code> (which can be a non-integer) does not exist in the map, it is created using the default constructor along with a default constructed value. <code>at()</code> on the other hand will throw an exception if the element doesn't exist.</p>
<h3 id="stdset"><a class="header" href="#stdset"><code>std::set</code></a></h3>
<p>Also implemented with balanced binary search trees. Stores unique elements.</p>
<p>The default implementation of <code>std::map</code> and <code>std::set</code> use <code>std::less&lt;T&gt;</code> to compare the elements. Therefore, keys must be comparable by <code>operator&lt;</code> or specialize <code>std::less&lt;T&gt;</code>. 
You can also specify a different comparison functor type that overloads <code>operator()</code> as the second template parameter. We'll discuss this more later.</p>
<p>For both <code>std::map</code> and <code>std::set</code>, finding an element uses <code>operator==</code> to compare for equality.</p>
<h3 id="stdmultiset-and-stdmultimap"><a class="header" href="#stdmultiset-and-stdmultimap"><code>std::multiset</code> and <code>std::multimap</code></a></h3>
<p>Same as their respective non-multi variants except they can hold duplicate keys.</p>
<h3 id="stdunorded_set-and-stdunordered_map"><a class="header" href="#stdunorded_set-and-stdunordered_map"><code>std::unorded_set</code> and <code>std::unordered_map</code></a></h3>
<p>Same as their respective ordered variants except implemented with a hash map / hash set. Due to the hash function, an iterator will traverse the map/set in an arbitrary order while their 
ordered variants will traverse the keys in order from least to greatest.</p>
<p>The keys of each must specialize <code>std::hash&lt;T&gt;</code> or you must change the third template argument to a  functor type to perform the hashing. 
Keys are compared via <code>operator==</code> which can be changed by changing the 4th template argument to a custom comparator type which overloads <code>operator()</code> to perform the comparison.</p>
<h3 id="stdforward_list"><a class="header" href="#stdforward_list"><code>std::forward_list</code></a></h3>
<p>Typically a simple linked list implementation. Performs constant time insertion/deletion from anywhere in the list. Can only iterate through it one way (forward). Linear time random access.</p>
<h3 id="stdlist"><a class="header" href="#stdlist"><code>std::list</code></a></h3>
<p>Typically a doubly linked list. Again performs constant time insertion / deletion at any point in the list. Iterators are bidirectional. Linear time random access.</p>
<h3 id="stddeque"><a class="header" href="#stddeque"><code>std::deque</code></a></h3>
<p>&quot;Double ended queue&quot;. Performs fast insertions and deletions at both ends of lists. Typically implemented as a sequence of small chunks of contiguous allocated elements. 
Constant time random access but linear insertion or removal of elements in middle of deque. Due to extra bookkeeping, slower indexed access than <code>std::vector</code> and a larger size of the class.</p>
<h3 id="stdstack-stdqueue-and-stdpriority_queue"><a class="header" href="#stdstack-stdqueue-and-stdpriority_queue"><code>std::stack</code>, <code>std::queue</code>, and <code>std::priority_queue</code></a></h3>
<p>These are not containers themselves but <em>adapters</em>. They provide an interface of their respective data structure using the container specified as the second template argument. <code>std::stack</code> and <code>std::queue</code> use <code>std::deque</code> as their default container while <code>std::priority_queue</code> uses <code>std::vector</code>.</p>
<p>The comparator for <code>std::priority_queue</code> is its third template argument. The priority queue cannot change the priority of existing elements. Internally, the priority queue uses functions like <code>std::make_heap</code>, <code>std::push_heap</code>, <code>std::pop_heap</code>, and <code>std::sort_heap</code> which manage a heap given a starting and ending random access iterator.</p>
<h3 id="stdinitializer_list"><a class="header" href="#stdinitializer_list"><code>std::initializer_list</code></a></h3>
<p>This one isn't technically part of the containers either. The purpose is to allow you to pass an arbitrary amount of the same type arguments to a constructor or function. The initializer list can be set and iterated, and that's about it. </p>
<pre><code class="language-C++">auto sum(std::initalizer_list&lt;int&gt; list) {
    auto sum = 0;
    for (e : list) {
        sum += e;
    }
    return sum;
}

const auto nums = {1, 2, 3, 4}; // type deduction of {} is initializer list
sum(nums); // 10


class MyClass {
    std::vector&lt;int&gt; nums;
public:
    MyClass(std::initializer_list&lt;int&gt; startingNums) : nums(startingNums) {}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h1>
<p>Take this example:</p>
<pre><code class="language-C++">std::string makeGreeting(const std::string &amp; personName) {
    return &quot;Hello, &quot; + personName + &quot; it is very nice to meet you!&quot;;
}

std::string greetJake = makeGreeting(&quot;Jake&quot;);
</code></pre>
<p>In pre C++11, <code>&quot;Jake&quot;</code> would be constructed into an <code>std::string</code>, and each <code>operator+</code> would also construct new <code>std::string</code>s. 
Next the <code>return</code> statement could copy construct a temporary <code>std::string</code> which is returned from the function and <code>greetJake</code> could be copy constructed from that temporary. 
A lot of copies! </p>
<p>Without changing any of the code and simply compiling with a modern version, the last two copies become (relatively) low cost moves. 
As we saw earlier, moves often amount to just copying pointers. However, as we discussed this isn't always the case. 
One such exception are strings, due to SSO (small string optimization) the move will also have to copy the small stack allocated buffer which is typically &lt;= 15 bytes in size. 
Therefore, moving a string amounts to copying a pointer, integral size, and the small buffer while moving something like an <code>std::vector</code> would typically only amount to copying a pointer and integral size.</p>
<p>This story isn't quite over, so please save your cards and letters, but I hope you can see the motivation for moving.</p>
<h2 id="move-basics-from-constructors-chapter"><a class="header" href="#move-basics-from-constructors-chapter">Move Basics (from constructors chapter)</a></h2>
<p>Now I talk about this move constructor. But what is moving exactly? Well, instead of performing a copy, we move the internals from one object to another, leaving behind an empty shell of an object to be destroyed. 
When the old object is destroyed, nothing happens because the object's internal state has been moved out and put into a new object.</p>
<p>The double ampersand is an <em>rvalue reference</em>, and basically it is a reference to temporary values. 
For example, the return value of a function is moved (well, sometimes, more on this later) into a temporary value and that temporary is returned. 
The temporary gets destroyed at the end of the statement that called the function. We can also manually move non-temporaries with the <code>std::move</code> function. 
However, once a value has been moved, you <strong>must not</strong> use it again since all of its state has been put into a different object.</p>
<p>Now frankly, I've told you a flat out lie, but we'll discuss this in way more detail later.</p>
<pre><code class="language-C++">std::string getString() {
    return &quot;Hello&quot;;
}

std::string greet(std::string &amp;&amp; name) {
    return &quot;Hello &quot; + name;
}

std::string myStr = getString(); // move constructor
std::string myStr2 = std::move(myStr); // move constructor again
const auto myStr3 = myStr2; // copy constructor

std::string myName = &quot;Jacob&quot;;
auto greeting = greet(std::move(myName));
    // move ctor for name in the greet() function
    // move ctor for greeting
</code></pre>
<hr />
<blockquote>
<p>&quot;Premature optimization is the root of all evil.&quot;</p>
<p>- Donald Knuth</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alphabet-soup-of-values"><a class="header" href="#alphabet-soup-of-values">Alphabet Soup of Values</a></h1>
<p>What we've seen so far are <em>rvalues</em> and <em>lvalues</em>. Both are these come from pre C++11 and the names originate from the idea than a lvalue can go on the left side of the equals sign and 
rvalues may only go on the right side. A little better criteria is that a lvalue is something you can take an address of and a rvalue you cannot. 
Another possible distinction is that rvalues are temporary values while lvalues are named values.</p>
<pre><code class="language-C++">int age = 5;
Person p = Person(&quot;Bob&quot;, 20);
int ageBob = p.getAge();
long long bigAge = age;
</code></pre>
<p>Here, <code>age, p, ageBob, and bigAge</code> are lvalues. <code>5</code>, the result of the <code>Person</code> constructor, and the temporary result of <code>p.getAge()</code> are all rvalues. 
Once again, you can think of rvalues as temporary values. We can't take the address of the result of the <code>Person</code> constructor, <code>5</code>, nor the result of <code>p.getAge()</code>. Although we can do this:</p>
<pre><code class="language-C++">int foo();
&amp;foo; // adress of foo
// not the address of the result of calling foo

int * resPtr = &amp;(foo()); // error
// return from function is not an lvalue
</code></pre>
<p>Although we cannot have pointers to rvalues, we can have references to rvalues. Lvalue references are denoted with <code>&amp;</code> and rvalue references are denoted with <code>&amp;&amp;</code>. 
Now confusingly, the rvalue reference itself is a lvalue. This lvalue just so happens to store a reference to a rvalue. Using rvalue references, we can avoid an excess construction when using rvalues.</p>
<pre><code class="language-C++">
auto makePerson() {
    return Person();
}

auto funcL(const Person &amp; p) {

}

auto funcR(Person &amp;&amp; p) {

}

Person p;

funcL(p); // no construction
funcR(p); // error, p is not an rvalue
funcL(makePerson()); // construct a new Person from the temporary return, pass the reference of this new Person to funcL
funcR(makePerson()); // no construction
</code></pre>
<p>As you may notice, this <code>&amp;&amp;</code> syntax is exactly what we use in the move constructor. 
As a rvalue reference indicates a temporary or value we don't care about, this means that when passed to a move constructor, we're allowing that constructor to steal the rvalues internals and leave behind a &quot;shell&quot; 
of an object.</p>
<p>In order to move, we need a non-const rvalue reference (otherwise we couldn't modify the old value to invalidate it, and we'd effectively perform a copy). 
Thus, since rvalue references are primarily used for moving, we don't often use <code>const</code> rvalue references. 
This is because, if we tried to move construct from a <code>const</code> rvalue reference, the compiler would silently perform a copy since a <code>const &amp;&amp;</code>
cannot bind to <code>&amp;&amp;</code> but it can bind to <code>const &amp;</code> (copy constructor!).</p>
<pre><code class="language-C++">
Person getPerson() {
    Person newPerson;
    //...
    return newPerson;
}

// accepts an rvalue reference!
void doStuff(Person &amp;&amp; p) {
    std::cout &lt;&lt; p.getName() &lt;&lt; &quot;\n&quot;;
}

void doStuff2(const Person &amp; p) {}

doStuff(getPerson());
doStuff2(getPerson()); // construct Person from return of getPerson

doStuff(Person(&quot;Joe&quot;, 10));
doStuff2(Person(&quot;Joe&quot;, 10)); // construct another Person from constructed person

doStuff(std::move(lvaluePerson));
lvaluePerson.getName(); // BAD, lvaluePerson has been moved
// internals could be empty
</code></pre>
<p>Notice <code>getPerson()</code> doesn't return a <code>Person&amp;&amp;</code> nor do we explicitly move <code>newPerson</code>, but the resulting behavior is still to move <code>newPerson</code> and bind that temporary to the rvalue reference. 
It's generally not a good idea to have a return type as a rvalue reference nor should we explicitly return by <code>std::move()</code> because this inhibits some compiler optimizations we'll talk about later.</p>
<p>So what's the point of all this? Well, since we are using a reference to an existing object, we don't have to reconstruct the object from the temporary. 
Furthermore, a rvalue indicates a temporary object. Thus, when we use rvalues we get to assume they the object is being discarded, and we can construct new objects from rvalues very cheaply via swapping. 
Instead of having to copy the state from the existing object to the new instance, we can sort of just steal the state of the temporary and take ownership of it. 
After all, a rvalue is just a temporary about to be destroyed. </p>
<pre><code class="language-C++">auto sumVec(const std::vector&lt;int&gt; &amp; v) {
    return std::accumulate(v.begin(), v.end());
}

// rvalue overload
auto sumVec(std::vector&lt;int&gt; &amp;&amp; v){
    std::vector&lt;int&gt; * ptr = &amp;v;
    // this is valid, so v is an lvalue


    return sumVec(v);
    // calls lvalue reference version
    // since v is an lvalue
}
std::vector&lt;int&gt; * invalid = &amp;std::vector&lt;int&gt;({20, 30, 40, 560}); // error! not an lvalue

const auto sum = sumVec({20, 30, 40, 560}); // bind to rvalue overload
// the vector is constructed once, that single object is passed by reference to both functions


std::vector vec = {1, 2, 3, 4};

const auto sum2 = sumVec(vec); // calls lvalue overload
// again vector is constructed once (at its definition)
</code></pre>
<p>Later we'll see how universal references (aka forwarding references) can be used to have one function for both lvalues and rvalues. 
For now, a good method (and sometimes preferable to forwarding references) to get the best of both worlds is to create two functions and implement the rvalue reference overload in terms of the lvalue one.</p>
<p>Now since a rvalue reference argument is a lvalue, if we want to pass it to another function taking a rvalue reference we'd have to use <code>std::move</code>.</p>
<pre><code class="language-C++">auto func1(Car &amp;&amp; car) {
    //...
}

auto func2(float mpg, Car &amp;&amp; car) {
    // ..
    return func1(std::move(car));
    // cannot use car after this line
    // totally fine since that's the last line
    // in the function
}

func2(30.3, {&quot;Tesla&quot;, &quot;Model S&quot;});
// A Car is constructed once, a reference to that is passed to func2
// then that same car is moved to func1
</code></pre>
<h2 id="more-values"><a class="header" href="#more-values">More Values!</a></h2>
<p>Now lvalues and rvalues aren't the full story. The taxonomy of expressions into these different types of values is known as an expression's value category. 
The rvalues I've been talking about so far (and pre C++11 rvalues) are really <em>prvalues</em> and the new rvalue category contains both <em>prvalues</em> and <em>xvalues</em>. 
The lvalues I've been talking about (pre C++11 lvalues) are still called lvalues but are now a subset of expressions categorized as <em>glvalues</em>. (I did name this chapter &quot;alphabet soup&quot; for a reason).</p>
<pre><code>             expression
            /          \
        glvalue       rvalue
       /      \      /      \
 lvalue        xvalue        prvalue
</code></pre>
<h3 id="prvalues"><a class="header" href="#prvalues">prvalues</a></h3>
<p>A <em>prvalue</em> is the result of the construction of an object including functions returning non-references, literals (except string literals), enumerators, lambda expressions, pending member function calls, and the <code>this</code> pointer. 
Roughly speaking it is a direct value. A prvalue cannot be polymorphic so its static type must be the same as its dynamic type.</p>
<pre><code class="language-C++">Person(&quot;Jimmy&quot;, &quot;Longbottom&quot;); // prvalue
{20, 30, 40}; // consruct an std::initializer_list&lt;int&gt;
std::string(&quot;Hello World&quot;); // prvalue

&quot;Hiya&quot;; //not prvalue

str1 + str2; // operator+ constructs a new string, that result is a prvalue

42 // literals are prvalues

struct Person {
    enum {
        brown,
        black,
        blonde,
        red,
        ginger
    } hairColor;

    auto guessEyeColorFromHairColor() {
        switch (hairColor) {
            // ...
        }
    }
}

Person::ginger; // prvalue, since enumerators are prvalues

Person p;

p.guessEyeColorFromHairColor; // pending member function call
// prvalue
// cannot do anything with this except call it
// cannot take reference of this

// as a reminder, here is the member function pointer syntax
HairColor(Person::* memberPtr)(void) = &amp;Person::guessEyeColorFromHairColor;
(p.*memberPtr)(); // call it with p as the context object

// But
p.*memberPtr; // is also a prvalue (same reason as above)
</code></pre>
<h3 id="xvalues"><a class="header" href="#xvalues">xvalues</a></h3>
<p>Named as such because it is an &quot;expiring&quot; value. 
It denotes an object or bit-field that is nearing the end of its lifetime and can be moved. 
These were originally classified as lvalues pre C++11, so one way to think of them are lvalues that can be moved. 
They are created in 3 cases: accessing a non-static member of a rvalue, the result of a function call that returns a rvalue reference, or casting an object to a rvalue.</p>
<p>The rvalue category comprises prvalues and xvalues.</p>
<pre><code class="language-C++">auto getPerson() {
    return Person {Person::red};
}

Person&amp;&amp; bar() {
    // ...
}

getPerson().hairColor; //xvalue

Person p {Person::brown};

std::move(p); // we'll discuss this later but std::move actually just casts to an rvalue
// so this is an xvalue
static_cast&lt;Person&amp;&amp;&gt;(p); // also xvalue

bar(); // xvalue (result of calling a function returning an rvalue reference)


</code></pre>
<h3 id="glvalues"><a class="header" href="#glvalues">glvalues</a></h3>
<p>Glvalues are &quot;generalized lvalues&quot; and are composed of lvalues and xvalues. 
They can be polymorphic (actual type is not the static type) and have an incomplete type. 
When a glvalue appears where an prvalue is expected, the glvalue is converted to a prvalue.</p>
<p>Let's look at an example to recap:</p>
<pre><code class="language-C++">class Game {
    std::string name;
public:

    Game(std::string some_name) : name(std::move(some_name) /*xvalue*/) {}

    std::string&amp; getName()
    {
        return name;
    }

    std::string cpyName() const
    {
        return name;
    }
};

Game g(&quot;Skyrim&quot;); 
g; // lvalue

g.getName(); // lvalue
g.cpyName(); //prvalue
</code></pre>
<h3 id="returning-by-rvalue-reference"><a class="header" href="#returning-by-rvalue-reference">Returning by rvalue reference</a></h3>
<p>Now I said it's <em>generally</em> not a good idea to return by rvalue references, yet I also said that the result of a function that returns by rvalue reference is an xvalue. 
So clearly, returning by rvalue references has its uses. And yes, yes it does but its usage is somewhat esoteric. </p>
<p>Take the following code snippet:</p>
<pre><code class="language-C++">class MaybeResult {
    ResultType result;
    bool success;
public:
    MaybeResult() : success(false) {}
    MaybeResult(const ResultType &amp; res) : result(res), success(true) {}

    ? valueOrThrow() {
        // just for fun: this concept is called a Monad and this particular function is often named unwrap()
        if (success) return result;
        throw std::runtime_error(&quot;No value stored in result&quot;);
    }
};

MaybeResult doComputation() {
    // ...
    return MaybeResult(computation);
}

auto res = doComputation().valueOrThrow();
</code></pre>
<p>Now, how can we avoid copying <code>result</code>. 
Perhaps <code>ResultType</code> is a large matrix, it would be great not to copy it. 
But if we return by reference, then the reference will dangle since <code>result</code> is a member of a temporary. 
What if we could move <code>result</code>? Well, that would be lovely but then <code>valueOrThrow</code> would be unsafe to call on a lvalue!</p>
<p>Thankfully, we can use <em>ref-qualifiers</em> to constrain the type of value the member function is applied on. 
Ref-qualifiers work exactly like declaring a function <code>const</code>. In truth, both qualifiers aren't properties of the function but rather constraints on the type of the implicit first argument <code>this</code> pointer. 
For example, a free function version of <code>valueOrThrow</code> could be:</p>
<pre><code class="language-C++">ResultType&amp;&amp; valueOrThrow(MaybeResult &amp;&amp; maybe) {
    if (maybe.success) return std::move(maybe.result);
    else //...
}

ResultType&amp; valueOrThrow(MaybeResult &amp; maybe) {
    if (maybe.success) return maybe.result;
    else //...
}

const ResultType&amp; valueOrThrow(const MaybeResult &amp; maybe) {
    if (maybe.success) return maybe.result;
    else //...
}
</code></pre>
<p>The analogous member functions using ref-qualifiers would therefore be:</p>
<pre><code class="language-C++">    //...


    // called on rvalues
    ResultType&amp;&amp; valueOrThrow() &amp;&amp; {
        if (success) return std::move(result);
        else //...
    }

    // when valueOrThrow() is called on lvalues
    ResultType&amp; valueOrThrow() &amp; {
        if (success) result;
        else //...
    }

    // when called on const lvalues
    const ResultType&amp; valueOrThrow() const &amp; {
        if (success) return result;
        else //...
    }
};
auto res = doComputation().valueOrThrow(); // #1
MaybeResult res2;

res2.valueOrThrow(); // #2

const auto res3 = doComputation();

res3.valueOrThrow(); // #3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-optimizations"><a class="header" href="#move-optimizations">Move Optimizations</a></h1>
<p>Are you still with me? The last chapter definitely got pretty deep in the weeds. 
In the spirit of full disclosure, that's because during my Googling to double check myself, I found quite a bit I didn't know. 
I realized that I had no idea when it was useful to return a rvalue reference aside from re-implementing <code>std::move</code>,
and I also realized that my understanding of xvalues was pretty muddled. 
It just goes to prove my point that I'm no expert. Anyway...</p>
<p>Earlier I said that a simple function such as:</p>
<pre><code class="language-C++">Person getPerson() {
    return Person(&quot;Lily&quot;);
}
</code></pre>
<p><em>could</em> cause 2 copies in pre-C++11 and 2 moves today.
Well, I doubt any commercial compiler would actually perform those 2 moves. Consider the following code:</p>
<pre><code class="language-C++">class Test {
public:
    Test() {
        std::cout &lt;&lt; &quot;Init\n&quot;;
    }
    Test(const Test&amp;) {
        std::cout &lt;&lt; &quot;Copy\n&quot;;
    }
    Test(Test&amp;&amp;) {
        std::cout &lt;&lt; &quot;Move\n&quot;;
    }
};


auto getTest() {
    return Test();
}

auto t = getTest();
</code></pre>
<p>On MSVC and GCC the result is simply <code>&quot;Init&quot;</code>. Not a single copy or move is performed. 
This is known as the RVO or Return Value Optimization, and it allows (pre C++17) or guarantees (C++17 and later) the elision of the two aforementioned temporaries when a <em>prvalue</em> is the expression in the return statement. 
This can happen <strong>even if elision changes the behavior of the program</strong>. As you can see, the RVO changed the behavior of the program from printing:</p>
<blockquote>
<p>Init</p>
<p>Move</p>
<p>Move</p>
</blockquote>
<p>to just &quot;Init&quot;. So even if the constructor had some code performing a side effect, that move can be elided. 
Now for RVO to be mandatory, the prvalue being returned must have the exact same type as the return type of the function. 
Recall that prvalues are not polymorphic, so doing something like this:</p>
<pre><code class="language-C++">Test getTest() {
    Test t;
    return std::move(t);
    // xvalue, not prvalue
    // type is Test&amp;&amp; not Test
}
</code></pre>
<p>makes it ineligible for RVO. The RVO also works when a function has multiple return statements.</p>
<p>Now what about something like this:</p>
<pre><code class="language-C++">Test getTest() {
    Test t;
    return t;
}
</code></pre>
<p>According to our rules this doesn't qualify for RVO since <code>t</code> is a lvalue. But, if you run this code, chances are you'll notice once again only &quot;Init&quot; is printed. 
This is known as the Named Return Value Optimization or NRVO. NRVO is <strong>not mandatory</strong>, however it's a common optimization performed by compilers. 
Basically, it's RVO but for values that have a name. 
Copy elision can also occur in a throw statement and in a catch clause when the thrown exception has the exact same type as the exception in the catch clause. 
When this elision occurs, the exception is essentially caught by reference, however this elision won't introduce polymorphism.</p>
<p>Let's play compiler; how could we elide these temporaries? Well, we need to construct the return object directly in the caller's stack. 
So, maybe the caller could pass us a pointer to an area of memory that the return value can fit in, and we can just construct the object in that area of memory. </p>
<pre><code class="language-C++">Test getTest() {
    return Test();
}

auto t = getTest();

// could be turned into something sort of like this

void getTest(void * returnValue) {
    new (returnValue) Test();
    // construct new Test at the pointer given
    // actual RVO by compilers probably wouldn't
    // do it this way
}

// sizeof() returns a compile time constant
char buffer[sizeof(Test)];
// can't have an array of Test object or
// pass a Test pointer because we aren't the ones constructing a Test object
getTest(buffer);
Test * t = reinterpret_cast&lt;Test*&gt;(buffer);

// yes this is a pointer and not a value, but this is just the general idea
// and not an actual implementation
t-&gt;~RVO();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-on-move"><a class="header" href="#more-on-move">More on Move</a></h1>
<p>I mentioned this earlier, but <code>std::move</code> doesn't move anything. 
Instead, it <em>casts</em> whatever you pass it to an <code>rvalue</code>. 
Since a rvalue indicates giving up ownership, a manual <code>std::move()</code> says &quot;hey, I'm done with this, and you can do whatever you want with it&quot;. 
Therefore, you shouldn't use a value after you have manually moved it. </p>
<p>As I mentioned, the idea of moving is to swap the internals. 
For example, with <code>std::vector</code> moving ends up copying the internal pointer and size from one vector to the other and invalidating both values in the original object. 
The original vector would then just be an empty shell waiting to be destroyed.
Here's another rough example from our Socket RAII class.</p>
<pre><code class="language-C++">class Socket {
private:
    unsigned int sock;
public:
    Socket() : sock(socket(AF_INET, SOCK_STREAM, 0)) {}
    ~Socket() {
        if(sock != INVALID_SOCKET)
            closesocket(sock);
    }
    Socket(Socket&amp;&amp; other) : sock(INVALID_SOCKET) {
        std::swap(sock, other.sock);
    }
    Socket&amp; operator=(Socket&amp;&amp; other) {
        std::swap(sock, other.sock);
        return *this;
    }
};


</code></pre>
<p>Many classes express things that don't make sense to be copied. (For example our socket class, or a thread). However, it still makes sense to transfer ownership of them. 
That's where moves come in. Let's say you want a vector of Sockets to keep track of all the clients connected to a server via TCP. The following will not compile:</p>
<pre><code class="language-C++">std::vector&lt;Socket&gt; sockets;

Socket s;
sockets.push_back(s); //bad, tries to copy
sockets[userId] = s; //bad, tries to copy
</code></pre>
<pre><code class="language-C++">std::vector&lt;Socket&gt; sockets;

Socket s;
sockets.emplace_back(Socket()); //emplace_xxx takes an rvalue
sockets[userId] = std::move(s); //invokes move constructor
// cannot reference s anymore
</code></pre>
<p>It's pretty dangerous to use std::move() to manually move a lvalue. If you do it, it should be at the end of the lvalue's scope, so that it can't be accidentally referenced later.</p>
<pre><code class="language-C++">std::unique_ptr&lt;Port&gt; cmr::addPortDecorator(
    std::unique_ptr&lt;Port&gt;&amp;&amp; port, 
	std::shared_ptr&lt;msgFmt::MsgFormatter&gt; fmt,
	/*enum*/ PortDecorator d)
{
	// only one PortDecorator so I don't use a switch here
	return std::make_unique&lt;ThreadPort&gt;(std::move(port), fmt);
    // Where ThreadPort constructor takes an rvalue reference of a port unique_ptr
}
</code></pre>
<p>Here, <code>port</code> binds to a rvalue, so any temporaries passed to <code>addPortDecorator</code> are not copied. 
<code>port</code> itself is a lvalue (that binds to rvalues) and thus we must use <code>std::move()</code> to pass along the rvalue which was passed to <code>addPortDecorator()</code>. 
Notice also the move is at the last place we reference port. </p>
<h2 id="rtti"><a class="header" href="#rtti">RTTI</a></h2>
<p>Ok this admittedly has little to do with move semantics, but I didn't know where to put it. 
It better belongs in the casting section, but I didn't want to give half an explanation since it helps to know about prvalues and glvalues.</p>
<p>RTTI stands for runtime type information, and it's how <code>dyanmic_cast</code> is able to check the dynamic type during a cast. 
RTTI information is encapsulated within an <code>std::type_info</code> object which is part of the <code>&lt;typeinfo&gt;</code> header. 
This object is hashable with the <code>hash_code()</code> member function, comparable with <code>operator==</code> and <code>operator!=</code>, can be ordered with the <code>before()</code> member function,
and can also print out an implementation defined name representing the type with the <code>name()</code> member function. <code>std::type_info</code> is neither constructable nor copyable. 
If you want to use it as a key or put it in a container, you can wrap it in an <code>std::type_index</code> which provides value semantics for an <code>std::type_info</code>. 
Internally, <code>std::type_index</code> holds a pointer to a <code>std::type_info</code> object and is therefore copy constructable and assignable. 
<code>std::type_info</code> objects have static lifetimes, so their pointers should not be manually freed.</p>
<p>The <code>name()</code> member function should be used for debugging purposes only. 
This name is implementation defined, and it may return a different string for the same type between different compilations or even different executions of the program. 
<code>name()</code> also does not distinguish between reference and non reference types.</p>
<p>A <code>std::type_info&amp;</code> is returned by the <code>typeid()</code> operator. This operator takes an expression or a type. Top level qualifiers (<code>const</code> or <code>volatile</code>) and referenceness is ignored;
so <code>typeid(int) == typeid(const int) == typeid(int&amp;)</code>. If passed an expression that is a <em>glvalue</em>, the expression is executed,
and the resultant dynamic type's (behaves polymorphically) <code>std::type_info</code> is returned. 
If the expression is a <em>prvalue</em>, it's not executed, and the static type's <code>std::type_info</code> is returned because prvalues are not polymorphic. 
Dereferencing a <code>nullptr</code> within <code>typeid()</code> will throw <code>std::bad_typeid</code> if the pointer being dereferences is polymorphic. 
If it is not (and therefore dereferencing it can only result in one type), no exception is thrown.</p>
<pre><code class="language-C++">const std::type_info&amp; ti = typeid(std::cout &lt;&lt; &quot;Hello there\n&quot;); 
// expression executed and prints (bc operator&lt;&lt; returns an ostream reference -&gt; glvalue)
std::cout &lt;&lt; ti.name() &lt;&lt; std::endl; 
// implementation defined but probably something like
// std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;

std::vector&lt;std::type_index&gt; types;
types.push_back(ti); //type_index is constructible and copyable

struct HerType {
    virtual ~HerType() = default;
}

struct MyType : public HerType {
    MyType() {
        std::cout &lt;&lt; &quot;Hello World\n&quot;
    }
}

std::cout &lt;&lt; typeid(MyType()).name() &lt;&lt; std::endl;
// only prints (most likely) &quot;MyType&quot;
// constructor not executed

MyType mt;
HeyType&amp; ht = mt;
std::cout &lt;&lt; typeid(ht).name() &lt;&lt; std::endl;
// likely &quot;MyType&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templates"><a class="header" href="#templates">Templates</a></h1>
<p>We've been using these quite a bit already, and you may already be familiar with things like templates from another programming language.
Templates allow us to pass parameters (often types) to classes, structs, and functions at compile time. 
Effectively, what this does is replace every template argument with whatever type is passed to it. 
For example, <code>std::vector</code> is a template that is <em>instantiated</em> with the type we specify.
This allows one definition of <code>std::vector</code> to be used for many types.
Each template <em>instantiation</em> is a different type; behind the scene each unique combination of template parameters passed to a template type results in 
the compiler generating a unique class/function. 
As we've seen, this means that <code>std::unique_ptr&lt;Base&gt;</code> and <code>std::unique_ptr&lt;Derived&gt;</code> are totally distinct classes even though <code>Derived</code> is a subclass of <code>Base</code>.</p>
<pre><code class="language-C++">template&lt;typename T&gt; // this is the template parameter
class MyVec {
    size_t size;
    T * data;
public:
    explicit MyVec(size_t size) : size(size), data(new T[size]) {}
    // T is effectively replaced with whatever type we specify
    // this type substitution happens at compile time allowing
    // operations like new (which need the static type)
    // to work
    ~MyVec() {
        delete[] data;
    }

    T&amp; operator[](size_t idx) {
        return data[idx];
    }

    T* begin() {
        return data;
    }

    T* end() {
        return data + size;
    }

    bool contains(const T&amp; e) const {
        const auto end = data + size;
        return std::find(data, end, e) != end;
    }
};

MyVec&lt;int&gt; mv(100);

// -----------------------------------------------
// Effectively what happens is the compiler generates the following:

class MyVec_int {
    size_t size;
    int * data;
public:
    MyVec_int(size_t size) : size(size), data(new int[size])
    ~MyVec_int() {
        delete[] data;
    }

    int&amp; operator[](size_t idx) {
        return data[idx];
    }

    int* begin() {
        return data;
    }

    int* end() {
        return data + size;
    }

    bool contains(const int&amp; e) const {
        const auto end = data + size;
        return std::find(data, end, e) != end;
    }
};

MyVec_int mv(100);
</code></pre>
<p>In order to instantiate a template, the template's full definition (not just declaration) must be available. 
Since translation units (source file + all included headers) are compiled independently,
the general result is that a template function or class must be defined in a header file. 
This allows multiple source files to declare instances of template types because when the compiler compiles the translation unit,
the definition is available since it's in the header file. 
There is a way around this however.
If the amount of different instantiations of a template is limited,
you can define the class in a source file and manually enumerate through all allowed instantiations in that file. 
This way, when another translation unit uses an instance of a template class,
the linker can link the instance defined in an external translation unit with its usage.</p>
<pre><code class="language-C++">// my_vec.h
template&lt;typename T&gt; 
class MyVec {
    size_t size;
    T * data;
public:
    explicit MyVec(size_t size);
    ~MyVec();
};
</code></pre>
<pre><code class="language-C++">// my_vec.cpp
#include &quot;my_vec.h&quot;

template&lt;typename T&gt;
MyVec&lt;T&gt;::MyVec(size_t size) : size(size), data(new T[size]) {}

MyVec&lt;T&gt;::~MyVec() { delete[] data; }

// Manual instantiations
// full definition avaliable here
template MyVec&lt;int&gt;;

template MyVec&lt;double&gt;;
</code></pre>
<pre><code class="language-C++">// main.cpp
#include &quot;my_vec.h&quot;

// only declaration is available
MyVec&lt;long long&gt; v(100); // ERROR
// no definition available

MyVec&lt;int&gt; mvi(10);
// fine, link with the instantiated template from another
// translational unit

</code></pre>
<p>As we've seen, template arguments can be omitted when the compiler can infer them.</p>
<pre><code class="language-C++">
std::vector vec = {1, 2, 3, 4};
// infers std::vector&lt;int&gt;

template&lt;class T&gt; // the keyword class can also be used, there is no difference at all although class conveys more that you are expecting a class
T add(T a, T b) {
    return a + b;
}

const auto sum = add(100, 200);
// deduces to add&lt;int&gt;(100, 200)
</code></pre>
<p>Notice that <code>add</code> may not work with every type we pass to it. For example if we passed two vectors, we'd get a compiler error. 
However, even with this failure case, <code>add</code> still compiles. 
A template instantiation is not generated unless that instantiation is <em>ODR-used</em> (used in a place where a definition is required, we'll discuss this later). 
Later we'll also see ways to constrain the template arguments because if you did ODR-use an invalid template instantiation you'd likely be greeted with a somewhat cryptic and perhaps very lengthy error message.</p>
<p>Because we use <code>T</code> for the return types and both arguments, all 3 must be exactly the same type. If that wasn't the case, we'd need more type parameters.</p>
<pre><code class="language-C++">template&lt;typename T, typename U, typename ReturnType&gt;
ReturnType add(const T&amp; a, const U&amp; b) {
    return a + b;
}

std::string hello = &quot;Hello&quot;;
auto result = add(hello, 5);
// We'll discuss type deduction later, but this deduces to
// add&lt;std::string, int, std::string&gt;
</code></pre>
<p>We can also have non-type template parameters too. We saw this with <code>std::array</code>.</p>
<pre><code class="language-C++">template&lt;typename T, int N&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream &amp; str, const T (&amp; arr)[N]) {
    str &lt;&lt; &quot;[&quot;;
    for (auto i = 0; i &lt; N - 1; ++i) {
        str &lt;&lt; arr[i] &lt;&lt; &quot;, &quot;;
    }
    if (N &gt;= 1) {
        str &lt;&lt; arr[N - 1];
    }
    str &lt;&lt; &quot;]&quot;;
    return str;

}
// pass by reference to T array of size N

int myArray[] = {1, 2, 3};
std::cout &lt;&lt; myArray;
// &quot;[1, 2, 3]&quot;
</code></pre>
<p>Let's look at another example.</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;optional&gt;

template&lt;typename T&gt;
class LList {
    struct node {
        // fully qualified name is LList&lt;T&gt;::node
        std::shared_ptr&lt;node&gt; next;
        T data;

        node(const T&amp; data) : next(nullptr), data(data) {}
        // T must be copy constructable

        node(const node&amp; other) {
            if (other.next) {
                next = std::make_shared&lt;node&gt;(other);
            }
            else next = nullptr;
            data = other.data;
            // T must be copy assignable
        }
        node() = default;
        // T must be default constructable
    };

    std::shared_ptr&lt;node&gt; first; ///&lt; Invariant: nullptr iff list is empty
    std::weak_ptr&lt;node&gt; last; ///&lt; Invariant: nullptr iff list is empty
public:
    LList() = default;

    LList(const LList&lt;T&gt;&amp; other) : LList() {
        // LList&lt;T&gt; is a type, LList is not
        // we make this copy constructable from lists ONLY of the same type
        *this = other;
    }

    // Deep copy, strong guarantee
    // The default copy would increment the reference count of the pointer (shallow copy)
    // So we'd end up with two linked lists sharing the same data
    LList&amp; operator=(const LList&lt;T&gt;&amp; other) {
        if (other.first) {
            first = std::make_shared&lt;node&gt;(*other.first);
            set_last();
        }
        else {
            first = nullptr;
            last = std::weak_ptr&lt;node&gt;(first);
        }
        return *this;
    }

    LList(LList&lt;T&gt;&amp;&amp;) noexcept = default;
    LList&amp; operator=(LList&lt;T&gt;&amp;&amp;) noexcept = default;

    // Strong
    void push_back(const T&amp; elem) {
        if (!set_first_if_empty(elem)) {
            if (last.expired())
                throw std::runtime_error(&quot;Invariant violated&quot;);
            auto lastNode = last.lock();
            lastNode-&gt;next = std::make_shared&lt;node&gt;(elem);
            last = std::weak_ptr&lt;node&gt;(lastNode-&gt;next); //noexcept
        }
    }
    // Strong guarantee
    void push_front(const T&amp; elem) {
        const auto oldRoot = first;
        first = std::make_shared&lt;node&gt;(elem);
        first-&gt;next = oldRoot; //copying a smart pointer is noexcept
    }

    bool empty() const noexcept {
        return first == nullptr;
        // could have have static_cast first to bool
    }

    std::optional&lt;T&gt; pop_front() noexcept {
        if (first) {
            std::optional result = std::move(first-&gt;data);
            // T must be move constructable
            // safe to move because the reference to data is about
            // to be destroyed
            first = first-&gt;next;
            return result;
        }
        return {};
    }
private:
    /**
    * Creates the first node of the list if the list is empty
    * Strong guarantee
    * @param elem the data for the new first node if created
    * @returns true if elem was set to the new first node, else false
    */
    bool set_first_if_empty(const T&amp; elem) {
        if (!first) {
            first = std::make_shared&lt;node&gt;(elem);
            last = std::weak_ptr&lt;node&gt;(first); // noexcept
            return true;
        }
        return false;
    }

    /**
    * Updates last to reference the last element in the list
    */
    void set_last() noexcept {
        auto n = first;
        auto lastNode = n;
        while (n) {
            lastNode = n;
            n = n-&gt;next;
        }
        last = std::weak_ptr&lt;node&gt;(lastNode);
    }
};

int main() {
    LList&lt;int&gt; stack;
    stack.push_front(10);
    stack.push_front(20);
    std::cout &lt;&lt; stack.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //20
    // value_or uses ref qualifiers to move out the contained value of the optional
    // since we call it on an rvalue
    std::cout &lt;&lt; stack.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //10
    std::cout &lt;&lt; stack.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //-1
    auto queue = stack;
    queue.push_back(100);
    queue.push_back(200);
    std::cout &lt;&lt; queue.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //100
    std::cout &lt;&lt; stack.empty() &lt;&lt; &quot;\n&quot;; //1 (true)
    std::cout &lt;&lt; queue.empty() &lt;&lt; &quot;\n&quot;; //0 (false)
    auto q2 = queue;
    q2.push_back(500);
    std::cout &lt;&lt; q2.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //200
    std::cout &lt;&lt; q2.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //500
    std::cout &lt;&lt; queue.pop_front().value_or(-1) &lt;&lt; &quot;\n&quot;; //200
}
</code></pre>
<p>Notice we make a few subtle assumptions about <code>T</code>. We assume that whatever type is instantiated is copy constructable, copy assignable, move constructable, and default constructable. 
One type that won't satisfy this is a unique pointer for example. What we've done is we assumed a static interface that all elements of our list must adhere to.</p>
<h2 id="one-definition-rule"><a class="header" href="#one-definition-rule">One Definition Rule</a></h2>
<p>Firstly, <em>definitions</em> are <em>declarations</em> that fully define something except for the following cases (and a few more):</p>
<ul>
<li>Function declaration without a body</li>
<li>Declaration with <code>extern</code> that lacks an initial value
<pre><code class="language-C++">extern const int i; // declaration
extern const int j = 5; // definition
</code></pre>
</li>
<li>Non-inline static members in a class
<pre><code class="language-C++">struct S {
    int i; // definition
    static int j; // declaration
    inline static int k; // definition
};

int S::j; // definition
</code></pre>
</li>
<li>Declaration of class without body
<pre><code class="language-C++">class S;
class ReturnType func(class ArgType a);
</code></pre>
</li>
<li>Using and typedef aliases</li>
<li>Template parameters
<pre><code class="language-C++">template&lt;typename T&gt; //T is declared
</code></pre>
</li>
</ul>
<p>Now as the name implies, only one definition of something is allowed in a single translation unit,
and one and only one definition of non-inline functions and variables must exist in a program. 
Finally, one definition of inline functions and variables must be present in every translation unit where they are ODR-used.</p>
<p>Functions are ODR used when somebody makes a call to it or takes its address. Objects are ODR used when its value is read (unless it's a compile-time constant), written, has its address taken, 
or a reference is bound to it. For a reference, it is ODR used when it is not known at compile time. Anything that's ODR used must have a valid definition somewhere in the program.</p>
<p>This was a pretty round about way of basically saying that templates are normally defined in header files and nothing else can be defined in a header file unless it's <code>inline</code> or a non-static member variable.</p>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>We can add an alternative name to types using a type alias. The old way of doing this was through the <code>typedef</code> keyword, but now we can do this with <code>using</code> declarations. 
<code>using</code> declarations may be templates themselves, and they respect access modifiers when declared as part of a class. As I just talked about, type aliases are not definitions.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
using stack_t = LList&lt;T&gt;;

stack_t&lt;int&gt; stack;

class Test {
    using name_t = std::string;

    name_t name;
public:
    using test_t = int;
    name_t getName() const { return stack; }
};

Test::name_t nm; // error, not visible
Test::test_t tt; // good

template&lt;typename T&gt;
using tuple_3 = std::tuple&lt;T, T, T&gt;;

tuple_3&lt;int&gt; tp;
// instead of std::tuple&lt;int, int, int&gt;
</code></pre>
<p>Like defining <code>const</code> or <code>constexpr</code> variables instead of magic values, type aliases provide an opportunity to add documentation via a name for a type and make it easy to replace types. 
For example, let's say that you want to change the stack implementation from using our <code>LList&lt;T&gt;</code> to an <code>std::deque&lt;T&gt;</code>. 
Instead of having to change every reference to the type (return type, parameter type, variable declarations, etc.) you can just change it in one place and be done with it.</p>
<h3 id="possible-exercises-6"><a class="header" href="#possible-exercises-6">Possible Exercises</a></h3>
<ol>
<li>
<p>Make the <code>Ringbuffer</code> class from earlier into a template. Instead of using raw pointers, can you use a <code>std::unique_ptr</code>? (If you were actually implementing this, the best choice would be <code>std::vector</code>). Make sure it's copyable and moveable. Alternatively, make your favorite container with templates.</p>
</li>
<li>
<p>Make the <code>Vec3d</code> class from before into a template which is templated on type to store and number of elements. Define all of the same members as before plus make it copy constructable and assignable from <code>std::array</code>, <code>std::vector</code>, <code>std::initializer_list</code> and really all other list/vector like containers with a single constructor and assignment operator. For a bonus, do the same with a reference to an array (will need a separate overload).</p>
</li>
<li>
<p>What would happen if you casted the integer 300 to a <code>char</code>. What about the float <code>12.4f</code> to a <code>long long</code>. How would the result of the cast compare to the original value? What about if you casted the integer <code>500</code> to a <code>short</code>? How do these scenarios differ? From these ideas, see if you can implement <code>narrow_cast&lt;T, U&gt;</code> which casts the arithmetic type <code>T</code> to the arithmetic type <code>U</code> if the value of the <code>T</code> object can fit in <code>U</code>. This function is part of the GSL (guidelines support library) so an implementation can be found online.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-specialization"><a class="header" href="#template-specialization">Template Specialization</a></h1>
<p>Earlier I talked about how the behavior of <code>std::vector</code> changed when it stores <code>bool</code> and how the behavior of smart pointers change when they point to arrays. 
This is possible due to template specialization, which basically provides a separate definition of a class or function used when a template parameter is a specific type.</p>
<p>Let's start with <em>total template specialization</em> which is when you want unique behavior for a specific combination of template arguments.</p>
<pre><code class="language-C++">template&lt;typename T, typename U&gt;
class Foo {
    // ...
};

template&lt;&gt;
class Foo&lt;int, long&gt; {
    // ...
};

Foo&lt;int, int&gt;; // first
Foo&lt;long, int&gt;; // first
Foo&lt;std::string, Person&gt;; // first
Foo&lt;int, long&gt;; // second
</code></pre>
<p>A specialization does not automatically share the interface of the main definition (like for example public inheritance) and the interface for a template specialization may be completely different. 
However, in most cases where you use this, you'll probably find it most useful if the specialization and template class mostly share an interface.</p>
<p>Here's a more useful example. Let's say you had two classes, <code>Address</code> and <code>Person</code>, and to have a hash map with <code>Address</code> keys and <code>Person</code> values. 
You could manually add a <code>hash()</code> member function and key the map on that hash type, but then you'd have to manually ensure that <code>hash()</code> doesn't create collisions. 
Plus, you'd be doing extra computation as <code>std::unordered_map</code> would then hash that key again. Instead, we can specialize <code>std::hash</code> which is a <code>struct</code> that uses <code>operator()</code> to compute the hash.</p>
<pre><code class="language-C++">struct Address {
    int zipCode, streetNumber;
    short state;
    std::string city, street;

    bool operator==(const Address&amp; other) const {
        // ...
    }
};

class Person {
    // ...
};

namespace std {
    // std::hash is part of the std namespace so we must
    // put the specialization in that namespace as well

    // normally you shouldn't modify the std namespace
    // but this is an example that's ok

    template&lt;&gt;
    struct hash&lt;Address&gt; {

        size_t operator()(const Address&amp; addr) const {
            const static std::hash&lt;int&gt; iHash;
            const static std::hash&lt;short&gt; sHash;
            const static std::hash&lt;string&gt; strHash;

            return iHash(zipCode) ^ iHash(streetNumber) ^
                sHash(state) ^ strHash(city) ^ strHash(street);
            // not much though went into this example hash function
        }
    };
}

std::unordered_map&lt;Address, Person&gt;; // good!
</code></pre>
<p>Functions may be specialized as well. However, generally, it's best to avoid specialization and prefer overloading the function unless you really need to specialize it. 
One scenario where you would need specialization is to have functions that differ in only their return type. This is because you cannot create overloads based on return type alone.</p>
<pre><code class="language-C++">template&lt;typename T, typename U&gt;
void foo(const T&amp; t, const U&amp; u) {
    // ...
}

template&lt;&gt;
void foo&lt;int, int&gt;(const int&amp; t, const int&amp; u) {

}
</code></pre>
<p>During name resolution, the compiler will first pick the best overload, then pick the best specialization. 
This can lead to confusing results because a better match created by specializing a worse matching overload won't be picked over a decent matching overload.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
void foo(T f) {
    // ...
}

template&lt;&gt; foo&lt;int*&gt;(int* f) {} // specialize foo&lt;T&gt;

template&lt;typename T&gt;
void foo(T* f) {} // overload

foo(new int()); // calls foo(T*) not foo&lt;T&gt; specialization
// chooses best overload, then looks for specialization (which there are none)
</code></pre>
<p>However, changing the definition order so that the specialization specializes the second <code>foo</code> makes it work as expected.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
void foo(T f) {
    // ...
}

template&lt;typename T&gt;
void foo(T* f) {} // overload

template&lt;&gt; foo&lt;int*&gt;(int* f) {} // specialize foo&lt;T*&gt;

foo(new int()); // calls specialization
// chooses the T* overload since its a better match
// then sees the int* specialization
</code></pre>
<p>Classes don't overload. However, what we can do with classes (and not functions) is <em>partial template specialization</em>. 
Using this, we can create a specialization that is used when some, but not all template arguments match, or create specializations on other template types.</p>
<pre><code class="language-C++">template&lt;typename T, typename U&gt;
class Foo {

};

template&lt;typename T&gt;
class Foo&lt;T, std::string&gt; {

};

template&lt;typename T, typename U&gt;
class Foo&lt;std::unique_ptr&lt;T&gt;, U&gt; {

};

Foo&lt;int, int&gt;; // #1
Foo&lt;int, std::string&gt;; //#2
Foo&lt;std::unique_ptr&lt;std::string&gt;, long&gt;; //#3
Foo&lt;std::unique_ptr&lt;int&gt;, std::string&gt;; // error, ambiguous specialization. Could be 2 or 3
</code></pre>
<p>You can inherit from templates and specialization as well. When inheriting from a template, you must use the <code>this</code> pointer to refer to the base class's members.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
class Foo : private std::vector&lt;T&gt; {
    // ...

    Foo() {
        emplace_back(); // error
        this-&gt;emplace_back(); // good
    }
};
</code></pre>
<h3 id="possible-exercises-7"><a class="header" href="#possible-exercises-7">Possible Exercises</a></h3>
<ol>
<li>
<p>Specialize the <code>Ringbuffer</code> class so that when used with <code>bool</code>, it only takes up one bit per element.</p>
</li>
<li>
<p>Make the vector template from previous exercises hashable.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts-and-type-traits"><a class="header" href="#concepts-and-type-traits">Concepts and Type Traits</a></h1>
<p>In C++20, concepts and constraints are a direct language feature.
However, the idea of a concept has long existed before then. Consider the following function:</p>
<pre><code class="language-C++">template&lt;typename T, typename U&gt;
U sum(const T&amp; container, U initialValue) {
    // another example of making the compiler do the copy for us
    for(auto e : container) {
        initialValue += e;
    }
    return initialValue;
}
</code></pre>
<p>What is required from <code>T</code> and <code>U</code>? Well <code>U</code> needs to define <code>operator+=</code>, and that operator must take a <code>U</code> as the first parameter and whatever type is returned from dereferencing an iterator to <code>T</code>. 
<code>T</code> must be iterable by defining a <code>begin()</code> and <code>end()</code> function and that iterator must return a type that is implicitly convertible to <code>U</code> or <code>U</code> must provide an overload of <code>operator+=</code> 
so that it takes whatever is &quot;contained&quot; in <code>T</code>. These requirements form the <em>concepts</em> that <code>T</code> and <code>U</code> must implement.</p>
<p>Templates allow for generic programming and <em>parametric polymorphism</em>, which allows a single code implementation to be used with multiple classes.</p>
<p>Earlier I discussed how the types passed to our <code>LList&lt;T&gt;</code> class needed to be default constructable and copyable. 
These are two major criteria for the <em>Regular</em> concept which among being default constructable and copyable also needs to be comparable with <code>==</code> and <code>!=</code>.</p>
<p>The <code>type_traits</code> header provides many helpers to query types or the adherence of a type to a certain quality. 
Traits that end in <code>_v</code> &quot;return&quot; values, and those that end in <code>_t</code> &quot;return&quot; types. 
These &quot;helpers&quot; are not actually functions but rather template <code>constexpr</code> variables or type aliases in <code>struct</code>s. Therefore, the results of these queries are available at compile time.</p>
<pre><code class="language-C++">std::is_default_constructable_v&lt;std::string&gt;; // true
// is_default_constructable is a template struct
// so the above is shorthand for:
std::is_default_constructable&lt;std::string&gt;::value;

std::is_fundamental_v&lt;char&gt;; // true
std::is_arithmetic_v&lt;int&gt;; // true
std::is_same_v&lt;int, const int&gt;; // false
std::is_floating_point_v&lt;long long&gt;; // false
std::is_signed_v&lt;unsigned&gt;; // false

std::rank_v&lt;int(&amp;)[3]&gt;; // 1 - dimensions of array type

std::is_base_of_v&lt;Base, Derived&gt;; // true

using typ = std::remove_cv_t&lt;const bool&gt;; // bool
// once again, shorthand for
std::remove_cv&lt;const bool&gt;::type;

enum class myEnum {}
std::underlying_type_t&lt;myEnum&gt;; // int
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/header/type_traits">cppreference</a> has a list of all of them.
Now how do these work? I won't explain the full story just yet, but they can use template specialization behind the scenes.
Let's create a simple <code>is_bool</code> type trait.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
struct is_bool {
    inline constexpr static auto value = false;
    // inline so redefinitions are allowed in a program
};

template&lt;&gt;
struct is_bool&lt;bool&gt; {
    inline constexpr static auto value = true;
};

template&lt;typename T&gt;
inline constexpr auto is_bool_v = is_bool&lt;T&gt;::value;
</code></pre>
<p><code>is_bool</code> is specialized so that when <code>T</code> is <code>bool</code> its <code>value</code> member will be true. Now what about <code>const bool</code> or <code>bool&amp;</code> or <code>const bool&amp;</code>? 
Since these are distinct types from <code>bool</code>, they'll fall into the unspecialized version of <code>is_bool</code> and <code>value</code> will be false. 
One solution would be to pass the argument into <code>std::remove_reference_t</code> and <code>std::remove_cv_t</code> prior to passing it to <code>is_bool_v</code>.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
using strip_t = std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;;
// order matters here, remove_cv removes the top level const and volatile qualifiers

remove_cv_t&lt;int * const volatile&gt;; // int* because const and volatile apply to the pointer
remove_cv_t&lt;const volatile int *&gt;; // const volatile int * because const and volatile apply to the data

is_bool_v&lt;strip_t&lt;const bool &amp;&gt;&gt;; // true
is_bool_v&lt;const bool&gt;; // false

template&lt;typename T&gt;
inline constexpr auto is_bool2_v = std::is_same_v&lt;T, bool&gt;;
</code></pre>
<p>There's a bunch more type traits in the STL that can be found <a href="https://en.cppreference.com/w/cpp/header/type_traits">here</a>. 
Now that we have these traits, the most basic approach to enforcing adherence of template parameters to a concept is with <code>static_cast</code>.</p>
<pre><code class="language-C++">template&lt;typename T, typename U, typename V&gt;
V sum(T a, U b) {
    static_cast(std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;,
        &quot;Sum passed non arithmetic types&quot;);
    return a + b;
}
</code></pre>
<p>This incurs no runtime penalty since the check happens during compilation.</p>
<p>A better approach is to use <code>std::enable_if_t</code>. As the name might suggest, the main usage of this is to conditionally enable functions. 
How this works is by replacing the entire statement with the second template type parameter
if the first template parameter evaluates to a true condition at compile time. 
Then you can specify the return type of the function to be an <code>enable_if_t</code> expression. 
If the function is called with template parameters that make the condition true, all is well since the return type will be the second template argument to
<code>std::enable_if_t</code>. Otherwise, the <code>enable_if</code> effectively prevents the instantiation of the function template causing the compiler to complain that the function doesn't exist. 
Not as clear as an error message as you'd get in C++ 20 with concepts and constraints, but trust me it's far nicer than some monstrosities you might receive without it.
You can omit the second type parameter to <code>enable_if</code>, in that case it defaults to <code>void</code>.</p>
<p>The default type for the second template argument is <code>void</code>. </p>
<pre><code class="language-C++">template&lt;typename T, typename U&gt;
constexpr inline auto are_arithmetic_v = std::is_arithmetic_v&lt;strip_t&lt;T&gt;&gt; &amp;&amp; 
    std::is_arithmetic_v&lt;strip_t&lt;U&gt;&gt;;

template&lt;typename T, typename U, typename V&gt;
std::enable_if_t&lt;are_arithmetic_v&lt;T, U&gt;, V&gt;
sum(T a, U b) {
    return a + b;
}
// sum returns type V if `are_arithmetic_v&lt;T, U&gt;` is true


// same thing with trailing return type
template&lt;typename T, typename U, typename V&gt;
auto sum2(T a, U b) -&gt; std::enable_if_t&lt;are_arithmetic_v&lt;T, U&gt;, V&gt;
{
    return a + b;
}
/*
This is not type deduction, the auto doesn't mean auto like normal
but instead its syntax for trailing return type
the return type of the function is specified after it using a -&gt;
allows the parameters to be used in the return type
*/
</code></pre>
<p>A trailing return type is most useful with <code>decltype()</code> which &quot;returns&quot; the type of the expression passed to it. 
The expression passed is not evaluated, but instead the compiler figures out what the type of the expression is and replaces the <code>decltype</code>
expression with this type during compilation. 
Thus, it incurs no runtime penalty.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
auto getIter(const T&amp; container) -&gt; decltype(container.begin()) {
    return container.begin();
}
// Of course the trailing return type here isn't necessary

template&lt;typename T&gt;
auto getIter(const T&amp; container) {
    decltype(*container.begin()) acc = 0;
    // auto will deduce to int, but we want the type to be whatever container holds
    for (e : container) {
        acc += e;
    }
    return acc;
}
</code></pre>
<p>So how does all this work? By a language feature known as <em>SFINAE</em> which stands for specialization failure is not an error. 
Basically, if instantiating a template causes an error, the compiler will look for another template specialization.
If no other template is found, it complains that it can't find the class or function.</p>
<p>I think it's best to start with an example.</p>
<pre><code class="language-C++">template&lt;typename T, typename = void&gt;
struct SFINAE : std::false_type {};
// primary definition
// 2 template arguments, the second is unnamed and defaulted to void

template&lt;typename T&gt;
struct SFINAE&lt;T, std::void_t&lt;typename T::type&gt;&gt; : std::true_type {}; 
// 1 template argument specialization
// instantiates if T has a member type alias called type

enum e {};

static_assert(SFINAE&lt;std::underlying_type&lt;e&gt;&gt;::value); 
//good (second declaration) bc std::underlying_type&lt;e&gt; has a type alias called type

static_assert(SFINAE&lt;std::string&gt;::value); 
// error (first declaration) bc std::string does not have an alias type
</code></pre>
<p>Let's walk this through. First we create our default struct which inherits <code>false_type</code> so that it has a constant member <code>value</code> that is false. 
This is the primary definition. The <code>typename = void</code> is somewhat odd, but all it's doing is creating a template with two parameters,
where the second one is unnamed and defaults to <code>void</code>. 
This allows code to reach this version of the struct <code>SFINAE</code> if the specialization fails. Then we create a specialization. 
The specialization subtypes <code>std::true_type</code> to get a <code>constexpr</code> member <code>value</code> that's true.</p>
<p>For the second template argument of the specialization, we pass <code>T::type</code> to <code>std::void_t</code>. 
If the type arguments of <code>std::void_t</code> (multiple can be passed) are valid, <code>std::void_t</code> is substituted with <code>void</code>. 
If it isn't, then specialization fails. We need the <code>typename</code> keyword whenever we are accessing a type alias which is part of a template type. </p>
<pre><code class="language-C++">struct MyStruct {
    using name = int;
};

template&lt;typename T&gt;
auto test() {
    typename T::type t_type; // accessing alias of template parameter, need typename keyword
    typename std::vector&lt;T&gt;::iterator it; // std::vector&lt;T&gt; is a template, need typename keyword
    std::vector&lt;int&gt;::iterator it2; // no keyword needed
    MyStruct::name i; // also no keyword
}
</code></pre>
<p>So if <code>T</code> contains a type alias called <code>type</code>, then <code>std::void_t</code> will be substituted with <code>void</code> and the specialization will succeed. 
Otherwise, the specialization fails, and the next best specialization is chosen. 
When we use these structs, we'll only pass 1 type parameter. 
Thus, the compiler will first try to instantiate the better matching specialization (1 template parameter) before trying to instantiate the next best match (2 template parameters with one of them defaulted).</p>
<pre><code class="language-C++">template&lt;typename T, typename = void&gt;
struct IsThreadDestructionPolicy : std::false_type {};

template&lt;typename T&gt;
struct IsThreadDestructionPolicy&lt;T,
	std::void_t&lt;
        decltype(T::onThreadDestroy(std::declval&lt;std::thread&amp;&gt;()))
    &gt;&gt; : std::true_type {};
</code></pre>
<p>Think of <code>std::void_t&lt;... Ts&gt;</code> as &quot;try to instantiate&quot; the following types. In actuality, <code>void_t</code> is a usage of SFINAE itself. 
In this example, what we try to instantiate is the return type of the function <code>onThreadDestroy</code>. It's static and takes a reference to a thread. 
In order to get the proper function signature, we must somehow &quot;construct&quot; an object of the type it expects and pass this object to it at compile time. 
That's basically what <code>std::declval&lt;T&gt;()</code> does. <code>std::declval</code> cannot be ODR-used, so it is only applicable in unevaluated contexts such as template arguments. 
Note that to get a reference of <code>T</code>, like we need here, you must explicitly request it by putting an <code>&amp;</code> in the brackets. 
<code>Sizeof()</code> is another unevaluated context: it does not actually evaluate whatever expression you pass to is.</p>
<p>Now what if for some type <code>T</code>, it doesn't have the function <code>onThreadDestroy</code>? 
Well, we get a specialization failure, and by the name of SFINAE this does not halt compilation, rather it just goes on to the next possible instantiation which is the struct that inherits from <code>false_type</code>. 
This is why our primary definition needed that second parameter. We need a parameter to put the <code>std::void_t</code> to see if we can resolve a correct type. 
If we can't, because this second parameter is defaulted, the compiler will then choose the less restricting primary definition of the struct. 
It won't choose this first, because our users will only supply one type parameter, and a specialization taking one parameter will be chosen over one in which it takes a second, defaulted argument.</p>
<p>Let's create a struct to check if a type implements an iterable concept. We'll check the type has <code>begin()</code> and <code>end()</code> member functions and that whatever returned from those functions is
incrementable, dereferenceable, and comparable with <code>==</code> and <code>!=</code>. As we'll soon see, there's a better way to check if a type is an interator, and these requirements don't even cover all our bases.</p>
<pre><code class="language-C++">template&lt;typename T, typename = void&gt;
struct IsIterable : std::false_type {};

template&lt;typename T&gt;
using iter_t = decltype(std::declval&lt;T&amp;&gt;().begin());

template&lt;typename T&gt;
struct IsIterable&lt;T, std::void_t&lt;
        decltype(std::declval&lt;T&gt;().begin()),
        decltype(std::declval&lt;T&gt;().end()),
        decltype(*std::declval&lt;iter_t&lt;T&gt;&gt;()),
        decltype(++std::declval&lt;iter_t&lt;T&gt;&gt;()),
        decltype(std::declval&lt;iter_t&lt;T&gt;&gt;()++),
        decltype(std::declval&lt;iter_t&lt;T&gt;&gt;() == std::declval&lt;iter_t&lt;T&gt;&gt;()),
        decltype(std::declval&lt;iter_t&lt;T&gt;&gt;() != std::declval&lt;iter_t&lt;T&gt;&gt;()),
    &gt;&gt; : std::true_type {};

template&lt;typename T&gt;
constexpr inline auto is_iterable_v = IsIterable&lt;T&gt;::value 
    &amp;&amp; std::is_default_constructible_v&lt;iter_t&lt;T&gt;&gt;
    &amp;&amp; std::is_copy_constructible_v&lt;iter_t&lt;T&gt;&gt; 
    &amp;&amp; std::is_copy_assignable_v&lt;iter_t&lt;T&gt;&gt;
    &amp;&amp; std::is_swappable_v&lt;iter_t&lt;T&gt;&gt;;

template&lt;typename T&gt;
auto printContainer(const T&amp; container) -&gt; std::enable_if_t&lt;is_iterable_v&lt;T&gt;&gt;
{
    std::cout &lt;&lt; &quot;[&quot;;
    for (auto e : container) {
        std::cout &lt;&lt; e &lt;&lt; &quot;, &quot;;
    }
    std::cout &lt;&lt; &quot;]\n&quot;;
}

const std::vector v = {10, 20, 30, 40};
const std::string s = &quot;Hello World&quot;;
const char * str = &quot;Hiya&quot;;

printContainer(v);
printContainer(s);
printContainer(str); // error!
</code></pre>
<p>Why is this useful? Well, try uncommenting the trailing return type with <code>enable_if_t</code> and calling <code>printContainer(100)</code>. 
See what error message you get. Trust me it gets way worse when there's nested template functions used in multiple source files across a project that has thousands of lines of code. 
In Visual Studio, the linter will also be able to pick up on violating <code>enable_if</code> the second you type the function call.</p>
<p>Here's another example</p>
<pre><code class="language-C++">template&lt;typename T, typename = void&gt;
struct IsThreadInterruptionPolicy 
: std::false_type {};

template&lt;typename T&gt;
struct IsThreadInterruptionPolicy&lt;T,
    std::enable_if_t&lt;
        std::is_same_v&lt;T, InterruptableThreadPolicy&gt; || 
        std::is_same_v&lt;T, UninterruptableThreadPolicy&gt;
    &gt;&gt;
    : std::true_type {};
</code></pre>
<p>Here we use <code>std::enable_if</code> which is a struct that defines a member <code>type</code> if the first template parameter is true. 
If the first argument to <code>enable_if</code> is <code>false</code>, then it doesn't have a member alias named <code>type</code> and the specialization will fail. 
<code>std::enable_if</code>and <code>std::void_t</code> work very similarly, the difference is <code>enable_if</code> takes a boolean or boolean expression while <code>std::void_t</code> takes a type or list of types. 
Instead of having to type <code>typename std::enable_if&lt;/*...*/&gt;::type</code> or <code>typename std::void&lt;/*...*/&gt;::type</code> we use <code>std::enable_if_t</code> and <code>std::void_t</code> respectively. 
Of course in C++17 this whole example can simply be written as:</p>
<pre><code class="language-C++">template&lt;typename T&gt;
constexpr inline auto is_thread_interruptable_policy_v = 
    std::is_same_v&lt;T, InterruptableThreadPolicy&gt; || 
    std::is_same_v&lt;T, UninterruptableThreadPolicy&gt;;
</code></pre>
<p>Let's see another example of SFINAE. Here it's used to ensure that only certain types are passed and to get a friendlier compiler error if these conditions are violated. </p>
<pre><code class="language-C++">/**
* Enables a function at compile time if all 
* the type parameters are integral types or vectors
* @param &lt;T&gt; typename to check if it is an integer or 
* vector type
* @param &lt;ReturnType&gt; defaults to std::vector&lt;uint8_t&gt;, 
*   the return type of the function if enabled
*/
template&lt;typename T, 
typename ReturnType = std::vector&lt;uint8_t&gt;&gt;
using requires_int_or_vec = std::enable_if_t&lt;
    is_int_or_vector&lt;strip_t&lt;T&gt;&gt;::value, ReturnType&gt;;



template&lt;typename T&gt;
static constexpr auto convertToByteArray(const std::initializer_list&lt;T&gt;&amp; numArray) 
    -&gt; requires_int_or_vec&lt;T&gt; 
{
    std::vector&lt;uint8_t&gt; ret;
    ret.reserve(numArray.size() * sizeof(T));
    for (auto&amp; v : numArray) {
        const std::vector&lt;uint8_t&gt; subArray 
            = convertToByteArray(v);
        ret.insert(ret.end(),
            subArray.begin(), subArray.end());
    }
    return ret;
}
</code></pre>
<p>This will only compile if <code>T</code> is an int or vector/array like type. <code>is_int_or_vector</code> is a custom struct defined using SFINAE similar to my earlier example.</p>
<p>If C++ 20 is available to you, use C++ 20 concepts and <code>requires</code> clauses.</p>
<p>Let's recap:</p>
<ul>
<li><code>decltype</code> - gets the type of whatever expression is passed to it. Like <code>sizeof</code>, the expression passed is not actually evaluated but simply used for the compiler to figure out the type of said expression.</li>
<li><code>std::declval&lt;T&gt;</code> - creates a &quot;proto&quot; <code>T</code> object that can be used in unevaluated contexts like <code>decltype</code>. Allows us to &quot;call&quot; member functions or functions taking a <code>T</code> in such unevaluated contexts. 
<code>T</code> need not be default constructable. If you needed <code>T</code> to be default constructable as well, you could use <code>T()</code>, however this would always return a prvalue.</li>
<li><code>std::void_t&lt;T, ...&gt;</code> - if all the types passed as template arguments are valid, substitutes the entire expression with <code>void</code>. 
Otherwise, it fails to instantiate causing whatever template specialization it's used in to also fail to instantiate.</li>
<li><code>std::enable_if_t&lt;Condition, Type&gt;</code> - if <code>Condition</code> is true, substitutes the entire expression for <code>Type</code>. 
Otherwise, it fails to instantiate causing whatever function it's used in to also fail to instantiate. 
<code>Type</code> defaults to <code>void</code> if it's not specified.</li>
</ul>
<p>Let's look at one final example from our <code>sum</code> function we motivated this section with. This will build on the <code>IsIterable</code> example:</p>
<pre><code class="language-C++">/*
Original Function:

    template&lt;typename T, typename U&gt;
    U sum(const T&amp; container, U initialValue) {
        for(auto e : container) {
            initialValue += e;
        }
        return initialValue;
    }
*/

template&lt;typename T, typename U, typename = void&gt;
struct IsSummable : std::false_type {};

template&lt;typename T, typename U&gt;
struct IsSummable&lt;T, U, std::void_t&lt;
    decltype(std::declval&lt;T&amp;&gt;() += std::declval&lt;U&gt;()),
    decltype(std::declval&lt;U&amp;&gt;() += std::declval&lt;T&gt;()),
    decltype(std::declval&lt;T&gt;() + std::declval&lt;U&gt;()),
    decltype(std::declval&lt;U&gt;() + std::declval&lt;T&gt;()),
&gt;&gt; : std::true_type {};

template&lt;typename Container, typename Acc&gt;
constexpr inline auto is_vector_summable_v = is_iterable_v&lt;Container&gt; &amp;&amp;
    IsSummable&lt;decltype(*std::declval&lt;iter_t&lt;Container&gt;&gt;()), Acc&gt;::value;


template&lt;typename T, typename U&gt;
auto sum(const T&amp; container, U initialValue) 
    -&gt; std::enable_if_t&lt;is_vector_summable_v&lt;T, U&gt;, U&gt; 
{
    for(auto e : container) {
        initialValue += e;
    }
    return initialValue;
}
</code></pre>
<h3 id="possible-exercises-8"><a class="header" href="#possible-exercises-8">Possible Exercises</a></h3>
<ol>
<li>Use SFINAE to ensure that the previous template classes are protected from misuse.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forwarding"><a class="header" href="#forwarding">Forwarding</a></h1>
<p>There's one type of reference we haven't looked at yet. And that's the universal, aka forwarding, reference. 
It's not exactly its own type of reference, but rather it can bind to both rvalues and lvalues and is formed like <code>T&amp;&amp;</code> where <code>T</code> is some template parameter. 
A universal reference cannot have qualifiers or other type adornments. For example <code>const T&amp;&amp;</code> is a const rvalue reference to <code>T</code> and <strong>not</strong> a <code>const</code> universal reference. </p>
<p>For example, the following are rvalue references, not universal references:</p>
<ul>
<li><code>const T&amp;&amp;</code></li>
<li><code>std::vector&lt;T&gt;&amp;&amp;</code></li>
<li><code>volatile T&amp;&amp;</code></li>
<li><code>T*&amp;&amp;</code></li>
</ul>
<p>We can use universal references to create a function which works for both rvalue and lvalue references. This is possible with the help of <code>std::forward&lt;T&gt;</code>. 
<code>std::forward</code> is similar to <code>std::move</code> except <code>std::forward</code> conditionally casts the argument to <code>T&amp;&amp;</code> while move always casts its argument to <code>T&amp;&amp;</code>. 
<code>std::forward</code> will cast its argument to <code>T&amp;&amp;</code> if it's a rvalue reference otherwise it keeps it as a lvalue reference. 
This allows function that use a forwarding reference to take advantage of move semantics when they can.</p>
<pre><code class="language-C++">
template&lt;typename T&gt;
struct Node {
    T data;
    std::unique_ptr&lt;Node&lt;T&gt;&gt; next;

    explicit Node(T&amp;&amp; data) : data(std::forward&lt;T&gt;(data)), next(nullptr) {}
}

auto n = Node&lt;std::string&gt;(&quot;Hello World&quot;);
// const char * is passed by lvalue reference to Node(T&amp;&amp;)
// const char * used to construct std::string

auto n2 = Node&lt;std::string&gt;(n.data);
// lvalue reference passed to Node(T&amp;&amp;)
// copy constructor used to copy data

auto n3 = Node&lt;std::string&gt;(std::move(n2.data));
// rvalue references passed to Node(T&amp;&amp;)
// n3.data is move constructed from n2.data

auto getString() {
    return std::string(&quot;Hiya&quot;);
}


auto n4 = Node&lt;std::string&gt;(getString());
// move construct data
</code></pre>
<p>Notice that <code>std::forward</code> requires the base type to be specified as a template argument while <code>std::move</code> does not.</p>
<p>Overloading a function that takes a universal reference is a pretty tricky area and should be avoided. 
This is because universal references will be perfect matches for almost anything. 
You can circumvent some of these issues by using <code>std::enable_if</code> to limit the bindings on the function or use <em>tag dispatch</em> which is a technique we'll discuss later.</p>
<p>There are a few cases where forwarding can fail:</p>
<ul>
<li>Passing a brace initializer to a template. This fails because the compiler can't know if this is constructing some type or if it's a <code>std::initializer_list</code></li>
<li>Passing the C <code>NULL</code> macro. This is a macro for <code>0</code> and thus the type deduced will be <code>int</code>, not a pointer. This is why we use <code>nullptr</code>.</li>
<li>Passing a function pointer that has overloads. The compiler can't tell which overload you mean to use.</li>
<li>Passing bitfields, which cannot be taken by non-const reference.</li>
</ul>
<p>Forwarding is how functions like <code>std::make_unique</code> are created. 
There's still 1 other language feature used to allow passing an arbitrary amount of arguments, but a single argument version might look something like this:</p>
<pre><code class="language-C++">template&lt;typename T, typename U&gt;
auto make_unique_simple(U&amp;&amp; u) {


    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;U&gt;(u)));
}
</code></pre>
<p>As you can see, universal references are a template parameter. 
Which means functions using them pretty much have to be defined in a header file. 
Plus, what we'll end up with in the compiled code is a separate function for every type of parameter passed to it. This can lead to bloat in the size of the executable. 
Is there another option? Well, don't forget about passing by value. Lvalues will by copy constructed and rvalues will be move constructed. 
Then you can unconditionally move the argument since it was copied/moved. This isn't always the best choice, but it is <em>a</em> choice. 
Finally, you can also implement the rvalue reference function in terms of the lvalue reference function.</p>
<p>Finally, I'd like to just clarify that <code>std::move</code> should be used for rvalue references and <code>std::forward</code> for universal references.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-deduction"><a class="header" href="#type-deduction">Type Deduction</a></h1>
<p>If you have been following the advice of Herb Sutter to almost always use auto, then you will have had much experience with type deduction. 
For the most part, type deduction just works as you'd expect, but there are cases where things might snag you.</p>
<p>Here is my template for the following explanation:</p>
<pre><code class="language-C++">template&lt;typename T&gt;
void fun(ParamType t);

fun(expr);

</code></pre>
<p>In the following explanation, I will refer to <code>expr</code> as the expression passed to the function. <code>T</code> as the deduced type of the function, and <code>ParamType</code> 
as the adorned type used as the argument for the function. For example:</p>
<pre><code class="language-C++">template&lt;typename T&gt;
void fun(const T&amp; t);

fun(10);
</code></pre>
<p><code>expr</code> is <code>10</code> which has a type of <code>int</code>, <code>ParamType</code> is <code>const T&amp;</code>, and <code>T</code> will be deduced to <code>int</code>.</p>
<p>Type Deduction Rules:</p>
<ul>
<li>Modifiers specified in <code>ParamType</code> are lost by the type deduction of <code>T</code>
<ul>
<li>So if <code>ParamType</code> is <code>T&amp;</code>, any lvalue references passed in to the function will have a deduced type which doesn't include the reference. So passing in <code>const int&amp;</code>, <code>T</code> will be <code>const int</code>. 
In this example, rvalue references would not be able to be bound.</li>
<li>If <code>ParamType</code> is <code>const T&amp;</code>, then passing in a <code>const int</code>, <code>T</code> will be deduced to be <code>int</code>, not <code>const int</code></li>
</ul>
</li>
<li>If <code>expr</code> is a reference, the reference part is ignored</li>
<li>If <code>ParamType</code> is a universal reference and <code>expr</code> is a lvalue then <code>T</code> is deduced to be an lvalue references. <strong>This is the only time type deduction deduces a reference</strong></li>
<li>If <code>ParamType</code> is just <code>T</code> (pass-by-value) constness, referenceness, and volatility is ignored.</li>
<li>If <code>ParamType</code> is a reference, and <code>expr</code> is an array, then <code>T</code> deduces the array's type. It doesn't decay into a pointer like normal. This applies to function pointers as well</li>
</ul>
<p><code>auto</code> type deduction mostly follows the same rules as above. You can think of <code>auto</code> as the <code>T</code> in template type deduction. 
One caveat is while template type deduction cannot deduce braces, <code>auto</code> type deduction can, and it will deduce as <code>std::initializer_list</code>. 
A function that returns <code>auto</code> follows template type deduction rules, not <code>auto</code> type deduction rules.</p>
<p>The best way to understand this is with examples:</p>
<pre><code class="language-C++">// When I saw 'T is', I mean to say that 'T is replaced by'
void foo(T t);
void bar(const T&amp; t);
void func(T&amp;&amp;);

std::vector&lt;double&gt; d;
const int c;
volatile bool b;
foo(5); //T is int
foo(c); //T is int

bar(c); //T is int
bar(5); //T is int
bar(b); //T is volatile bool
bar(d); //T is std::vector&lt;double&gt;

func(c); //T is const int&amp;
func(d); //T is std::vector&lt;double&gt;&amp;
func(55); //T is int

bar(std::string(&quot;...&quot;)); // error, cannot bind to rvalue reference
</code></pre>
<pre><code class="language-C++">// Once again when I say &quot;auto becomes&quot;, I mean to say that &quot;auto is replaced by&quot; as if
// auto was &quot;T&quot; in the above example

std::vector&lt;double&gt; d;
const int c;
volatile bool b;

auto&amp; f = c; //auto becomes const int
auto&amp;&amp; d2 = d; //auto becomes std::vector&lt;double&gt;&amp;
// auto&amp;&amp; is a universal reference

const auto v = b; //auto becomes bool
const auto&amp; v2 = b; //auto becomes volatile bool
//when I mean &quot;auto becomes&quot; I essentially 
//mean it's as if you typed this:
const volatile bool&amp; v2 = b;

auto initList = {10, 20, 30, 40}; //std::initializer_list&lt;int&gt;
std::vector v = {10, 20, 30, 40}; //std::vector&lt;int&gt;
auto vec = std::vector{10, 20, 30, 40};

auto&amp; v2 = v;
// auto becomes std::vector&lt;int&gt;
// so v2 is an std::vector&lt;int&gt;&amp;
</code></pre>
<p>The <code>decltype</code> rules are very simple. 
It produces the exact type of the expression passed.
We can use <code>decltype</code> rules in place of <code>auto</code> or template rules for variables and return values with the syntax <code>decltype(auto)</code>.</p>
<pre><code class="language-C++">auto operator[](int index) {
    return c[index];
    // template type deduction rules
    // since auto lacks any reference, it is returned by-value
    // so we can't use operator[] to assign values
}

auto&amp; operator[](int index) {
    return c[index];
    // returns lvalue reference
}

auto&amp;&amp; operator[](int index) {
    return c[index];
    // returns lvalue reference
    // auto&amp;&amp; is a universal reference
}

decltype(auto) operator[](int index) {
    return c[index];
    // returns lvalue reference
    // return type of operator[] is an lvalue reference
}


int c = 100;
auto d = c; // auto is int
decltype(c) d = c; // type is int
decltype(auto) e = c; // type is int

int&amp; get(int &amp; i) {
    return i;
}

auto f = get(c); // auto is int
decltype(auto) g = get(c); // type is int&amp;

int i;
int&amp;&amp; f();


auto x3a = i;                  // decltype(x3a) is int
decltype(auto) x3d = i;        // decltype(x3d) is int
auto x4a = (i);                // decltype(x4a) is int
decltype(auto) x4d = (i);      // decltype(x4d) is int&amp;
auto x5a = f();                // decltype(x5a) is int
decltype(auto) x5d = f();      // decltype(x5d) is int&amp;&amp;
auto x6a = { 1, 2 };           // decltype(x6a) is std::initializer_list&lt;int&gt;
decltype(auto) x6d = { 1, 2 }; // error, { 1, 2 } is not an expression (only auto deduces braces to initializer list)
auto *x7a = &amp;i;                // decltype(x7a) is int*
decltype(auto)*x7d = &amp;i;       // error, declared type is not plain decltype(auto)
</code></pre>
<p>So with this knowledge, let's look at the following example:</p>
<pre><code class="language-C++">template&lt;typename T&gt;
auto make_unique_cpy(T&amp;&amp; t) {
    using Type = std::remove_reference_t&lt;T&gt;; 
    
    return std::unique_ptr&lt;Type&gt;(new Type(std::forward&lt;T&gt;(t)));
}
</code></pre>
<p>If a lvalue is passed to <code>make_unique_simple</code>, then <code>T</code> will be deduced to a lvalue reference. 
Since we can't create a pointer to a reference, we must use <code>std::remove_reference_t</code> to ensure that the type being passed to <code>unique_ptr</code>
and <code>new</code> is not a reference.</p>
<p>During type deduction, there may be cases where a reference to a reference is produced.
Since such double references are illegal, the compiler follows the rules of <em>reference collapsing</em> to produce a single reference. 
This can occur when using <code>decltype</code>, type aliases, or during type deduction, for example. When a reference to a reference is produced:</p>
<ul>
<li>If either references is a lvalue references, the result is a lvalue reference</li>
<li>Otherwise, the expression collapses to a rvalue reference.</li>
</ul>
<pre><code class="language-C++">template&lt;typename T&gt;
auto func(T&amp;&amp; param) {
    const T&amp;&amp; p2 = param;
    // since const is used
    // p2 is not a universal reference
}

std::string name = &quot;Hello&quot;;

func(name);
// T deduced to std::string&amp;
// type of p2 becomes const std::string&amp; &amp;&amp;
// type of p2 collapses to const std::string&amp;

func(10);
// T deduced to be int
// type of p2 becomes const int &amp;&amp;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variadic-templates"><a class="header" href="#variadic-templates">Variadic Templates</a></h1>
<p>As we've seen with <code>std::void_t</code>, <code>emplace()</code>, and <code>make_unique</code>/<code>make_shared</code>, there is a way to take an unknown amount of parameters of different types. 
This can be done using a <em>parameter pack</em>. A template that uses a parameter pack is known as a variadic template.</p>
<p>You can almost think of a parameter pack as a list of template parameters (both type and non-type parameters). 
A parameter pack can have any number of parameters, including none.</p>
<pre><code class="language-C++">template&lt;typename ...Ts&gt;
struct Types {};

Types&lt;&gt; t;
Types&lt;1, 2, 3&gt; t2;
Types&lt;int, short, std::string, char&gt; t3;

template&lt;typename ...Ts&gt;
void func(Ts... args) {
    // ..
}

func();
func(100, &quot;Hello&quot;, 'g');
</code></pre>
<p>We can define a parameter pack by putting the ellipsis in front of the pack name, and expand a parameter pack by putting the ellipsis after the <em>pattern</em>. 
The pattern is the pack name with any adornments (such as <code>&amp;</code>) which are given to all elements of the pack. During expansion, the pattern is substituted by the elements of the pack separated by commas.</p>
<pre><code class="language-C++">template&lt;class ...Us&gt; 
void f(Us... pargs) {}

template&lt;class ...Ts&gt; 
void g(Ts... args) {
    return f(&amp;args...); 
    // calls f by passing all elements of args by reference
    // &amp;args is the pattern
}
g(1, 0.2, &quot;a&quot;); 
</code></pre>
<p>We can expand parameter packs in the following contexts:</p>
<ul>
<li>As we've just seen, function arguments
<pre><code class="language-C++">template&lt;typename ... Ts&gt;
void g(Ts... args) {
    f(args...);
    f(++args...); // expands to f(++a, ++b, ++c, ...)
    f(h(args...) + args...); 
    // expands to
    //f(h(a, b, c) + a, h(a, b, c) + b, h(a, b, c) + c);
}
</code></pre>
</li>
<li>Initializers (both parenthesis and braces)
<pre><code class="language-C++">template&lt;typename ... Ts&gt;
auto toVec(Ts ... args) {
    std::vector v = {1, args..., 2};
    return v;
}
</code></pre>
</li>
<li>Template arguments
<pre><code class="language-C++">template&lt;typename ... Ts&gt;
struct Test {
    container&lt;int, short, Ts...&gt; c;
};
</code></pre>
</li>
<li>Base class specifiers and member initialization lists
<pre><code class="language-C++">template&lt;typename ... Mixins&gt;
struct Aggregator : public Mixins ... {
    Aggregator(const Mixins&amp; ... args) : Mixins(args) ... {};
    // expands to call copy constructor of all base classes
}
</code></pre>
</li>
<li>Using declarations
<pre><code class="language-C++">template&lt;typename ... Mixins&gt;
struct Aggregator : public Mixins ... {
    Aggregator(const Mixins&amp; ... args) : Mixins(args) ... {};
    // expands to call copy constructor of all base classes

    void foo() {};
    using Mixins::foo...;
    // unshadow all base class foo overloads
}
</code></pre>
</li>
</ul>
<p>Parameter packs can also be universal references and can be forwarded.</p>
<pre><code class="language-C++">template&lt;typename T, typename ... Args&gt;
auto make_unique(Args&amp;&amp; ... args) {
    return std::unique_ptr&lt;T&gt;( new T(std::forward&lt;Args&gt;(args)...) );
    // expands to
    // new T(std::forward&lt;A&gt;(a), std::forward&lt;B&gt;(b), std::forward&lt;C&gt;(c), /* ... */)
}
</code></pre>
<p>Basically, each use case of <code>...</code> expands a comma separated list of the pattern <code>...</code> is applied to. 
The name of the pack typename (<code>Args</code> in this case) is substituted which each type in the pack, and the name of the pack arguments (<code>args</code> here) is substituted with each argument passed to the function.</p>
<p>We can &quot;unpack&quot; an expansion by using two function overloads (or class specializations), one which takes no arguments, this will be the base case, and one which takes a &quot;head&quot; argument and &quot;tail&quot; parameter pack. 
The idea here is the same as in functional programming. Here's a simple function to get the length of a parameter pack.</p>
<pre><code class="language-C++">constexpr auto argCount() {
    return 0;
}

template&lt;typename T, typename ... Args&gt;
constexpr auto argCount(T&amp;&amp;, Args&amp;&amp; ... args) {
    return 1 + argCount(std::forward&lt;Args&gt;(args)...);
}

constexpr auto count = argCount(5); 
static_assert(count == 1);
static_assert(argCount(&quot;Hello&quot;, 50.0, 10, 'c') == 4);
</code></pre>
<p>When we call <code>argCount</code> with non-zero amount of arguments, the first argument gets bound to <code>T&amp;&amp;</code> and the rest (which there may be none) gets bound to <code>Args&amp;&amp;</code>. 
If the pack has no arguments in it, the expansion won't do anything, and the no parameter overload will be called.</p>
<p>A better way to do this is to use the <code>sizeof...</code> operator, which gets the amount of arguments in a parameter pack.</p>
<pre><code class="language-C++">template&lt;typneame ... Args&gt;
constexpr auto argCount(Args&amp;&amp; ...) {
    return sizeof...(Args);
    // sizeof... takes the typename of the pack, not the argument name
}
</code></pre>
<p>Here's an example of getting the nth type from a parameter pack:</p>
<pre><code class="language-C++">template&lt;unsigned index, typename Head, typename ... List&gt;
struct NthType {
    using Type = typename NthType&lt;index - 1, List...&gt;::Type;
    // we &quot;pop&quot; the Head of the pack by not passing it through
};

template&lt;typename Head, typename ... List&gt;
struct NthType&lt;0, Head, List...&gt; {
    using Type = Head;
};
// index 0 specialization

using sndType = typename NthType&lt;2, void*, char*, int, long, double&amp;&gt;::Type;
//sndType is int
/*  sndType
        NthType&lt;index = 2, Head = void*, List = char*, int, long, double&amp;&gt;
            NthType&lt;index = 1, Head = char*, List = int, long, double&amp;&gt;
                NthType&lt;index = 0, Head = int, List = long, double&amp;&gt;
                    This is the specialization
                    So `Type = Head = int`

*/
</code></pre>
<h2 id="fold-expressions"><a class="header" href="#fold-expressions">Fold Expressions</a></h2>
<p>A fold expression is like another type of pack expansion, except that instead of producing comma separated arguments,
the pack is expanded over a binary operator. 
A fold expression can have an initial value as well, and must be surrounded by parentheses.</p>
<p>I won't explain the details of folds here, but basically left folds operate on the leftmost argument first,
right folds go from the rightmost argument to leftmost. Folds come from functional programming languages. 
Fold expression have the following syntax where <code>pack</code> is the pattern containing the name of the pack,
<code>op</code> is the operator, <code>init</code> is the initial value and <code>...</code> are the actual ellipsis.</p>
<ul>
<li>Unary fold right - <code>(pack op ...)</code></li>
<li>Unary fold left - <code>(... op pack)</code></li>
<li>Binary fold right - <code>(pack op ... op init)</code></li>
<li>Binary fold left - <code>(init op ... op pack)</code></li>
</ul>
<p>The difference between a unary and binary fold is not that one uses unary operators (that would be a normal pack expansion),
but rather the binary fold has an initial value. 
The syntax for a left fold is when the <code>...</code> is on the left side of the pack name.</p>
<pre><code class="language-C++">template&lt;typename ... Ts&gt;
constexpr auto sum(Ts&amp;&amp; ... args) {
    return (... + args);
    // &quot;unary&quot; left fold
}

template&lt;typename ... Args&gt;
void print(Args&amp;&amp; ... args) {
    (std::cout &lt;&lt; ... &lt;&lt; args);
    // binary left fold
}

template&lt;typename ... Args&gt;
constexpr auto allTrue(Args&amp;&amp; ... args) {
    return (... &amp;&amp; args);
    // binary left fold
}

template&lt;typename T, typename ...Args&gt;
constexpr auto contains(T needle, Args ... args) {
    // true if needle is contained within the pack
    return (... || (args == needle));
}

template&lt;typename ...Args&gt;
constexpr auto selfDot(Args... args) {
    // computes the dot product of the arguments with them self
    return (... + (args * args));
}
</code></pre>
<p>Notice the need for the parenthesis to make an entire expression such as <code>args * args</code> or <code>args == needle</code> part of the pattern. 
We define all of these function <code>constexpr</code> so that the result of the function can be available at compile time (and therefore not done during runtime) if we pass arguments that are also <code>constexpr</code> such as literals.</p>
<h2 id="packs-and-concepts"><a class="header" href="#packs-and-concepts">Packs and Concepts</a></h2>
<p>Parameter packs can be used pretty easily with <code>enable_if</code> using fold expressions.</p>
<pre><code class="language-C++">template&lt;typename ... Ts&gt;
constexpr auto sum(Ts... args) 
    -&gt; std::enable_if_t&lt;(... &amp;&amp; std::is_arithmetic_v&lt;Ts&gt;), decltype((... + args))&gt; 
{
    return (... + args);
}

constexpr auto s = sum(10, 20.3, 100.f, 'c'); // double 229.3
</code></pre>
<p>Unlike before, in this situation we <em>need</em> to use the trailing return type because the parameter <code>args</code> is used in determining the return type. 
Also, notice how when we want a fold expression using the types of the pack, we use the name of the template parameter <code>Ts</code>. 
However, when we want a fold expression using the values of the pack, we use the name of the function argument <code>args</code>.</p>
<p>In this case we fold over <code>&amp;&amp;</code> (boolean AND) to ensure that all types in the pack are arithmetic.
We could fold over <code>||</code> (boolean OR) to check that at least one type upholds a certain condition.</p>
<p>We can use a type alias to make this a bit cleaner.</p>
<p>Another less graceful, (and pre C++17 friendly) way of doing this is to create an <code>all_true</code> struct using SFINAE. 
What we'll do is instantiate a struct with a pack of bools.
Then we'll assert that the type of the bool pack is the same when we append a <code>true</code> to the front of the pack as when we push a <code>true</code> to the back. 
If all elements of the bool pack are the <code>true</code>, then the types will be the same.
However, if any of the elements in the pack are <code>false</code>, the position of this <code>false</code> will differ between the two 
instantiations of the template, and they won't be the same type.</p>
<pre><code class="language-C++">
template&lt;bool...&gt;
struct bool_pack {};

// template variables are a C++17 feature
template&lt;bool... bools&gt;
constexpr inline auto all_true_v = std::is_same_v&lt;
    bool_pack&lt;bools..., true&gt;, 
    bool_pack&lt;true, bools...&gt;&gt;;

template&lt;typename... Ts&gt;
std::enable_if_t&lt;all_true_v&lt;std::is_arithmetic_v&lt;Ts&gt;...&gt;&gt;
foo(Ts... args) {
    //...
}
</code></pre>
<h3 id="possible-exercises-9"><a class="header" href="#possible-exercises-9">Possible Exercises</a></h3>
<ol>
<li>Can you create a function that takes an arbitrary number of arguments and serializes all of them into a single byte array?
The function should return an <code>std::vector&lt;std::byte&gt;</code> or an <code>std::array&lt;std::byte, N&gt;</code>.
If you go the latter route, the function can be <code>constexpr</code>.
You'll need an overload to handle containers like <code>std::vector</code>, <code>std::list</code>, etc.
You may choose the endianness of the result.
<ul>
<li>So when passed <code>&quot;Hello&quot;, 5, static_cast&lt;short&gt;(1000)</code> the function should return a single byte array that would look something like:
<pre><code class="language-C++">0x48 0x65 0x6C 0x6C 0x6F 0x00 0x00 0x00 0x05 0x03 0xE8
 'H'  'e'  'l'  'l'  'o'|         5         |   1000
// little endian, 4 byte int, 2 byte short
</code></pre>
</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators-1"><a class="header" href="#iterators-1">Iterators</a></h1>
<p>There are actually multiple different iterator concepts. All iterators must be copy constructable and copy assignable, destructible, provide a prefix <code>operator++</code> for incrementing and an <code>operator*</code> for dereferencing. 
Furthermore, all iterator lvalues must be able to be swapped and all iterators must provide type aliases through <code>std::iterator_traits</code>. 
This is a struct that is specialized for iterators to provide the following member type aliases:</p>
<ul>
<li><code>difference_type</code> - result of subtracting iterators</li>
<li><code>value_type</code> - resultant type of dereferencing the iterator and passing by value. So qualifiers such as <code>const</code> would not be included here.</li>
<li><code>pointer</code> - pointer to <code>value_type</code> with qualifiers</li>
<li><code>reference</code> - reference to <code>value_type</code> with qualifiers</li>
<li><code>iterator_category</code> - tag indicating the type of iterator</li>
</ul>
<p>The type aliases can be declared by specializing <code>std::iterator_traits&lt;T&gt;</code> directly or by declaring them as public member type aliases in the class of the iterator itself. 
<code>std::iterator_traits&lt;T&gt;</code> is another usage of SFINAE. If <code>T</code> has the aforementioned type aliases, then <code>std::iterator_traits&lt;T&gt;</code> will be a struct that contains the exact same type aliases. 
Otherwise, <code>std::iterator_traits&lt;T&gt;</code> will not define any type aliases. Therefore, we could make an <code>IsIterable</code> trait before like so:</p>
<pre><code class="language-C++">template&lt;typename T, typename = void&gt;
struct IsIterable : std::false_type {};

template&lt;typename T&gt;
struct IsIterable&lt;T, std::void_t&lt;
    typename std::iterator_traits&lt;decltype(std::declval&lt;T&gt;().begin())&gt;::value_type
    &gt;&gt; : std::true_type {};
</code></pre>
<p>An implementation of <code>std::iterator_traits</code> might look something like this:</p>
<pre><code class="language-C++">template&lt;typename T, typename = void&gt;
struct iterator_traits {};

template&lt;typename T&gt;
struct iterator_traits&lt;T, std::void_t&lt;
    typename T::value_type,
    typename T::difference_type,
    typename T::pointer,
    typename T::reference,
    typename T::iterator_category
&gt;&gt; {
    using value_type = typename T::value_type;
    using difference_type = typename T::difference_type;
    using pointer = typename T::pointer;
    using reference = typename T::reference;
    using iterator_category = typename T::iterator_category;
};
</code></pre>
<ul>
<li>Base Iterator Requirements
<ul>
<li>Copyable</li>
<li>Destructible</li>
<li>Able to be dereferenced and incremented</li>
</ul>
</li>
<li>Input Iterator
<ul>
<li>Can be compared for equality with <code>==</code> and <code>!=</code>.</li>
<li>Can be dereferenced to a rvalue</li>
</ul>
</li>
<li>Output Iterator
<ul>
<li>Can be dereferenced to a lvalue</li>
</ul>
</li>
<li>Forward Iterator
<ul>
<li>Input or Output Iterator that can be default constructed and is <em>multi-pass</em></li>
<li>Multi-pass: dereferencing and incrementing the iterator doesn't affect the ability for the iterator to dereference. 
Basically, using the iterator does not consume anything. The iterator can increment to the sentinel and start over and do it again without a change in behavior.</li>
</ul>
</li>
<li>Bidirectional Iterator
<ul>
<li>Forward Iterator that can be decremented</li>
</ul>
</li>
<li>Random Access Iterator
<ul>
<li>Bidirectional Iterator that supports arithmetic operations such as <code>+</code> and <code>-</code> to move the iterator</li>
<li>Also supports <code>operator-(Iterator, Iterator)</code> which returns the distance between two iterators</li>
<li>Can be compared with <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code></li>
<li>Supports compound assignment operators <code>+=</code> and <code>-=</code></li>
<li>Supports <code>operator[]</code> such that <code>it[n] == *(it + n)</code>.</li>
</ul>
</li>
<li>Contiguous Iterator
<ul>
<li>Random Access Iterator with its elements adjacent to each other in memory</li>
<li>Requires that <code>*(it + n) == *(std::addressof(*it) + n)</code></li>
</ul>
</li>
</ul>
<pre><code>Iterator
|
|_ Contiguous Iterator
        |
        |_ Random Access
                |
                |_  Bidirectional
                        |
                        |_  Forward
                                |
                                |_  Input
                                |
                                |_  Output
</code></pre>
<p>Each iterator has a corresponding iterator tag type that would be assigned to the <code>iterator_category</code> type alias. The tags are <code>std::input_iterator_tag</code>, <code>std::output_iterator_tag</code>, etc.</p>
<p>The STL provides some general methods for operating with iterators that are specialized to use more efficient operations if available. 
<code>std::advance(it, diff)</code> takes an iterator reference as its first parameter and a different type as its second parameter. 
It will advance the iterator <code>diff</code> spaces using <code>operator+</code> if it's available otherwise will repeatedly increment the iterator. <code>std::distance()</code> will return the distance between two iterators. 
Similarly, <code>std::distance</code> will be constant time for iterators that support <code>operator-(iter, iter)</code>. 
The STL also provides <code>std::next</code> and <code>std::prev</code> which are similar to <code>std::advance</code> for incrementing and decrementing the iterator.</p>
<p>When designing generic code, it's best to be <strong>as generic as possible</strong>. 
For example, if you're using iterators in a for loop, it's better to use <code>operator!=</code> rather than <code>operator&lt;</code> for comparing the iterator to the sentinel because only Random Access and Contiguous iterators 
support <code>operator&lt;</code>. This doesn't just apply to iterators. Any time you use a type parameter you ideally want to use the most broadly applicable interface possible to reduce the requirements for that type.</p>
<p>Consider:</p>
<pre><code class="language-C++">// Needs a random access iterator and a container with a size member and operator[]
template&lt;typename T&gt;
void reverse(T&amp; container) {
    for (auto i = 0; i &lt; container.size() / 2; ++i) {
        using std::swap;
        swap(container[i], container[container.size() - 1 - i]);
    }
}

// Needs a forward iterator
template&lt;typename T&gt;
void reverse(T&amp; container) {
    const auto size = std::distance(container.begin(), container.end());
    const auto it = container.begin();
    for (auto i = decltype(size){0}; i &lt; size / 2; ++i) {
        using std::swap;
        auto a = it;
        auto b = it;
        std::advance(a, i);
        std::advance(b, size - i);
        swap(*a, *b);
    }
}

</code></pre>
<p>Yes, the more generic version is more code and can be ever so slightly less efficient. 
But unless you have a good reason not to, it's generally more preferred to be as generic as possible (within reason). 
Another good example would be using <code>size() == 0</code> to check for emptiness of a container. 
Some containers don't have a concept of <code>size</code> but still have a concept of emptiness which can be tested with the <code>empty()</code> member function.</p>
<p>Let's look at an example of creating our own iterator</p>
<pre><code class="language-C++">/**
* A class which strings together two vectors into one
* without copying them
*/
template&lt;typename T&gt;
class Rope {
private:
	std::vector&lt;T&gt; first, second;
public:
    // construct a rope from two vector rvalues
	Rope(std::vector&lt;T&gt;&amp;&amp; first, std::vector&lt;T&gt;&amp;&amp; second) : 
        first(std::move(first)), second(std::move(second)) {}

	class iterator {
		Rope&lt;T&gt;* owner;
		size_t pos;
	public:
	    // type aliases for all iterators
		using value_type = std::remove_cv_t&lt;T&gt;;
		using difference_type = ptrdiff_t;
		using reference = T&amp;;
		using pointer = T*;
		using iterator_category = std::forward_iterator_tag;

		iterator(Rope&lt;T&gt;* owner, size_t pos) :
			owner(owner), pos(pos) {};


		bool operator==(const iterator&amp; other) const {
			return owner == other.owner &amp;&amp; 
			    pos == other.pos;
		}
		bool operator!=(const iterator&amp; other) const {
			return !(*this == other);
		}
		T&amp; operator*() {
			if (pos &gt;= owner-&gt;first.size() &amp;&amp; 
				pos &lt; owner-&gt;second.size() + owner-&gt;first.size()) 
			{
				return owner-&gt;second[pos - owner-&gt;first.size()];
			}
			else if (pos &lt; owner-&gt;first.size())
				return owner-&gt;first[pos];
			else
				throw 
				    std::out_of_range(&quot;Iterator out of range&quot;);
		}
		iterator&amp; operator++() {
			++pos;
			return *this;
		}
		// postfix increment
		iterator operator++(int) {
			iterator old = *this;
			operator++();
			return old;
		}
	};
    // iterator to start of container
	iterator begin() {
		return { this, 0 };
	}
	// iterator to end
	iterator end() {
		return { this, first.size() + second.size() };
	}
};
</code></pre>
<p>As you see here, iterators are often implemented using pointers. So they must not live beyond the lifetime of the container they reference. 
<code>iterator</code> is a subclass of <code>Rope&lt;T&gt;</code>. So the fully qualified name for the iterator is <code>Rope&lt;T&gt;::iterator</code>. 
We cold also have forward declared the iterator inside the class and defined it outside the class. 
Later we'll see an implementation of <code>chain</code> which allows stringing together an arbitrary amount of different types of iterators.</p>
<p>In C++ 20, the typename <code>iterator_category</code> in <code>std::iterator_traits</code> is replaced with <code>iterator_concept</code> and the <code>std::iterator_tag</code> is replaced with iterator concepts. </p>
<h2 id="iterator-adapters"><a class="header" href="#iterator-adapters">Iterator Adapters</a></h2>
<p>Iterator adapters wrap existing iterators in another iterator to provide certain functionality. These are mostly self-explanatory, and I won't go through every single one here.</p>
<ul>
<li><code>reverse_iterator</code> - wraps an existing bidirectional iterator into an iterator such that <code>++</code> of the reverse iterator calls <code>--</code> of the underlying iterator. 
Returned by <code>rbegin()</code> and <code>rend()</code> of standard containers.
<ul>
<li>Can be created with <code>std::make_reverse_iterator()</code></li>
</ul>
</li>
<li><code>move_iterator</code> - dereferences to an rvalue to allow moving the value referenced by the iterator
<ul>
<li>Factory function <code>std::make_move_iterator()</code></li>
</ul>
</li>
<li><code>back_insert_iterator</code> - output iterator that appends to a container using that containers <code>push_back()</code> method
<ul>
<li>Factory function <code>std::back_inserter</code></li>
</ul>
</li>
<li><code>front_insert_iterator</code> - Can you guess what this does? Yup, uses <code>push_front()</code> instead of <code>push_back()</code> but otherwise quite similar to <code>back_insert_iterator</code>
<ul>
<li><code>std::front_inserter</code></li>
</ul>
</li>
</ul>
<h3 id="possible-exercises-10"><a class="header" href="#possible-exercises-10">Possible Exercises</a></h3>
<ol>
<li>Make an iterator for the <code>Ringbuffer</code> class</li>
<li>I recommend checking out <a href="http://www.gotw.ca/gotw/018.htm">this GOTW</a>. A little old, but still plenty relevant.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="policies"><a class="header" href="#policies">Policies</a></h1>
<p>Taking the term from Andrei Alexandrescu, a policy is a small little class which handles a single behavior or structural element for larger, more complex classes. 
<em>Policy Based Design</em> is the methodology to design classes by using such policies. 
Policy based design is sort of like the generic programming equivalent of object composition with class hierarchies. 
Let's look at an OOP and generic way of abstracting the thread safety and comparator behavior of a Linked List:</p>
<pre><code class="language-C++">// OOP object composition (untested)
class ThreadingPolicy {
public:
    virtual ~ThreadingPolicy() = default;
    virtual std::unique_ptr&lt;LockProxy&gt; lock() = 0;

    struct LockProxy {
        virtual ~LockProxy() = default;
    };
};

class MultithreadedPolicy : public ThreadingPolicy {
    std::mutex mu;
public:
    class MTLock : public ThreadingPolicy::LockProxy {
        std::mutex &amp;mu;
    public:
        MTLock(std::mutex&amp; mu) : mu(mu) {
            mu.lock();
        }

        ~MTLock() {
            mu.unlock();
        }
    };

    std::unique_ptr&lt;LockProxy&gt; lock() override {
        return std::make_unique&lt;MTLock&gt;(mu);
    }
};

class SingleThreadedPolicy : public ThreadingPolicy {
public:
    struct SSLock : public ThreadingPolicy::LockProxy {};

    std::unique_ptr&lt;LockProxy&gt; lock() override {
        return std::make_unique&lt;SSLock&gt;();
    }
};

struct Comparator {
    virtual ~Comparator() = default;
    virtual int compare(int, int) = 0;
};

struct LessThanComparison : Comparator {
    int compare(int a, int b) override {
        return a - b;
    }
};

class LinkedList {
    std::unique_ptr&lt;ThreadingPolicy&gt; tp;
    std::unique_ptr&lt;Comparator&gt; cmp;

    struct node {
        int data;
        std::unique_ptr&lt;node&gt; next;

        node(int data) : data(data), next(nullptr) {}
    };

    std::unique_ptr&lt;node&gt; root;
public:
    LinkedList(std::unique_ptr&lt;ThreadingPolicy&gt; &amp;&amp; tp, std::unique_ptr&lt;Comparator&gt; &amp;&amp; cmp) :
        tp(std::move(tp)), cmp(std::move(cmp)), root(nullptr) {}

    void push_back(int data) {
        const auto lk = tp-&gt;lock(); // user passed instance controls locking
        auto* n = &amp;root;
        while(*n) {
            n = &amp;n-&gt;next;
        }
        *n = std::make_unique&lt;node&gt;(data);
    }

    bool find(int e) const {
        const auto lk = tp-&gt;lock();
        auto* n = &amp;root;
        while(*n) {
            if (cmp-&gt;compare(n-&gt;data, e) == 0) // user tells us how to compare
                return true;
            n = &amp;n-&gt;next;
        }
        return false;
    }
};
</code></pre>
<p>There's a few problems with this approach. 
Firstly, we cannot have template virtual functions. This means we'd need to manually create comparators for every type of arguments we'd want to support. 
Instead of an interface, we could accept a generic <code>std::function</code> to ameliorate that.
What if we wanted to have a per node locking system to improve the concurrency of the list? A solution could be to make the threading policy follow the <em>prototype</em> OOP pattern. 
Notice how this OOP approach however requires 2 parallel hierarchies, and because of the nature of polymorphism, indirection due to dynamic dispatch. 
This might be manageable, but what if we decide to make allocation something the user can control? Once again we'd be off creating another set of parallel class hierarchies.</p>
<p>We can make OOP work, but a better solution, especially when we're already dealing with generic code is to use policies. 
Customizable behaviors such as object allocation, comparators, threading, different algorithm implementations, etc. can be <em>policies</em> passed as template arguments. 
Each policy would adhere to a certain concept allowing the usage of many different, unrelated types. 
For example, a threading policy would no longer have to have a <code>lock()</code> function returning an implementation of a specific interface, but rather any object adhering to a certain concept. 
In our previous example, the concept would simply be <code>Destructible</code>.</p>
<pre><code class="language-C++">#include &lt;mutex&gt;
#include &lt;memory&gt;
// Policy Implementations:
// these adhere to the concepts required of them
// kind of like OOP concrete classes
struct SingleThreadPolicy {
    char lock() const { return 0; }
    // the thread policy concept (see below) requires we return something swappable and
    // destructible
    // char satisfies this requirement and is essentially
    // a placebo for a lock
};

class MultiThreadPolicy {
    mutable std::mutex lk;
    // mutable allows lk to be mutated from const members
public:
    auto lock() const { return std::unique_lock&lt;std::mutex&gt;(lk); }
    // unique lock is RAII for a lock
    // locks on construction, unlocks on destruction
    // move-only like unique_ptr
    // we'll talk more about this later
};

enum class Ordering {
    less,
    equal,
    greater
};

template&lt;typename T&gt;
struct BasicComparator {
    static Ordering compare(const T&amp; a, const T&amp; b) {
        if (a &lt; b) return Ordering::less;
        else if (a == b) return Ordering::equal;
        else return Ordering::greater;

    }
};
///

// C++17 policy definitions
// define what concepts we need our policies to have
// analogous to an OOP abstract class/interface

template&lt;typename T&gt;
using strip_t = std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;;

template&lt;class Comparator, typename T, typename = void&gt;
struct IsComparator : std::false_type {};

template&lt;class Comparator, typename T&gt;
struct IsComparator&lt;Comparator, T, std::enable_if_t&lt;
    std::is_same_v&lt;Ordering,
    strip_t&lt;decltype(Comparator::compare(std::declval&lt;T&gt;(), std::declval&lt;T&gt;()))&gt;&gt;
    // checks for a static member function compare() that operates on two Ts and returns an Ordering
    // does not have to be same const, reference, pointer, or volatility-ness
    &gt;&gt; : std::true_type{};

template&lt;typename T, typename = void&gt;
struct IsThreadingPolicy : std::false_type {};

template&lt;typename T&gt;
struct IsThreadingPolicy&lt;T,
    std::enable_if_t&lt;
    std::is_swappable_v&lt;decltype(std::declval&lt;const T&gt;().lock())&gt;
    // checks for a const member function lock() that returns a type that is swappable
    &gt;&gt; : std::true_type{};

template&lt;typename T&gt;
constexpr auto inline is_threading_v = IsThreadingPolicy&lt;T&gt;::value;

template&lt;template&lt;typename&gt; class Cmp, typename T&gt;
constexpr auto inline is_comparator_v = IsComparator&lt;Cmp&lt;T&gt;, T&gt;::value;

///


// primary definition of class, if it gets to this (specialization failure), class is incomplete and cannot be used
template&lt;typename T, 
    class ThreadingPolicy = SingleThreadPolicy, 
    template&lt;typename&gt; class Cmp = BasicComparator, 
    typename = void&gt;
class LinkedList;

// this template&lt;typename&gt; syntax indicates that Comparator is a &quot;template-template&quot; parameter
// a template paramater that is itself a template
// more on this later

// sfinae specialization
template&lt;typename T,
    class ThreadingPolicy,
    template&lt;typename&gt; class Cmp&gt;

class LinkedList&lt;T,
    ThreadingPolicy, Cmp,
    std::enable_if_t&lt;is_threading_v&lt;ThreadingPolicy&gt;&amp;&amp; is_comparator_v&lt;Cmp, T&gt;&gt;&gt;
{
    class node {
        ThreadingPolicy localLock;
        T data; ///&lt; Invalid iff empty is true
        bool empty;
    public:
        std::unique_ptr&lt;node&gt; next;
        ///Invariant: next is null iff empty is true
    public:

        node() : data(), empty(true), next(nullptr) {}
        node(T&amp;&amp; data) : data(std::forward&lt;T&gt;(data)), empty(false),
            next(std::make_unique&lt;node&gt;()) {};

        void set(T&amp;&amp; data) {
            this-&gt;data = std::forward&lt;T&gt;(data);
            empty = false;
            if (!next) {
                next = std::make_unique&lt;node&gt;();
            }
        }

        inline auto lock() { return localLock.lock(); }
        inline auto isEmpty() { return empty;  }
        inline const auto&amp; getData() { return data;  }
    };

    std::unique_ptr&lt;node&gt; root;
public:
    LinkedList() : root(std::make_unique&lt;node&gt;()) {};

    template&lt;typename U&gt;
    auto push_back(U&amp;&amp; data) -&gt; std::enable_if_t&lt;std::is_same_v&lt;strip_t&lt;U&gt;, T&gt;&gt; 
    {
        // if we used T, data would not be a universal reference since
        // the function itself is not a template and T is the class template argument
        using std::swap;
        auto n = &amp;root;
        auto lk1 = n-&gt;get()-&gt;lock();
        while (!n-&gt;get()-&gt;isEmpty()) {
            n = &amp;n-&gt;get()-&gt;next;
            auto lk2 = n-&gt;get()-&gt;lock();
            swap(lk1, lk2);
            // hand over hand locking (we'll talk about this later)
            // lk1 and lk2 are swapped, lk1 then goes out of scope
            // releasing the lock
        }
        n-&gt;get()-&gt;set(std::forward&lt;T&gt;(data));
    }

    bool find(const T&amp; e) const {
        using std::swap;
        auto n = &amp;root;
        auto lk1 = n-&gt;get()-&gt;lock();
        while (!n-&gt;get()-&gt;isEmpty()) {
            if (Cmp&lt;T&gt;::compare(n-&gt;get()-&gt;getData(), e) == Ordering::equal)
                return true;
            // we don't need an instance of the comparator
            // its member function is static
            n = &amp;n-&gt;get()-&gt;next;
            auto lk2 = n-&gt;get()-&gt;lock();
            swap(lk1, lk2);
            // policy doesn't dictate what type is returned from lock
            // might be an STL lock, might be something user defined
            // thus we don't want to hardcode std::swap bc the user
            // might provide their own
        }

        return false;
    }
};
</code></pre>
<p>We've gained finer grain locking with policies because when we pass a type via template parameter, we have more control. 
We can easily construct instances of the locking policy wherever we see fit without forcing the locking policy to implement the prototype pattern. 
We also don't need to have an instance of the comparator. 
And probably most importantly, we cut down on the amount of classes we have to create. Supporting a different type is as easy as changing a single template parameter. 
We use SFINAE to enforce that the template parameters adhere to the policy interface. In C++20, concepts makes this much easier and cleaner.</p>
<p>Notice that these policies are general enough to apply to many classes. </p>
<p>Template-template parameters and more policy design examples will come later, but for now, I want to focus on using these ideas to customize the STL.</p>
<p>STL uses this design a lot. We've already seen it in action with deleters on smart pointers and comparison predicates in STL containers. 
One thing to note is that the STL wasn't so kind as to use SFINAE to prevent incorrect concept implementations. </p>
<p>A common STL policy is an allocator. These are typically the last template argument (because they are typically the least frequently customized) and are pretty similar to custom deleters with smart pointers. 
I won't discuss them here, but it's good to know they exist.</p>
<p>Let's start with an <code>std::map</code>. <code>std::set</code> is an ordered container typically implemented as a RB Tree. If we want to have a map of students, we'd need to be able to order them.</p>
<pre><code class="language-C++">struct Student {
    std::string name, school, college, major;
    float gpa;
};

</code></pre>
<p>The concept for a comparator (<code>Compare</code> named requirement) requires a type that takes in a template parameter and defines an <code>operator(const T&amp;, constT&amp;)</code> which returns a bool 
(or something implicitly convertible to bool). It also requires that <code>!cmp(a, b) &amp;&amp; !cmp(b, a)</code> establishes that <code>a == b</code>. 
The default ones provided are <code>std::less</code> and <code>std::greater</code> which use <code>operator&lt;</code> and <code>operator&gt;</code> respectively. 
Containers will order their elements so that <code>a</code> is before <code>b</code> if <code>cmp(a, b)</code> returns true. Thus, an out-of-the-box <code>std::set</code> will order elements least to greatest using the type's defined <code>operator&lt;</code>.</p>
<p>Say we wanted to dehumanize our students and order them from highest to lowest gpa. Since equal gpa's should be allowed, we'll need an <code>std::multiset</code>. 
We could do this relatively simply by defining an <code>operator&gt;</code> and changing the template parameter.</p>
<pre><code class="language-C++">struct Student {
    std::string name, school, college, major;
    float gpa;

    bool operator&gt;(const Student&amp; other) const {
        return gpa &gt; other.gpa;
    }
};

std::multiset&lt;Student, std::greater&lt;Student&gt;&gt; students;
</code></pre>
<p>Now let's say we wanted a multiset of students in an order that's different from the typical method to compare students: all CS students first, then alphabetically by major. 
We probably don't want to change <code>operator&gt;</code> since users of our Student type wouldn't expect such an ordering when using the comparison operators. So instead, we'll just change the comparator on the set.</p>
<pre><code class="language-C++">
struct StudentMajorOrdering {
    // const Student&amp; because that will bind to all references
    bool operator()(const Student&amp; a, const Student&amp; b) const {
        if (a.major == &quot;Computer Science&quot; &amp;&amp; b.major != a.major)
            // two students that are equal must not compare to true
            return true;
        else
            return a.major &lt; b.major;
    }
};

std::multiset&lt;Student, StudentMajorOrdering&gt; students;
</code></pre>
<p>The STL comparator is not a template template parameter which allows us to easily implement specific orderings like this one. 
However, it also means that when we do use template comparators like <code>std::less</code>, we'll have to pass the element type as a parameter to both the container and comparator as well.</p>
<p>A difference between OOP and generic interfaces is that these two sets are not the same type. Unless our class defines generic member functions (which the STL does not), 
we cannot easily convert the two types and any code wishing to abstract away the specific implementation would need to use templates.</p>
<pre><code class="language-C++">
template&lt;typename T, class Cmp, class Alloc&gt;
void useMS(const std::multiset&lt;T, Cmp, Alloc&gt; &amp;) {}

// OR

template&lt;typename T&gt;
void useSet(T&amp;&amp;) {}
// this one should probably use concepts to enforce 
// the interface T must adhere to.
</code></pre>
<p>We already saw how we can specialize <code>std::hash</code> to make custom types work with hash containers, but what if we just wanted one <code>std::unordered_map</code> with a custom hash function? 
We can change the hashing and the comparison templates similarly to changing a comparator in a set. 
Let's saw we wanted a map keyed on a student where we'll have only 1 student per school. That is to say two students are equal if they go to the same school. 
We'll need to change the hash function and the predicate used to compare for equality.</p>
<pre><code class="language-C++">struct StudentSchoolEquality {
    bool operator()(const Student&amp; a, const Student&amp; b) const {
        return a.school == b.school;
    }
    // return true iff the passed arguments are equal
};

struct StudentSchoolHash {
    size_t operator()(const Student&amp; s) const {
        return std::hash&lt;std::string&gt;{}(s.school);
        // just hash the student's school member
    }
    // a hash function should return std::size_t
}

std::unordered_map&lt;Student, std::string, StudentSchoolHash, StudentSchoolEquality&gt; map;
</code></pre>
<p>Notice how the <code>operator()</code> member functions are <code>const</code> and are passed <code>const</code> references. 
Because they do not modify any outside state or have side effects, these functions are known as <em>pure</em> and should be preferred to non-pure. 
For those familiar with functional programming, a pure function is like a step below a functional function. 
They don't have side effects or modify outside state, but they can modify internal local state and have things like loops.</p>
<p>For the last example, let's implement a case-insensitive string. We can customize <code>std::string</code> which is a type alias for <code>std::basic_string&lt;char&gt;</code>. The full template definition of <code>std::basic_string</code> is as follows:</p>
<pre><code class="language-C++"> template&lt;class charT,
           class traits = char_traits&lt;charT&gt;,
           class Allocator = allocator&lt;charT&gt; &gt;
      class basic_string;
</code></pre>
<p>So writing a case-insensitive string really just boils down to implementing a <code>char_traits</code> policy. <code>std::char_traits&lt;T&gt;</code> is a struct that defines quite a few <u>static</u> member functions such as 
<code>eq(), lt(), compare(), copy(), length(), move(), eof()</code>, and more. Unlike before where we created an entire implementation of the concept, this time we'll use inheritance to borrow the 
implementation of the default <code>std::char_traits&lt;T&gt;</code> and just shadow what we want to rewrite. Although <code>char_traits</code> is not meant to be inherited from (no virtual destructor), 
this is safe because we never instantiate either of them. We only use their static methods.</p>
<pre><code class="language-C++">// Herb Sutter's GOTW #29
struct ci_char_traits : public char_traits&lt;char&gt; {
    static bool eq(char c1, char c2) { 
        return toupper(c1) == toupper(c2); 
    }

    static bool ne(char c1, char c2) { 
        return toupper(c1) != toupper(c2); 
    }

    static bool lt(char c1, char c2 ){ 
        return toupper(c1) &lt; toupper(c2); 
    }

    static int compare(const char* s1, const char* s2, size_t n) {
        return memicmp(s1, s2, n);
        // case insensitive str compare
    }

    static const char* find(const char* s, int n, char a) {
        while( n-- &gt; 0 &amp;&amp; toupper(*s) != toupper(a) ) {
            ++s;
        }
        return s;
    }
};

using ci_string = std::basic_string&lt;char, ci_char_traits&gt;;
ci_string s1 = &quot;HeLlO&quot;;
ci_string s2 = &quot;helLO&quot;;
s1 == s2; // true
</code></pre>
<p>One thing to remember is that <code>std::vector&lt;int&gt;</code> is not the same type as <code>std::vector&lt;char&gt;</code> and thus <code>std::basic_string&lt;char&gt;</code> is a different type from <code>std::basic_string&lt;char, ci_char_traits&gt;</code>. 
Therefore, using things like <code>operator+()</code> or <code>operator&lt;&lt;()</code> will require you to convert to a c string with <code>c_str()</code> or write functions that work for the new type.</p>
<p>This implementation only supports <code>char</code>, but does a good job getting the point across.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Scott Meyers calls C++ a &quot;federation of languages&quot;: there's the OOP C++ part, what someone commonly will think when they hear C++, C, templates, and the STL. 
C++ as a whole is considered a multi paradigm language because, with a little discipline, you can use it to write in multiple programming paradigms. 
The C part of C++ is conducive towards structural programming, the traditional OOP part towards, obviously OOP and templates towards generic programming. 
I'm not sure if I would classify the STL under a single paradigm, but it is definitely like its own language which does have many features that come from functional programming languages.</p>
<p>I've used a few of these here and there but let's take a deeper look at these facilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdas"><a class="header" href="#lambdas">Lambdas</a></h1>
<p>You've likely seen lambdas in other programming languages, so I'll just get into the C++ specifics.</p>
<p>Lambdas have the syntax:</p>
<pre><code>[]() {

}
</code></pre>
<p>Where <code>[]</code> contains the variables captured by the lambda from the local scope, <code>()</code> encloses the arguments, and <code>{}</code> encloses the code that is part of the lambda. 
Data that is captured is copied into the lambda's <em>closure</em> which is a runtime object that holds copies or references to captured data and is an instance of the
<em>closure class</em> that the lambda belongs to. 
We can think of a lambda as being syntactic sugar for the compiler creating a class which provides an <code>operator()</code>, and instantiating that class like so:</p>
<pre><code class="language-C++">class ClosureClass {
    int myCapture;
public:
    ClosureClass(int myCapture) : myCapture(myCapture) {};
    // think of lambda capture as constructing a member in the closure class

    bool operator()(int myArgument) {
        return myArgument &gt; myCapture;
    }
};

ClosureClass closure(10);
const auto test = closure(20);

// Lambda version:

int myCapture = 10;
const auto lambda = [myCapture](auto arg) {
    return arg &gt; myCapture;
};

const auto test = lambda(20);
</code></pre>
<p>Unlike functions, the arguments in lambdas can be <code>auto</code>, leaving the compiler to deduce their type using the same method it uses to deduce template types. 
The return type is automatically deduced, however it can be manually specified with a trailing return type.</p>
<pre><code class="language-C++">int capture = 10;
const auto lambda2 = [capture](int arg) -&gt; bool {
    return arg &gt; capture;
};
</code></pre>
<p>The variables captured by a lambda are, by default, copied unless you manually request a reference by prepending the variable name with <code>&amp;</code>.<br />
The captured variables are captured once, when the lambda is defined. 
Even though the variables are copied, they are immutable unless you make the lambda a <code>mutable</code> lambda,
which allows the closure to modify the members of the closure class. </p>
<pre><code class="language-C++">int cap = 30;
const auto l2 = [cap]() mutable {
    return --cap;
    // although cap is copied, it cannot be mutated from within the lambda
    // unless you declare the lambda mutable
};

l2();
l2();
const auto r = l2();
// r is 27

cap; // 30

const auto l3 = [&amp;cap]() {
    cap = 20;
    // fine because the closure class member (the reference)
    // isn't changing but the data it refers to is
};

l3();

cap; // 20
</code></pre>
<p>A better way to capture variables is by <em>init-capture</em>. 
This method allows you to move variables into the closure along with making it very clear how each variable is captured. 
It uses the syntax <code>&lt;name&gt; = &lt;expression&gt;</code> where <code>&lt;name&gt;</code> is the name of the variable within the closure that will store the result of <code>&lt;expression&gt;</code>. 
This variable is created by move or copy constructing a new instance of the result of <code>&lt;expression&gt;</code>.</p>
<pre><code class="language-C++">std::unique_ptr&lt;Person&gt; pp;
int num = 0;
Person p;

const auto l4 = [person1 = std::move(pp), num = num, person2 = &amp;p] {
    num; // copied
    person1; // move constructed from pp
    person2; // pointer to p
};
</code></pre>
<p>If we wanted a reference instead of a pointer, we can wrap the data in a <code>std::reference_wrapper&lt;T&gt;</code> using <code>std::ref</code>. 
A <code>std::reference_wrapper</code> provided <em>value semantics</em> (is copyable) for a reference. It is implicitly converted to a <code>T</code> reference, or explicitly with its member function <code>get()</code>. 
It also provides <code>operator()</code> so that if it holds a reference to a callable object, it can directly invoke that callable object without unwrapping it. 
If we wanted a <code>const</code> reference we can create one with <code>std::cref</code>. This is needed because passing a lvalue reference will invoke the copy constructor, and rvalue references will invoke the move constructor. 
Therefore, we wrap the reference in a <code>reference_wrapper</code> which avoids constructing a new instance of the underlying data and instead will construct a new instance of <code>std::reference_wrapper</code>.</p>
<pre><code class="language-C++">const auto l5 = [person3 = std::ref(p)] {
    person3.get().speak();
    const auto name = person3.get().name;
    // person3 is a std::reference_wrapper&lt;Person&gt; not a Person&amp;
    person3.get() = Person();
};
</code></pre>
<p><code>std::reference_wrapper&lt;T&gt;</code> is also useful to allow containers such as <code>std::vector</code> that cannot hold references to be able to do so. 
However <code>std::reference_wrapper</code>, is just, well a <code>reference_wrapper</code> and provides no mechanisms to prevent or check for dangling references. 
In terms of safety, it's not much better than having a container of raw pointers.</p>
<pre><code class="language-C++">std::vector&lt;std::reference_wrapper&lt;int&gt;&gt; nums;

int myNum = 10;
nums.emplace_back(myNum); // emplace forwards arguments to constructor 
// in this case passing an lvalue reference to constructor
// myNum must live at least as long as its reference held in nums

nums.back() = 20;

myNum; //20
</code></pre>
<p>Back to lambdas: there are limitations to what can be captured. 
Static variables cannot be captured and neither can member variables. 
Static variables can be accessed from within a lambda without capturing them, and member variables can be accessed by copying the pointer of the owning instance object.
This means that in both of these cases, the value of the variable will be what the value is at the time the lambda is invoked, and not at the time the lambda is defined.
This is opposite the normal behavior!</p>
<p>Variables in a lambda can be captured by a default capture mode <code>[&amp;] or [=]</code>. 
Default capture modes capture all used variables by reference or by value, respectively. 
You should prefer init capture or enumerating the variables you capture instead of using default capture modes. 
The reason is that default captures make it harder to reason about object lifetimes and realize when certain variables cannot be captured.</p>
<p>Consider we use the default reference capture mode to pass everything by reference. 
You must take care to ensure that the objects you capture outlives the lambda. 
Lambdas are very easy to bring out of the scope they were declared in (say, adding it to a vector)
and thus anything that is captured must live outside the initial scope as well.</p>
<p>To avoid this, you might be tempted to just copy all variables you use with the default copy capture mode. 
But the capture mode <code>[=]</code> to capture by copy doesn't always copy everything you &quot;capture&quot;. 
Remember, when you capture member variables you aren't actually copying them. You are copying the <code>this</code> pointer to the owning object. 
Thus, the default &quot;pass by value&quot; capture is susceptible to the same dangling pointer problem as passing by reference.
Furthermore, using the default copy capture mode might make you think a static variable's value was saved in the closure, however no copy was actually made
and any outside code that mutates the static variable also affects the lambda! 
A static variable &quot;captured&quot; by a default capture mode isn't really captured,
as the code will simply refer to the single instance of the static variable that exists outside the scope of the lambda. 
Therefore, a default capture by value isn't actually capturing everything by value. 
This confusion can be avoided by using <em>init-capture</em>.</p>
<pre><code class="language-C++">class Foo {
private:
    int data;
    Person person;
//...

    // in some member function:
    // bringing the lambda out of the function scope
    callbacks.push_back([=]() {
        return data * 5;
        // data is not copied
        // the this pointer is
        // if this lambda outlives the owning 
        // instance of Foo
        // we'll have a dangling pointer!
    });
    
    // This is what's really happening:
    callbacks.push_back([ptr = this]() {
        return ptr-&gt;data * 5;
    });
    SomeClass c;
    auto p = [=, &amp;c]() {
        // &quot;everything&quot; captured by value except c
    };
    
    // Init capture examples:
    [person = std::move(person), c2 = &amp;c]() {
        // Foo::person is moved to a variable person
        // in the closure
        // c is passed by pointer to a variable c2
        // in the closure
    }
    
}
</code></pre>
<p>The closure class's <code>operator()</code> is by default const. So mutating a captured variable requires declaring your lambda mutable.</p>
<h1 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h1>
<p>Lambdas are a type of callable object, but not the only one. In the header <code>&lt;functional&gt;</code>, the STL provides a generic function class <code>std::function</code> which can wrap any callable object 
(lambdas, function pointers, objects that define <code>operator()</code>, etc.). 
They are copyable and moveable and otherwise work like you might expect from a function. 
They enable us to use higher order programming and to pass function-like objects as values. The syntax for declaring one is as follows:</p>
<pre><code class="language-C++">std::function&lt;ReturnType(Args, ...)&gt;

// example
std::function&lt;void(int, int)&gt;; // takes two integers and returns nothing
std::function&lt;char()&gt;; // returns a char, takes nothing
std::function&lt;int(int, int)&gt;; // returns an int from two ints
</code></pre>
<pre><code class="language-C++">using my_func_t = std::function&lt;int(int, int)&gt;;

int sum(int a, int b) {
    return a + b;
}

struct DivOp {
    int operator()(int a, int b) const {
        return a / b;
    }
};

my_func_t f1 = &amp;sum;
my_func_t f2 = DivOp();
my_func_t f3 = [](auto a, auto b) {
    return a * b;
};
</code></pre>
<p>The syntax <code>ReturnType(Args...)</code> such as <code>int()</code> or <code>char(std::string, int)</code> is the syntax for a function type.
The syntax might be somewhat reminiscent to you of function pointer syntax. You can think of this as the non-pointer function type.</p>
<pre><code class="language-C++">int fun(char c) {
    return c - 'a';
}

using fun_ptr_t = int(*)(char); //function pointer
using fun_val_t = int(char); //function &quot;value&quot;
// I use the term &quot;value&quot;, but functions are not values in C++

fun_ptr_t funPtr1 = &amp;fun;
fun_val_t * funPtr2 = &amp;fun;
</code></pre>
<p>Here are some more <code>std::function</code> examples:</p>
<pre><code class="language-C++">struct Test {
    std::string str;

    void print() const {
        std::cout &lt;&lt; str &lt;&lt; std::endl;
    }
};

std::function&lt;void(const Test&amp;)&gt; func = &amp;Test::print;
Test t = {&quot;Hi&quot;};
func(t); 

std::function&lt;void()&gt; f2 = []() {
    std::cout &lt;&lt; &quot;qwertyuiop&quot; &lt;&lt; std::endl;
};
f2();
</code></pre>
<p>The real power of <code>std::function</code> is to be able to pass callable objects to functions and classes to control behavior. 
However, especially in the case of lambdas, you must be careful not to let a function outlive any references it may use.</p>
<pre><code class="language-C++">/**
* Creates a new container containing only the elements that fell in line
* Order is determined by the function f, which returns true if the first argument should come
*  before the second
*/
template&lt;class Container, typename Element&gt;
auto stalinSort(const Container&amp; container, 
    std::function&lt;bool(const Element&amp;, const Element&amp;)&gt; f) 
    -&gt; std::enable_if_t&lt;std::is_same_v&lt;
        typename std::iterator_traits&lt;decltype(std::declval&lt;Container&gt;().begin())&gt;::value_type,
        Element
    &gt;, Container&gt;
{
    Container result;
    if (container.empty()) return result;
    auto it = container.begin();
    result.push_back(*it);
    it = std::next(it);

    auto last = result.begin();
    for (; it != container.end(); ++it) {
        if (f(*last, *it)) {
            result.push_back(*it);
            // ++last; BAD
            // we cannot just increment last
            // because the container might move 
            // if it needs to reallocate. If this happens
            // last will become invalid
            last = result.begin();
            std::advance(last, result.size() - 1);
        }
    }

    return result;

}

std::vector nums = { 10, 400, 20, 30, 60, 708, -100, 1000 };
auto res = stalinSort&lt;std::vector&lt;int&gt;, int&gt;(nums, [](auto a, auto b) { return a &lt; b; });
// res is 10, 400, 708, 1000
</code></pre>
<h2 id="partial-application-and-bind"><a class="header" href="#partial-application-and-bind">Partial Application and Bind</a></h2>
<p>Generally, lambdas should be preferred to <code>bind</code>, but I do feel it is good to know about. 
Bind can be used to partially apply a callable object.
Partial application is when you supply some, but not all the arguments to a function.
The returned object of a partial application is another callable objects that takes the unspecified arguments.
<code>std::bind</code> takes a callable object, and constructs a <em>bind object</em> from it by copying in the arguments passed to <code>std::bind</code>. 
The bind object works similarly to a closure. 
However, its <code>operator()</code> can only delegate to the callable object that was passed to <code>std::bind</code>. 
The first argument of <code>std::bind</code> is the callable object, if the callable object is a member function then the second argument is a pointer to the
owning instance (or a placeholder). 
Remember, this owning object pointer can really be viewed as the first argument to the function. 
The rest of the arguments are placeholders or parameters bound to the underlying function arguments based on position. 
The arguments passed to <code>std::bind</code> are constructed in the bind object. 
Thus, lvalues are copied into the bind object and rvalues are moved. 
Furthermore, we can use <code>std::placeholders</code> to map arguments of the bind object's <code>operator()</code> to arguments in the underlying callable object. 
Each placeholder has a number that corresponds to the argument index during invocation of the bind object. This is best explained with an example:</p>
<pre><code class="language-C++">class Bar {
public:
    void memberFunction(int a, double &amp; b, char c) {
    }
}
Bar b;
double dub = 0;
auto foo = std::bind(&amp;Bar::memberFunction, &amp;b, 
    5, std::ref(dub), std::placeholders::_1);
// create a bind object for 
// memberFunction belonging to instance b
// to pass a reference, since all variables are 
// copied requires
// wrapping in std::ref()
// all arguments to bind are evaluated at the time 
// of the  call to bind
// the placeholder allows a user to call the bind object 
// with some more arguments

foo('c'); 
// calls b.memberFunction(5, dub, 'c');

char doFoo(std::string name, std::string text);

std::string myStr = &quot;Hello World&quot;;
auto foo2 = std::bind(&amp;doFoo, std::placeholders::_1, myStr);
myStr = &quot;Goodbye&quot;;

char res = foo2(&quot;Joe&quot;); 
// calls doFoo(&quot;Joe&quot;, &quot;Hello World&quot;);

auto foo3 = std::bind(&amp;doFoo, std::placeholders::_2, std::placeholders::_1);
foo3(&quot;Hello&quot;, &quot;World&quot;);
// calls doFoo(&quot;World&quot;, &quot;Hello&quot;)
</code></pre>
<p>References must be wrapped in <code>std::reference_wrapper</code> for the same reason as lambdas. 
Like lambdas, unless you use a <code>reference_wrapper</code>, arguments are evaluated at the call site of <code>std::bind</code>, not at the call site of the bind object.</p>
<pre><code class="language-C++">auto str = &quot;Billy&quot;;
auto foo4 = std::bind(&amp;doFoo, str, std::placeholders::_1);

str = &quot;Joey&quot;;

foo4(&quot;Johns&quot;);
// calls doFoo(&quot;Billy&quot;, &quot;Johns&quot;)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple"><a class="header" href="#tuple">Tuple</a></h1>
<p>Like <code>std::array</code>, <code>std::tuple</code> is a fixed size container, but the difference is it can hold different types. A tuple can be created by enumerating the values it will store in its constructor or using one of the following:</p>
<ul>
<li><code>std::tie()</code>
<ul>
<li>Creates a tuple of lvalue references</li>
</ul>
</li>
<li><code>std::make_tuple()</code>
<ul>
<li>General usage way to make a tuple. Same idea as <code>std::bind</code>, arguments are copy or move constructed.</li>
</ul>
</li>
<li><code>std::forward_as_tuple()</code>
<ul>
<li>Creates a tuple of references, lvalue references if the argument is a lvalue, rvalue references if it's a rvalue.</li>
</ul>
</li>
</ul>
<p>Accessing a tuple uses <code>std::get</code>, which takes either a type or index as the template argument. 
Therefore, you can only use <code>std::get</code> if you know the type or index you want to get at compile time. 
We can use the template <code>std::tuple_size_v&lt;T&gt;</code> to get the size of a tuple, and we can use <code>std::tuple_element_t&lt;I, Tuple&gt;</code> to get the type of index <code>I</code> of tuple <code>Tuple</code>.</p>
<pre><code class="language-C++">std::tuple&lt;int, char, double&gt; myTuple{5, 'c', 83.0};

auto tuple2 = std::make_tuple(23, true, 'a', 5.f);
float f = std::get&lt;3&gt;(tuple2); // gets value at index 3, which is 5.f
bool b = std::get&lt;bool&gt;(tuple2); // gets the first bool in the tuple, which is true

constexpr auto sz = tuple_size_v&lt;decltype(tuple2)&gt;; // 4

using type_2 = tuple_element_t&lt;decltype(tuple), 2&gt;; // double

std::tuple&lt;float&amp;, bool&amp;&gt; t3 = std::tie(f, b);
// tuple holds lvalue references!
// what it refers to must outlive it

std::tuple&lt;bool&amp;, int&amp;&amp;, double&amp;&amp;&gt; t4 = std::forward_as_tuple(b, getInt(), 5.374);
auto c = std::get&lt;0&gt;(t4);
c = false;
 
</code></pre>
<p>What if we need to get a value from a tuple from an index computed at runtime? We can recursively call a template function that has the index as a template argument.</p>
<pre><code class="language-C++">template&lt;class Tuple, size_t N = 0&gt;
constexpr auto dynamicGet(const Tuple&amp; tuple, size_t index) 
    -&gt; std::enable_if_t&lt;N &lt; std::tuple_size_v&lt;Tuple&gt;, std::tuple_element_t&lt;Tuple, N&gt;&gt; 
{
    if (index == N)
        return std::get&lt;N&gt;(tuple);
    else
        return dynamicGet&lt;Tuple, N + 1&gt;(tuple, index);
}

const auto t = std::make_tuple(10, 20);
const auto r = dynamicGet(t, 1);
</code></pre>
<p>Using this function requires the compiler to instantiate a new <code>dynamicGet</code> for the specific tuple type for all indices of the tuple. 
How this works is that we first call <code>dynamicGet&lt;Tuple, 0&gt;</code>. If the runtime index <code>index</code> is equal to the compile time index of the function (<code>N</code>), then we call <code>std::get&lt;N&gt;</code>. 
Otherwise, we call the next <code>dynamicGet</code> function.</p>
<p>Tuples are copyable and moveable if all of their contents are copyable and moveable, respectively. 
Tuples cannot be modified. The only way to do this would be to swap two tuples of the same type. Furthermore, we can make larger tuples by concatenating existing tuples together with <code>std::tuple_cat</code>.</p>
<pre><code class="language-C++">std::tuple&lt;int, double, char&gt; t = std::make_tuple(5, 5.0, 'c');
std::tuple&lt;int, double, char&gt; t2;
// default construct able if each type it 
// holds is as well
t2.swap(t);
std::swap(t, t2);

std::tuple&lt;int, double, char, float, bool&gt; t3 = std::tuple_cat(t2, {500.f, false});
std::get&lt;3&gt;; // 500.f
</code></pre>
<p>The main usage of tuples is for passing or returning multiple things from a function. Returning a tuple should be preferred to output parameters. 
However, accessing the data via <code>std::get</code> is quite annoying. So we can use a <em>structured binding</em> to unpack a tuple. 
A structured binding unpacks a <code>std::tuple</code>, <code>std::array</code>, <code>std::pair</code>, or <code>struct</code>. Each member of a tuple is assigned to the corresponding name specified within the <code>[]</code> of the structured binding. 
The general syntax is as follows:</p>
<pre><code class="language-C++">auto [name_1, name_2, ..., name_n] = std::tuple&lt;type_1, type_2, ..., type_n&gt;();
</code></pre>
<p>The nth value in the tuple is assigned to the nth name in the structured binding. A structured binding must have the same number of names as values in the object being unpacked. 
If <code>auto</code> (or any form of <code>auto</code>) is used, the type of each name is deduced from the unpacking. If you manually specify the type, then all names must have the same type.</p>
<pre><code class="language-C++">struct Bar {
    std::string foo;
    unsigned fizz : 5;
    unsigned buzz : 27;
};

auto [foo, fizz, buzz] = Bar{&quot;Hello&quot;, 30, 120};
// unpacks a struct, left most name in binding corresponds to top left most member in struct definition

std::array myArray = {100, 200, 300};
int [a, b, c] = myArray;
// a = 100, b = 200, c = 300
</code></pre>
<p>Structured bindings make using tuples to return multiple things really easy:</p>
<pre><code class="language-C++">auto myFunc() {
    Person p;
    return std::make_tuple(p, 10);
    // person is copied
}

template&lt;typename T&gt;
auto getForward(T&amp;&amp; t) {
    return std::forward_as_tuple(t, 5);
    // 5 is moved
    // t is forwarded
}

auto [person, count] = myFunc();
// person has type Person
// count has type int

const Person p;
auto&amp;&amp; [p3, num] = getForward(p);
// p3 has type const Person&amp;
// num has type int&amp;&amp;
</code></pre>
<p>Another usage of tuples is to use them to pass arguments to functions via <code>std::apply</code>. <code>std::apply</code> takes a callable object and a tuple which will be unpacked as the arguments for that callable object.</p>
<pre><code class="language-C++">auto f = [](int a, int b){
    return a + b;
};
auto tup = std::make_tuple(50, 23);
auto res = std::apply(f, tup);
//res is 73
</code></pre>
<h1 id="optional"><a class="header" href="#optional">Optional</a></h1>
<p>An optional is a type that may contain a value. It's especially useful for returning something from a function that can fail. 
If an optional contains a value, that value is part of the optional's memory layout. That is to say the value it contains is not dynamically allocated. 
If the optional does not contain a value, that value has yet to be constructed and there is no memory reserved for it. 
Therefore, an optional provides practically no overhead to code that uses them regardless if they are empty or not.</p>
<p>An optional's <code>has_value()</code> member can be used to query if the optional contains a value, the optional is also convertible to <code>bool</code>. 
It has a default constructor that creates an empty optional, and an implicit conversion constructor to convert wrap an object of the contained type into a filled optional. 
We can use <code>operator*</code>, <code>operator-&gt;</code>, or the <code>value()</code> members to get access to the contained value of the optional. 
If the optional does not contain a value when one of these members are called, it throws <code>std::bad_optional_access</code>. 
Remember that dereferencing a <code>nullptr</code> is undefined behavior, however optionals provides a defined result when getting the data of an empty one.</p>
<pre><code class="language-C++">auto opt = std::make_optional(100);
if (opt) {
    std::cout &lt;&lt; *opt &lt;&lt; std::endl;
    // prints 100
}
struct Data {
    int32_t number;
    uint64_t id;
    int16_t fs[100];
};

std::vector&lt;Data&gt; dataFrames;

std::optional&lt;Data&gt; readFile(std::string_view s) {
    std::ifstream stream(s.data(), std::ios::binary);
    if (stream.is_open()) {
        Data d;
        stream.read(reinterpret_cast&lt;char*&gt;(&amp;d), sizeof(Data));
        return d;
    }
    return {}; // default construct, empty optional
}

if (auto result = readFile(&quot;data.bin&quot;); result) {
    // This is called init-if
    // the first statement is the initializer
    // the second is the condition that is tested

    const auto t = result-&gt;number;
    dataFrames.push_back(result.value());
}
</code></pre>
<p>We can construct an element directly in the containing optional with the <code>emplace()</code> member function. 
Furthermore, we can use <code>value_or()</code> to get a default value if one doesn't exist, and use <code>std::nullopt</code> to indicate an empty optional.</p>
<pre><code class="language-C++">std::optional&lt;int&gt; p = std::nullopt; // empty
int v = p.value_or(-1); // p is -1

p.emplace(100);
if (p != std::nullopt) {
    std::cout &lt;&lt; p.value() &lt;&lt; std::endl; // prints 100
    p.reset(); // makes it empty
}
</code></pre>
<p>Optionals are a great tool for error handling, especially when the error might be somewhat expected every now and again. 
For example, a user might enter an incorrect path and the system not being able to open the specified file.</p>
<h1 id="variant"><a class="header" href="#variant">Variant</a></h1>
<p>The Variant is a type safe union. It can hold one of the multiple types specified as template arguments. 
A possible usage of a variant is to return either an error message, or a result from a function. Like an optional, the variant's data is held directly within the variant so no dynamic allocation. 
Furthermore, it does not hold extra data besides the value that is currently stored within it. We can use <code>std::get</code> to get the specified type or index of the variant. 
If the variant does indeed hold that type, the value is returned. 
Otherwise, the exception <code>std::bad_variant_access</code> is thrown. Once again this requires us to know the type or index of the type we want at compile time. 
We can use the <code>std::holds_alternative&lt;T&gt;</code> function to check if the variant holds a value of type <code>T</code>.</p>
<pre><code class="language-C++">
std::variant&lt;int, char, std::string&gt; var = 'H';

if (std::holds_alternative&lt;std::string&gt;(var)) {
    // .. do something with the string
} else if (std::holds_alternative&lt;char&gt;(var)) {
    std::cout &lt;&lt; std::get&lt;char&gt;(var) &lt;&lt; std::endl; // prints 'H'
}
</code></pre>
<p>There is also the <code>std::get_if&lt;T&gt;</code> function which takes a pointer to a variant and returns a pointer to <code>T</code> if the variant contains <code>T</code>. 
Otherwise, the function returns <code>nullptr</code>.</p>
<pre><code class="language-C++">std::variant&lt;Data, std::string&gt; readData(std::string_view s) {
    std::ifstream stream(s.data(), std::ios::binary);
    if (stream.is_open()) {
        try {
            Data d;
            stream.read(reinterpret_cast&lt;char*&gt;(&amp;d), sizeof(Data));
            return d;
        } catch (const std::exception &amp; e) {
            return e.what();
        } catch (...) {
            return &quot;An unknown error occurred while reading file&quot;;
        }
    }
    return &quot;Could not open file&quot;;
}

auto v = readData(&quot;data.bin&quot;);
if (auto ptr = std::get_if&lt;Data&gt;(&amp;v); ptr) {
    Data cpy = *ptr;
    // ...
} else {
    std::cerr &lt;&lt; &quot;An error has ocurred: &quot; &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; std::endl;
}
</code></pre>
<p>Another way to determine what a variant holds besides <code>std::get_if</code> is the member function <code>index()</code> which returns the index of the currently held value's type.</p>
<pre><code class="language-C++">
std::variant&lt;std::string, std::vector&lt;char&gt;, std::vector&lt;unsigned char&gt;&gt; bytes;

if(bytes.index() == 1) {
    //do something with std::vector&lt;char&gt;
}

if(std::holds_alternative&lt;std::string&gt;(bytes)){
    auto str = std::get&lt;std::string&gt;(bytes);
    if(!str.empty()){
        bytes.emplace(std::vector{str[0]});
        // constructs a new value in-place
    }
} 
</code></pre>
<p>As shown in the example, variants also define the <code>emplace()</code> member function for constructing a value directly in the variant.</p>
<p>We can use <code>std::visit</code> to perform a function templated on the type the variant holds. 
Using <em>constexpr if</em> we can perform a different action based on what the variant holds. 
Constexpr if is an if statement that is evaluated at compile time. Thus, when using constexpr if, the compiler can determine which branch is taken and inline that choice directly in the code. 
This makes it look like there wasn't a conditional to begin with if you were to look at the compiled code.</p>
<pre><code class="language-C++">std::variant&lt;char, int, double&gt; getGpa();

auto variant = getGpa();
std::visit([](auto&amp;&amp; gpa) {
    using T = std::decay_t&lt;decltype(gpa)&gt;;
    if constexpr (std::is_same_v&lt;T, char&gt;) {
        printf(&quot;Letter scale\n&quot;);
    }
    else if constexpr (std::is_same_v&lt;T, int&gt;) {
        printf(&quot;Numeric scale\n&quot;);
    }
    else if constexpr (std::is_same_v&lt;T, double&gt;) {
        printf(&quot;4.0 scale\n&quot;);
    }
}, variant);
</code></pre>
<p>What <code>std::visit</code> does is call the supplied function passing in the value held by the variant. 
Notice the use of <code>auto&amp;&amp;</code>, which is essentially a universal reference because visit will pass in different types. So this lambda is essentially a template of sorts. 
A normal template function however wouldn't work, because you'd need to know which instantiation to call, and the fact that we don't have this information is one of the reasons we're using <code>std::visit</code> in the first place. 
<code>std::visit</code> essentially applies the <em>visitor</em> pattern. Here we use one function with constexpr-if to simulate having multiple overloads. 
We also need the <code>std::decay_t</code>, which will remove the reference if the function is passed an lvalue. <code>std::decay_t</code> also decays arrays into pointers, which is functionality not used in this example.</p>
<p>A variant cannot be empty, but if wanted it to be able to hold nothing, we can allow it to hold <code>std::monostate</code> which is basically an empty struct designed to indicate an empty variant. </p>
<pre><code class="language-C++">std::variant&lt;std::vector&lt;int&gt;, std::string, std::monostate&gt; var = std::monostate{};

if (std::holds_alternative&lt;std::monostate&gt;(var)) {
    // empty variant
}
</code></pre>
<h2 id="union"><a class="header" href="#union">Union</a></h2>
<p>I mentioned that <code>variant</code> is a type safe union. So you may be wondering what a union is. Well basically, it's the C way of holding a value of one or multiple types all within the same area of memory. 
All members of a union are stored in the same memory location, so a union only takes up the amount of space needed for its largest member.</p>
<pre><code class="language-C++">
union MyUnion {
    int num;
    std::string name;
    unsigned flag : 1;
    unsigned long long id;
};

MyUnion un;
un.name = &quot;Peach&quot;;
sizeof(MyUnion) == sizeof(std::string); // largest member

un.flag = 0;
</code></pre>
<p>A common usage for <code>union</code> is to set the memory as one type, and read it off as another to essentially perform a <code>reinterpret_cast</code>. 
This is called <em>type punning</em> and is <strong>undefined behavior</strong> in C++ (but not C). Thus, in C++, you should only read from a member that has the same type as the actual stored value. 
Given this, I cannot think of a situation where a union would be preferable to <code>std::variant</code>.</p>
<h1 id="any"><a class="header" href="#any">Any</a></h1>
<p><code>std::any</code> is another utility type similar to <code>variant</code>, <code>optional</code>, and <code>tuple</code>, but <code>any</code> holds only 1 value of <em>any</em> type, as the name may suggest. 
We can check if a <code>std::any</code> has a value via the <code>has_value()</code> member function. 
We can also get the <code>std::type__info&amp;</code> of the stored type via the <code>type()</code> member function. Mutating the <code>any</code> can be done with the assignment operator, <code>swap()</code>, or <code>emplace()</code> just like a variant.</p>
<pre><code class="language-C++">std::any any = 1;
std::cout &lt;&lt; any.type().name() &lt;&lt; std::endl;
//compiler dependent but likely &quot;int&quot;
any = 3.14;
std::cout &lt;&lt; any.type().name() &lt;&lt; std::endl;
//compiler dependent but likely &quot;double&quot;

if(any.has_value()){
    any.emplace&lt;std::string&gt;(&quot;something new&quot;);
}
</code></pre>
<p>Getting a value stored from an any can be done with <code>std::any_cast</code>. We can also construct an any with <code>std::make_any</code>. 
<code>any_cast</code> allows type safe retrieval of the value in the any. It will throw an exception if the RTTI of the type parameter and the stored value do not match.</p>
<pre><code class="language-C++">auto anything = std::make_any(20);

int n = std::any_cast&lt;int&gt;(anything);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h1>
<p>STL algorithms are in the <code>&lt;algorithms&gt;</code> header. These are generic algorithms which operate on pairs of iterators (a start and end iterator). 
C++20 includes versions of these algorithms that operate on ranges and views. This is discussed more in the C++20 section
of the book, but ranges and views are basically like an abstraction over a pair of iterators.
Often times they will take a callable object to perform some computation. 
Whenever you write a for loop, the first though should be &quot;is there an algorithm which does this for me?&quot;. 
Generally, we want to use algorithms as much as possible because they help us avoid making simple indexing or iterator mistakes and are well tested. 
As we'll see later, some algorithms may also take an execution policy as their first argument. The execution policy changes their concurrency behavior. 
Thus, using STL algorithms, one parameter is all it takes to convert sequential code to concurrent code. 
I'll briefly discuss a few common ones, but more information can be found on the documentation of the algorithms library.</p>
<p>A predicate is a function that takes in an element and returns true if that element matches the criteria. 
A comparator is a function that takes in two arguments and returns true if the first argument should be ordered before the second.</p>
<p>If you are familiar with functional programming, some of the algorithms are very much like common operations in functional
languages such as <code>map</code> or <code>fold</code>. I indicate that in the following list with the phrase &quot;analogous to ...&quot; or &quot;similar to ...&quot;</p>
<ul>
<li><code>std::for_each(It begin, It end, Func f)</code> - analogous to <code>iterate</code>
<ul>
<li>Calls <code>f</code>, passing in the dereferenced iterator for all elements between <code>begin</code> and <code>end</code></li>
</ul>
</li>
<li><code>std::for_each_n(It begin, Size num, Func)</code> - analogous to <code>take</code>
<ul>
<li>Same as <code>for_each</code> but takes a number indicating the amount of elements to iterate through starting from <code>begin</code>.</li>
</ul>
<pre><code class="language-C++">std::array a = {600, 97, 3784, 474, 3, 906, 0};
std::for_each_n(a.begin(), 3, [](auto e) {
    std::cout &lt;&lt; e &lt;&lt; &quot;, &quot;;
});
// 600, 97, 3784, 
</code></pre>
</li>
<li><code>std::all_of</code>/<code>std::any_of</code>/<code>std::none_of</code> <code>(It begin, It end, Func pred)</code>
<ul>
<li>Iterates through and applies a predicate which takes the dereference of the iterator and returns a bool</li>
</ul>
</li>
<li><code>std::count(It begin, It end, T elem)</code>
<ul>
<li>Iterates through and counts how many elements equal <code>elem</code></li>
</ul>
</li>
<li><code>std::count_if(begin, end, pred)</code>
<ul>
<li>Same as <code>count</code> but counts how many times the predicate returns true</li>
</ul>
</li>
<li><code>std::find(begin, end, elem)</code>
<ul>
<li>Returns the iterator to the first element that equals <code>elem</code> or <code>end</code> if not found</li>
<li><code>std::find_if</code> is the same but takes a predicate instead of an element</li>
</ul>
</li>
<li><code>std::copy(begin, end, dstBegin)</code>
<ul>
<li>Copies elements from range to a new area beginning at <code>dstBegin</code>. Does not check whether <code>dstBegin</code> is valid or can support the amount of elements in the range</li>
<li><code>std::copy_if(begin, end, dstBegin, pred)</code> - similar to <code>filter</code>
<ul>
<li>Same as copy but only copies if the predicate returns true for that element</li>
</ul>
</li>
</ul>
</li>
<li><code>std::copy_backward(begin, end, dst)</code>
<ul>
<li>Same as copy but stores the elements in <code>dst</code> backwards</li>
</ul>
</li>
<li><code>std::move(begin, end, dst)</code>, <code>std::move_backward(begin, end, dst)</code>
<ul>
<li>Self explanatory</li>
</ul>
</li>
<li><code>std::fill(begin, end elem)</code>
<ul>
<li>Assigns <code>elem</code> to every iterator in the range</li>
<li><code>std::fill_n(begin, count, elem)</code></li>
</ul>
</li>
<li><code>std::generate(begin, end, f)</code>
<ul>
<li>Assigns the result of calling <code>f</code> to every iterator in the range</li>
<li><code>std::generate_n(begin, count, f)</code></li>
</ul>
<pre><code class="language-C++">std::vector&lt;int&gt; nums(100); // 100 integers
std::generate(nums.begin(), nums.end(), [count = 0]() mutable {
    return count++;
});

std::vector&lt;char&gt; letters;
std::generate_n(std::back_inserter(letters), 100, [](){ return 'A'; });
letters.size(); //100
</code></pre>
</li>
<li><code>std::transform(begin, end, [optional 2nd range begin], dstBegin, func)</code> - analogous to <code>map</code>, and <code>zip</code>
<ul>
<li>Iterates through a range or two, calls the function and stores the result of that function in the destination range</li>
<li>The second range must be at least as large as the first</li>
<li>Func takes in the underlying value of the iterator from the first range as the first argument, and if a second range is specified, the value of the second second as the second argument</li>
</ul>
<pre><code class="language-C++">std::vector a = {100, 200, 300};
std::array b = {100.0, 50.1, -300.67};
std::vector&lt;double&gt; out;

std::transform(a.begin(), a.end(), b.begin(), std::back_inserter(out),
    [](auto a, auto b) {
        return a + b;
    });
// out is {200.0, 250.1, -0.67}

// transform in-place is allowed
std::transform(a.begin(), a.end(), a.begin(),
    [](auto a) {
        return a * 2;
    });
// a is 200, 400, 600
</code></pre>
</li>
<li><code>std::swap_ranges(begin, end, otherBegin)</code>
<ul>
<li>Swaps the values of each element in two equal sized ranges</li>
</ul>
</li>
<li><code>std::iter_swap(a, b)</code>
<ul>
<li>Swaps the underlying value of two iterators</li>
</ul>
</li>
<li><code>std::shuffle(begin, end, [optional function which returns a randomly selected iterator difference_type or a UniformRandomBitGenerator])</code>
<ul>
<li>Randomly rearranges the elements</li>
</ul>
</li>
<li><code>std::rotate(begin, new_begin, end)</code>
<ul>
<li>Rotates the elements in <code>begin</code> to <code>end</code> to the left so that the iterator <code>new_begin</code> becomes the first element of the resulting range</li>
</ul>
</li>
<li><code>std::sample(begin, end, out, count, gen)</code>
<ul>
<li>Selects <code>count</code> elements at random from <code>begin</code> and <code>end</code> and writes them to <code>out</code> using <code>gen</code> (a random number generator) as a source or randomness</li>
</ul>
</li>
<li><code>std::unique(begin, end)</code>
<ul>
<li>Removes consecutive duplicates from the range</li>
<li>Removal is done by moving all elements to be removed to the back of the iterator range, then returning a new ending iterator that does not include these removed elements</li>
<li><code>std::unique_copy(begin, end, out)</code> - same but does not perform in-place</li>
</ul>
</li>
<li><code>std::remove_if(begin, end, predicate)</code>
<ul>
<li>Removes all elements satisfying the predicate by moving them to the end of the iterator range</li>
<li>Returns an iterator to the first removed element which is also an iterator off the back of the range of remaining elements</li>
</ul>
<pre><code class="language-C++">std::vector v = {100, 200, 300, 400, 500, 600};
const auto new_end = 
    std::remove_if(v.begin(), v.end(), [](auto e) { return e &lt;= 300; });

for(auto num : v) {
    std::cout &lt;&lt; num &lt;&lt; std::endl;
}
// Prints 400, 500, 600, then the remaining numbers (probably: 100, 200, 300)

for(auto it = v.begin(); it != new_end; ++it) {
    std::cout &lt;&lt; *it &lt;&lt; std::endl;
}
// Only prints 400, 500, 600 
</code></pre>
</li>
<li><code>std::partition(begin, end, pred)</code>
<ul>
<li>Partitions a range so that elements that satisfy <code>pred</code> are at the beginning of the range and those that don't are at the end</li>
<li>Returns an iterator to the point at which the range is partitioned</li>
<li><code>std::partition_copy</code> - same idea but not in place</li>
</ul>
</li>
<li><code>std::sort(begin, end, [optional comparator])</code></li>
<li><code>std::stable_sort(being, end, [optional comparator])</code> - sort that guarantees that elements that compare equally are kept in the same order as they were</li>
<li><code>std::lower_bound(begin, end, elem, [optional comparator])</code>
<ul>
<li>Returns an iterator to the first element &gt;= to <code>elem</code> or <code>end</code> of no such element is found</li>
<li>Requires <code>begin</code> and <code>end</code> be sorted or partitioned on <code>val &lt; elem</code> (ascending order)</li>
<li>Think of finding the lower bound of a series of <code>elem</code> within the range</li>
<li>The comparator defines what &lt; means in this context. Will get the first element in which calling the comparator returns <code>false</code>. The comparator returns true if the first argument is ordered before the second.</li>
</ul>
</li>
<li><code>std::upper_bound(begin, end, elem, [optional comparator])</code>
<ul>
<li>Same as lower_bound but finds first element &gt; <code>elem</code> or <code>end</code> if no such element is found</li>
<li>Think of finding the upper bound of a series of <code>elem</code> within the range</li>
</ul>
</li>
<li><code>std::binary_search(begin, end, val, [optional comparator])</code>
<ul>
<li>Returns true if <code>val</code> is present, false otherwise</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">// Requires begin and end be sorted in ascending order
// gets iterator to first iter that equals elem or end if not found
template&lt;typename Iter, typename T&gt;
auto binarySearch(Iter begin, Iter end, T elem) {
    const auto e = std::lower_bound(begin, end, elem);
    return *e == elem ? e : end;
}
</code></pre>
<ul>
<li><code>std::merge(begin, end, begin2, end2, out)</code>
<ul>
<li>Merges two sorted ranges and puts the result starting from the <code>out</code> iterator</li>
</ul>
</li>
<li><code>std::make_heap(begin, end, [optional comparator])</code>
<ul>
<li>Makes the range a max heap</li>
</ul>
</li>
<li><code>std::push_heap(begin, end, elem, [optional comparator])</code>
<ul>
<li>Appends an element to an existing heap</li>
</ul>
</li>
<li><code>std::pop_heap(begin, end, [comparator])</code></li>
<li><code>set_union</code>, <code>set_intersection</code>, <code>set_difference</code>
<ul>
<li>Treats two ranges as sets and performs the set operation</li>
</ul>
</li>
<li><code>max_element</code>, <code>min_element</code>, <code>minmax_element</code>
<ul>
<li>gets the max, min, and min and max, respectively from a range</li>
</ul>
</li>
<li><code>lexicographic_compare(begin, end, begin2, end2, [comparator])</code>
<ul>
<li>returns true if the first range is lexicographically less than the second</li>
</ul>
</li>
</ul>
<p>The following are part of the <code>&lt;numeric&gt;</code> header</p>
<ul>
<li>
<p><code>std::iota(begin, end, start)</code></p>
<ul>
<li>Fills the range with sequentially increasing values starting from <code>start</code></li>
</ul>
</li>
<li>
<p><code>std::accumulate(begin, end, start, [optional operation])</code> - similar to <code>fold_left</code> or <code>reduce</code></p>
<ul>
<li>Sums all the elements in the range with an initial value of <code>start</code></li>
<li>If a binary function is passed, calls that function with the first argument as the current accumulation value (initialized to <code>start</code>) and the second argument as the current value in the range. The returned value becomes the new accumulated value</li>
<li><code>std::reduce</code> is similar to <code>accumulate</code> but it can take an execution policy, and the initial value is optional</li>
</ul>
<pre><code class="language-C++">const std::vector v = {10.0, 5.4, 2, -1.2};
const auto pi_v = std::accumulate(v.begin(), v.end(), 1, [](auto a, auto b) {
    return a * b;
}); // 1 (initial value) * 10 * 5.4 * 2 * -1.2
</code></pre>
</li>
<li>
<p><code>std::partial_sum(begin, end, out, [optional op])</code></p>
<ul>
<li>Same as accumulate except saves each accumulation step as a separate element in <code>out</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-templates"><a class="header" href="#advanced-templates">Advanced Templates</a></h1>
<p>In this chapter we'll look at some more generic programming techniques, along with some more ways we can run computations at compile time.</p>
<p>Many compilers have a <em>step-limit</em>, which roughly correlates to how many times they'll recurse before stopping compilation.
Compile-time computations are recursive, and this step-limit ensures that compilation doesn't take too long.
Most compilers have an option to increase the step-limit if you need to.</p>
<h2 id="a-word-about-generic-programming"><a class="header" href="#a-word-about-generic-programming">A Word about Generic Programming</a></h2>
<p>Let's talk about generic programming for a bit. The goal of generics is to define an implementation in terms of types that we don't yet know. Contrast that to OOP where we do know the type, but we don't know the implementation. It accomplishes many of the same goals as OOP, but in a different way. I want to first define a few terms that I'll use without explanation:</p>
<ul>
<li><strong>static interface</strong> - An interface is an interface, the term is mostly agnostic to programming paradigms and means the same in OOP and here. However I use the term <em>static interface</em> to explicitly refer to a common interface shared by different classes. The static interface is essentially the concepts our generic algorithms require of the generic types passed to them.</li>
<li><strong>static polymorphism</strong> - Once again, polymorphism is polymorphism in OOP and Generics. However when I say <em>static polymorphism</em> I explicitly refer to the way in which we can pass different classes that uphold the same static interface to a generic algorithm.</li>
</ul>
<p>Here's an example comparing OOP and Generics:</p>
<pre><code class="language-C++">// This is our interface
class Vehicle {
public:
    virtual ~Vehicle() = default;

    virtual void transport() const = 0;
}

// subtyes of our interface/implementations of interface
class Car : public Vehicle {
    //...
}

class Plane : public Vehicle {
    //...
}



// polymorphic usage
// any class that inherits from Vehicle can be used
void travel(const Vehicle&amp; vehicle) {
    vehicle.transport();
}


// C++ 20 implementation so it looks closer to OOP
// this is our interface
template&lt;typename T&gt;
concept Animal = requires(T t) {
    { t.makeSound() } -&gt; std::same_as&lt;void&gt;;
}

//implementations of interface
class Bird {
public:
    void makeSound() {/*...*/}
}

class Dog {
public:
    void makeSound() {/*...*/}
}


// polymorphic usage
// any class that defines a void makeSound() function can be used
template&lt;Animal AnimalType&gt;
void animalSound(const AnimalType&amp; animal) {
    animal.makeSound();
}
</code></pre>
<p>I use C++20 concepts to make it easier to see the similarities. However the same idea applies even if you use C++17 techniques
or a simple requires clause in the spec of <code>animalSound()</code>. OOP incurs runtime cost of the extra memory for the virtual table,
extra indirection for dynamic dispatch, and extra indirection for use of pointers. Templates however, slow down compilation and
typically lead to larger binary sizes due to the need for the compiler to generate a new class/function for every type it's
instantiated with. Sometimes, templates have to be used if you want to merge two class heirarchies that you cannot modify.
For example, you might be using two libraries, each with their own heirarchy of vector/matrix classes. </p>
<p>In this chapter, we'll look at more techniques and strategies for template programming.</p>
<blockquote>
<p>&quot;The keys to an engineer's heart are acronyms. Lots and lots of acronyms.&quot;</p>
<p>- Me, 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constexpr"><a class="header" href="#constexpr">Constexpr</a></h1>
<p><code>constexpr</code> isn't really a template, but serves as a method of doing compile time computations.
<code>constexpr</code> denotes that an expression may be evaluated as a compile-time constant expression, provided its dependencies
(function arguments, etc.) are also constant expressions.</p>
<p>A <code>constexpr</code> variable must be: a literal type, immediately initialized, and the expression initializing the variable must also be a constant expression.
<code>constexpr</code> variables must also have a constant destruction, meaning it is not an array or non-literal class. In C++20, a <code>constexpr</code> variable can also be a class
provided it has a <code>constexpr</code> destructor.</p>
<p>A <code>constexpr</code> function must not be <code>virtual</code> and its arguments and return type must be literal types. The function body of a <code>constexpr</code> function
must not contain definitions of static or non-literal variables, try blocks, inline assembly, or uninitialized variable definition. The latter three are
no longer required in C++20.</p>
<p>We've discussed what a literal type is before: scalars or primitive types, references, and arrays of literals, just to name a few examples.
However, literal types can also be <em>literal classes</em>, which are classes with a trivial destructor. 
Literal classes must also have at least one <code>constexpr</code> constructor, be an aggregate type (struct with no user-defined constructor or union),
or be a closure type (lambda). Literal classes must have data members that are also literals.</p>
<p>The <code>constexpr</code> constructor of a literal class must satisfy the requirements of a <code>constexpr</code> function and initialize every data member. C++20 allows
<code>constexpr</code> destructors, however in C++17 the destructor must be compiler-generated.</p>
<p>Literal classes may also have <code>constexpr</code> member functions, which are <strong>not</strong> implicitly <code>const</code> members (they were in C++11).
So, making a <code>constexpr</code> member unable to change the state of the class requires the <code>const</code> qualifier just like a normal member function.</p>
<pre><code class="language-C++">class Rational {
    int num, den;
public:
    constexpr Rational(int numerator, int denominator = 1) :
        num(numerator), den(denominator) {}

    constexpr explcit operator double() const {
        return num / static_cast&lt;double&gt;(den);
    }

    constexpr Rational operator-() const {
        return {-num, den};
    }

    constexpr Rational&amp; operator++() {
        num += den;
        return *this;
    }

    friend constexpr auto operator*(const Rational&amp; a, const Rational&amp; b) {
        return Rational(a.num * b.num, a.den * b.den);
    }
};
</code></pre>
<p>If an exception is thrown during a constant expression during compile-time evaluation, that exception stops compilation.
The compiler error you'll probably see might be something along the lines of &quot;... failed to result in a constant expression&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-meta-programming"><a class="header" href="#template-meta-programming">Template Meta Programming</a></h1>
<p>We've actually been using this technique a bit already with SFINAE. Template meta programming allows us to use template specialization to compute results as compile time. 
Fun fact: TMP was actually <em>discovered</em>, not created on purpose. For many use cases, <code>constexpr</code> functions are easier to read and write, however TMP
must still be used for &quot;computing&quot; types.</p>
<p>Let's create a TMP struct to compute the factorial of a number.</p>
<pre><code class="language-C++">template&lt;int num&gt;
struct Factorial {
    constexpr int value = num * Factorial&lt;num - 1&gt;::value;
};

template&lt;&gt;
struct Factorial&lt;0&gt; {
    constexpr int value = 1;
};

template&lt;int i&gt;
using factorial_v = Factorial&lt;i&gt;::value;

constexpr auto f = factorial_v&lt;5&gt;;
</code></pre>
<p>When we instantiate the struct <code>Factorial&lt;5&gt;</code>, it sets the <code>value</code> member to be <code>5 * Factorial&lt;4&gt;::value</code>.
Then <code>Factorial&lt;4&gt;</code> is instantiated, and its member <code>value</code> is initialized as <code>4 * Factorial&lt;3&gt;::value</code>.
Then <code>Factorial&lt;3&gt;</code> is instantiated and its <code>value</code> member becomes <code>3 * Factorial&lt;2&gt;::value</code>.
This continues until we get to <code>Factorial&lt;0&gt;</code>, whose <code>value</code> member is initialized with the constant <code>1</code>
because of the specialization we defined.</p>
<p>So the general gist of TMP is to create a recursive <code>struct</code>, where the base case is implemented as a template specialization.</p>
<p>Computing values at compile time should be done with <code>constexpr</code> functions, but there are cases where TMP is needed. These types of problems
often require us to compute a type.
Let's say we want to return a type if a condition is true, and a different one if it's false:</p>
<pre><code class="language-C++">template&lt;bool condition, typename TrueType, typename FalseType&gt;
struct Conditional {
    using type = TrueType;
};

template&lt;typename TrueType, typename FalseType&gt;
struct Conditional&lt;false, TrueType, FalseType&gt; {
    using type = FalseType;
};


template&lt;bool condition, typename TrueType, typename FalseType&gt;
using if_t = typename Conditional&lt;condition, TrueType, FalseType&gt;::type;
// we need the typename keyword because type is a member type alias
// of a template type
</code></pre>
<p>If the condition argument to <code>Conditional</code> is true, the primary definition is used and <code>type</code> is an alias for <code>TrueType</code>.
If the condition is false, the <code>Conditional</code> specialization is used and <code>type</code> is an alias for <code>FalseType</code>.</p>
<p>Using this, let's create a way to get the minimum iterator category from a sequence of different iterator types. We'll start with creating a
<code>constexpr</code> function that converts iterator tags to numbers so that we can order the iterator tags from least to most restricting.</p>
<pre><code class="language-C++">/**
* Gets a number representing the functionality of an iterator where 0 is an input/output
* and higher numbers allow for more functionality.
*/
template&lt;typename Iter&gt;
constexpr auto get_iter_num() 
    -&gt; std::enable_if_t&lt;!std::is_same_v&lt;void, typename std::iterator_traits&lt;Iter&gt;::iterator_category&gt;, int&gt; 
    // enable the function only if the type has an iterator_category in iterator_traits
    // return `int` if Iter is an iterator
{
    using T = typename std::iterator_traits&lt;Iter&gt;::iterator_category;
    // get tag type

    if constexpr (std::is_same_v&lt;T, std::input_iterator_tag&gt; || std::is_same_v&lt;T, std::output_iterator_tag&gt; )
        return 0;
    else if constexpr (std::is_same_v&lt;T, std::forward_iterator_tag&gt;) 
        return 1;
    else if constexpr (std::is_same_v&lt;T, std::bidirectional_iterator_tag&gt;)
        return 2;
    else if constexpr (std::is_same_v&lt;T, std::random_access_iterator_tag&gt;)
        return 3;
}


/// Gets the minimum iterator from a pack of iterators
template&lt;typename Min, typename Head, typename ... Iters&gt;
struct MinIter {
private:
    using cur_min_t = if_t&lt;get_iter_num&lt;Min&gt;() &lt; get_iter_num&lt;Head&gt;(),
        MinIter, Head&gt;;
    // the &quot;smallest&quot; between the current Min and head of pack
    // the type with the smaller iterator number is assigned to the alias cur_min_t

    using tail_min_t = typename MinIter&lt;cur_min_t, Iters...&gt;::type;
    // the min of the tail of the pack
    // recursive step
public:
    using type = if_t&lt;get_iter_num&lt;cur_min_t&gt;() &lt; get_iter_num&lt;tail_min_it&gt;(),
        cur_min_t, tail_min_t&gt;;
};

template&lt;typename Min, typename Head&gt;
struct MinIter&lt;Min, Head&gt; {
    // this is the base case when the tail of the pack is empty

    using type = if_t&lt;get_iter_num&lt;Min&gt;() &lt; get_iter_num&lt;Head&gt;(),
        MinIter, Head&gt;;
};


/// Gets the first type in a parameter pack
template&lt;typename H, typename ... Tail&gt;
struct PackHead {
    using type = H;
};


/// Minimum iterator type (returns the iterator itself)
template&lt;typename ... Iters&gt;
using min_iter_t = typename MinIter&lt;typename PackHead&lt;Iters...&gt;::type, Iters...&gt;::type;

/// Gets the minimum iterator category
template&lt;typename ... Iters&gt;
using min_iter_tag = typename std::iterator_traits&lt;min_iter_t&lt;Iters...&gt;&gt;::iterator_category;
</code></pre>
<p>Let's say we wanted to chain together multiple iterators into a single iterator. It would make sense that this aggregate iterator would have the category of the weakest iterator it
is composed of. Hence, we can use TMP to query what this minimum iterator category is.</p>
<p>Notice the use of <code>using</code> declarations in <code>MinIter</code> to &quot;store&quot; the intermediate result. The using declaration is basically like the TMP version of defining variables.</p>
<p>We use the <code>typename Head, typename ... Iters</code> arguments to unpack the head of the parameter pack into <code>Head</code>, and the rest is put into the <code>Iters</code> parameter pack.
This allows us to pass a parameter pack and be able to query the type of the first element in the pack.</p>
<p>It's common to denote the TMP calculation's result type as a member named <code>type</code>, and a result value as a member named <code>value</code>. </p>
<p>Let's look at another TMP technique, <em>tag dispatch</em>. The idea is to use a struct that has no members to use as a type to switch between different overloads or specializations of a function.
This is the idea behind iterator tags, such as <code>std::random_access_iterator_tag</code>. Instead of having a conditional at runtime determine which function to call, the decision can be made by the
compiler, reducing runtime cost. Let's call a different function depending on the size of a type:</p>
<pre><code class="language-C++">template&lt;size_t i&gt;
struct Int2Type {
    constexpr auto value = i;
    // or
    enum : size_t { value = i };

    // just provides public access to the value
    // members are unnecessary in this example
};
// because different instantiations of a template are different types
// then different sizes passed to Int2Type&lt;&gt; instantiate different Int2Type types

void doFoo(Int2Type&lt;4&gt;);
void doFoo(Int2Type&lt;2&gt;);
void doFoo(Int2Type&lt;1&gt;);

doFoo(Int2Type&lt;sizeof(int)&gt;{});
// correct overload is called and inlined into the compiled code by the compiler.
</code></pre>
<p>We've seen how we can do something similar with <code>constexpr if</code> and template specialization.
<em>Tag dispatch</em> is just another tool in the toolbox that you may find optimal for some problems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curiously-recurring-template-pattern"><a class="header" href="#curiously-recurring-template-pattern">Curiously Recurring Template Pattern</a></h1>
<p>CRTP is a template pattern where a derived class inherits from a template base class, and the derived class is the type argument for the base class.
So something like this:</p>
<pre><code class="language-C++">template&lt;typename T&gt;
class Base {
    Base() = default;
    friend class Derived; // allow Derived to construct Base
    // This private constructor makes the Base only constructable
    // from the Derived class. This prevents us from using Base incorrectly

    // static_asserts or SFINAE could also be used

};

class Derived : public Base&lt;Derived&gt; {

};
</code></pre>
<p>So what's the purpose of this? Well with this setup, code in the Base class automatically knows what the dynamic type is because the actual type is passed as a template argument.
This makes it safe to <code>static_cast</code> instead of <code>dynamic_cast</code> which saves the runtime cost of RTTI type checks. This ability can be used to implement a generic version of
mixins. </p>
<p>In OOP, a mixin is basically a small class that provides a named set of functionality to different types. These mixins are not designed to stand on their own and are typically narrow in scope.
For example, you can have a mixin that might provide serialization functionality. Instead of each class having a <code>to_json</code> and <code>from_json</code> method, you can have all classes that you might want
JSON serialization functionality for inherit <code>JSONSerializationMixin</code> which provides said methods. 
As you can imagine, there isn't necessarily much in common between the &quot;children&quot; of a mixin; it doesn't define a hierarchy.
You can have a <code>Device</code> class use the mixin, and a <code>Student</code> class; there isn't necessarily a &quot;sibling&quot; relationship.</p>
<p>So back to CRTP, we can use it as a way to add functionality, similar to a mixin, that can be shared between different classes.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
class Geometry {
    Geometry() = default;
    friend class Square;
    friend class Rectangle;

    int geom_length() {
        if constexpr (std::is_same_v&lt;T, Square&gt;) {
            return static_cast&lt;T&amp;&gt;(*this).sideLen();
            // static cast is safe
        } else {
            return static_cast&lt;T&amp;&gt;(*this).length();
        }
    }

    int geom_width() {
        if constexpr (std::is_same_v&lt;T, Square&gt;) {
            return static_cast&lt;T&amp;&gt;(*this).sideLen();
        } else {
            return static_cast&lt;T&amp;&gt;(*this).width();
        }
    }

public:

    int area() {
        return geom_length() * geom_width();
    }

    int perimeter() {
        return 2 * geom_length() + 2 * geom_width();
    }

    int volume(int height) {
        return area() * height;
    }
};

class Square : public Geometry&lt;Square&gt; {
puiblic:
    int sideLen() { /*...*/ }
};

class Rectangle : public Geometry&lt;Rectangle&gt; {
puiblic:
    int length() { /*...*/ }
    int width() { /*...*/ }
};
</code></pre>
<p><code>static_cast</code> won't remove <code>const</code>, so if calling a constant member you must cast to a <code>const</code> reference to the derived type.</p>
<pre><code>//Usage:

Square s;
s.area();

template&lt;typename T&gt;
void doFoo(Geometry&lt;T&gt; &amp; geom) {
    // being a type argument to Geometry already limits what T can be
    // no need for SFINAE or even a requires clause in the spec

    std::cout &lt;&lt; geom.volume(10) &lt;&lt; std::endl;
}

Rectangle r;

doFoo(r);
doFoo(s);

</code></pre>
<p>A benefit of this over template non-member functions is that this makes it very clear which classes support which helper functions. 
Consider that we also had a <code>Circle</code> class. As written, the functions in <code>Geometry</code> won't support our <code>Circle</code>, so if <code>Geometry</code> was a set of non-member functions,
we'd have to document that they didn't support <code>Circle</code> and we could also use SFINAE to ensure the user doesn't accidentally pass a <code>Circle</code>.
And look, I'm basically a crazy masochist and even I get tired of writing out all the structs to emulate C++20 concepts when I can't use them.
Furthermore, it's an added burden on the user to have to remember what helper functions use which classes. CRTP also makes these non-member functions clearly part of the interface of Square and Rectangle.
This isn't to say that CRTP is the best solution, but it's an alternative.</p>
<p>I view common applications of CRTP and SFINAE as <em>defensive programming</em> techniques. The goal here is to make your interfaces idiot proof.
Imagine there is a little gremlin (maybe you at 2AM) who is trying to use your interfaces incorrectly; template non-member functions that bind to any type
are good targets for this nasty little guy. Both SFINAE and CRTP can be applied to restrict what types can be passed to these functions, thus making them
more protected from misuse.</p>
<p>Notice that CRTP doesn't use any virtual functions. While this does cut down on runtime cost, it also makes functions in the base class susceptible to shadowing.
If you use this pattern, you should ensure that the base class members have different names than any member in any derived class.</p>
<p>So that's one application of CRTP. Another one is to create static interfaces similar to how the STL container adapters work. 
The advantage with CRTP over an adapter is that we can use private members. Let's create an interface that provides a <code>size</code> method.</p>
<pre><code class="language-C++">template&lt;class T&gt;
class Container {
    Container() = default;
    friend class MyRange;
    friend class MyVec;

public:
    size_t size() const {
        return static_cast&lt;const T&amp;&gt;(*this).size();
    }
};

class MyRange : public Container&lt;MyRange&gt; {
public:
    size_t size() const {
        return std::distance(begin, end);
        // imagine this class stores a begin and end iterator
    }
};

class MyVec : public Container&lt;MyVec&gt; {
public:
    size_t size() const {
        return dataSize;
        // dataSize could be an internal member storing size
    }
};
</code></pre>
<p>Notice the subtle difference in flow of control. In this example, the implementation is in the derived class while in the previous one the
implementation was in the base class.</p>
<p>The name collision in this case is safe since the base and derived class <code>size</code> member functions do the same thing.</p>
<p>Now to use this:</p>
<pre><code class="language-C++">MyRange mr;
MyVec mv;

template&lt;typename T&gt;
void doFoo(const Container&lt;T&gt; &amp; container) {
    std::cout &lt;&lt; container.size() &lt;&lt; std::endl;
}


doFoo(mr);
doFoo(mv);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="policy-based-design"><a class="header" href="#policy-based-design">Policy Based Design</a></h1>
<p>I've talked about this a bit before in the main templates chapter. This is a continuation of that discussion.</p>
<p>In a way, PBD is another form of generic mixins. We design small, narrow focused classes, that provide functionality to a wide range of unrelated classes. 
A big difference is that PBD focuses on providing points of customization. Not only are we extracting out repeated functionality into its own class, but by
making these policies a template argument, we allow users to easily change behavior of a policy-holder class by changing one of its policies.</p>
<p>We've seen this with allocators, smart pointer deleters, <code>std::char_traits</code>, comparators, predicates, and hash functions in the STL.</p>
<h2 id="template-template-parameters"><a class="header" href="#template-template-parameters">Template-template Parameters</a></h2>
<p>A common technique used with PBD are <em>template-template parameters</em>: template type parameters that are themselves template types. This is especially useful
when a type passed directly to the policy-holder would also be passed to its policies as well.</p>
<pre><code class="language-C++">// Template Arguments:
MyVec&lt;int, MyCmp&lt;int&gt;, MyAllocator&lt;int&gt;, MyHash&lt;int&gt;&gt;

// Template-Template arguments
MyVec&lt;int, MyCmp, MyAllocator, MyHash&gt;
</code></pre>
<p>The syntax for such a type argument is to put a <code>template&lt;typename&gt;</code> before the <code>typename</code> of the policy in the template argument list:</p>
<pre><code class="language-C++">template&lt;typename T,
    template&lt;typename&gt; class Comparator,
    template&lt;typename&gt; class Alloc = MyAllocator,
    template&lt;typename S&gt; class Hash = MyHash&gt; //name this template-template argument as S
</code></pre>
<p><code>template-template</code> parameters can have multiple template arguments, they could also be given template argument names. When you use these arguments as concrete types, you must also specify the type parameter.</p>
<pre><code class="language-C++">// template arguments above
class MyVec {
    T * data;
    size_t data_sz;
public:
    explicit MyVec(size_t len) :
        data(MyAllocator&lt;T&gt;::alloc(len)) {}
        // MyAllocator is a template, we must pass the type to it
        // call static function alloc on MyAllocator
    
    ~MyVec() {
        MyAllocator&lt;T&gt;::free(data);
    }
};
</code></pre>
<h2 id="dependent-names"><a class="header" href="#dependent-names">Dependent Names</a></h2>
<p>A dependent name is essentially a name that relies on a template argument to get resolved. Basically these are the members of a template type or template type argument.
By default, the compiler interprets dependent names as values, which is why we needed the <code>typename</code> keyword when accessing a member type alias.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
using type = MyVec&lt;T&gt;::type;
// Compiler has no idea what `type` is
// by default it assumes it's some value
// which is why we need to add `typename`
</code></pre>
<p>The compiler could wait until the template is instantiated before checking this, however many compilers don't in order to give the error to the author of the code and not an unsuspecting client.</p>
<p>Consider the following:</p>
<pre><code class="language-C++">T::doSomething&lt;int()&gt;(5);
</code></pre>
<p>The compiler could interpret this three ways:</p>
<ol>
<li>Call a function <code>doSomething</code> that takes a type argument which is a callable object that accepts no parameters and returns <code>int</code> and pass that function <code>5</code></li>
<li>Instantiate a template type <code>T::doSomething</code> with the template argument <code>int()</code> (type of parameter-less callable object returning <code>int</code>) and initialize it with <code>5</code>.</li>
<li>Call <code>operator&lt;</code> on a value <code>T::doSomething</code> with the no-parameter initializer for type <code>int</code> (which is 0) and then check if the integral value of the resulting boolean is greater than 5.</li>
</ol>
<p>We can tell the compiler to use option 2 with the <code>typename</code> keyword, and option 1 with the <code>template</code> keyword.</p>
<pre><code class="language-C++">T::template doSomething&lt;int()&gt;(5); // #1
typename T::doSomething&lt;int()&gt;{5}; // #2
T::doSomething &lt; int() &gt; (5); // #3
</code></pre>
<p>Generally speaking, use <code>typename</code> to access a type alias of a template type, and use <code>template</code> to call a template method of a template type. <code>template</code> can also be used after <code>.</code> and <code>-&gt;</code> too.</p>
<hr />
<p>For more information, take a look at <a href="http://index-of.co.uk/C++/C++%20Design%20Generic%20Programming%20and%20Design%20Patterns%20Applied.pdf">Modern C++ Design</a> by Andrei Alexandrescu.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-erasure"><a class="header" href="#type-erasure">Type Erasure</a></h1>
<p>What if we needed to store a vector of different types? Well, if we wrote all the classes we want to store in the vector, we could use inheritance and store <code>std::reference_wrapper</code>s to the base class.
Instead, let's say we have a bunch of different classes with a similar static interface, but are not part of an OOP hierarchy. For that, we need type erasure.</p>
<p>The gist of type erasure is to create a template holder class which does nothing but forward function calls to object it contains. Then we make this holder class inherit from our concept interface.
This inheritance is key to allow multiple different types (instantiations of the holder, aka model, class) to be used where an interface is expected. We can then store <code>reference_wrapper</code>s of this
Concept interface in the vector, or wrap the concept in our own class. That probably made no sense, so let's break it down.</p>
<p>Let's say we have these two concrete classes:</p>
<pre><code class="language-C++">struct Duck {
    void quack() {};
};

struct Duckish {
    void quack() {};
};
</code></pre>
<p>The concept we are trying to store in our container is something that sounds like a duck (has a <code>void quack()</code> method). 
Since these two classes are fundamentally different types, we cannot store them together in a container.</p>
<pre><code class="language-C++">struct DuckLike {
    virtual ~DuckLike() = default;
    virtual void quack() = 0;
};
</code></pre>
<p>What we would like to do is something like this:</p>
<pre><code class="language-C++">std::vector&lt;std::reference_wrapper&lt;DuckLike&gt;&gt; ducks;
</code></pre>
<p>However, our concrete classes (<code>Duck</code> and <code>Duckish</code>) do not implement our concept interface (<code>DuckLike</code>). So we need an intermediary step. 
We'll create a template that requires all template type arguments to uphold the static interface of our concept. Then, we'll make this template implement the dynamic interface.
Effectively, what type erasure is doing is converting static polymorphism into dynamic polymorphism, or said another way: generic polymorphism into oop polymorphism.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
class DuckHolder : public DuckLike {
    T duck;
public:
    template&lt;typename U&gt;
    DuckHolder(U&amp;&amp; duck) : duck(std::forward&lt;U&gt;(duck)) {}
    // a universal reference must be on a template function
    // if we used T, the constructor wouldn't be a template and T&amp;&amp; would
    // be an rvalue reference

    // this is because there would only be one constructor for DuckHolder&lt;T&gt;
    // a universal reference accepting function, essentially becomes multiple
    // in the compiled binary (like any other template) so that you can bind
    // both rvalue and lvalue references to it

    void quack() override {
        duck.quack();
    }
}
</code></pre>
<p>Using our DuckHolder, we can then use generic polymorphism where dynamic polymorphism is required.</p>
<pre><code class="language-C++">ducks.push_back(DuckHolder{ Duck() });
ducks.push_back(DuckHolder{ Duckish() });
</code></pre>
<p>Instead of using <code>std::reference_wrapper</code>, we could also define our own wrapper object, or use smart pointers.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="iterator-chain"><a class="header" href="#iterator-chain">Iterator Chain</a></h2>
<p>Let's design a class to have similar syntax and semantics to Python and Rust's <code>chain</code>. What we'll do is make a more abstract version of our Rope class.
A chain will be able to chain together objects with a <code>begin()</code> and <code>end()</code> function so that they can be iterated over by one iterator.
We'll want this iterator to be <code>const</code> if any of the containers' iterators are <code>const</code>.
For simplicity, we'll make the <code>chain</code> iterator random access, however it won't truly be random access unless all the iterators it is composed of
are random access as well. This is because technically, random access iterators require <code>O(1)</code> random access; however, for iterators that don't support
that, the random access iterator methods of <code>chain</code> (such as <code>operator[]</code>) will have <code>O(n)</code> lookup time.</p>
<p>We actually already designed a <code>min_iter_tag</code> template which can be used to prevent the user from having to keep track of what iterators are part of the chain
before using certain iterator features.</p>
<p>Let's see some example usage:</p>
<pre><code class="language-C++">std::vector v = {10, 20, 30, 50};
auto init_lst = {50, 60, 70, 20};
std::list ls = {100, 200, 300};

for (auto e : chain(v, lst, ls)) {
    std::cout &lt;&lt; e &lt;&lt; &quot;, &quot;;
}
std::cout &lt;&lt; std::endl;

auto c = chain(ls, v);
std::sort(c); // mutates ls and v

</code></pre>
<p>Let's start with a dynamic way to access tuple elements:</p>
<pre><code class="language-C++">/**
* Returns the result of calling the specified function on the tuple element
*
* @param tup the tuple
* @param idx the index of the element to get from the tuple
* @param f the function that accepts the element at index `idx`
*   and returns a result that is returned from this function
*/
template &lt;class Func, class Tuple, size_t N = 0&gt;
decltype(auto) tupleGet(Tuple&amp; tup, size_t idx, Func f) {
    if (N == idx) {
       return f(std::get&lt;N&gt;(tup));
    }

    if constexpr (N + 1 &lt; std::tuple_size_v&lt;Tuple&gt;) {
        return tupleGet&lt;Func, Tuple, N + 1&gt;(tup, idx, f);
    }
    else {
        throw std::invalid_argument(
            std::format(&quot;{} is &gt;= than tuple length {}&quot;, N + 1, std::tuple_size_v&lt;Tuple&gt;));
        // std::format is C++20, I'm being lazy here
    }
}
</code></pre>
<p>We've seen this before; this method just allows us to index a tuple at runtime.</p>
<p>Type alias helpers:</p>
<pre><code class="language-C++">/// reference type of Containers iterator
template&lt;class Container&gt;
using iter_reference_t = std::remove_const_t&lt;
    typename std::iterator_traits&lt;decltype(std::declval&lt;Container&gt;().begin())&gt;::reference&gt;;

/// pointer type of Containers iterator
template&lt;class Container&gt;
using iter_pointer_t = std::remove_const_t&lt;
    typename std::iterator_traits&lt;decltype(std::declval&lt;Container&gt;().begin())&gt;::pointer&gt;;

/// const and reference removed T
template&lt;typename T&gt;
using base_type = std::remove_const_t&lt;std::remove_reference_t&lt;T&gt;&gt;;
</code></pre>
<p>SFINAE helpers:</p>
<pre><code class="language-C++">/// value is true if Container has the same base iter type as IterType
template&lt;typename IterType, class Container, typename = void&gt;
struct IsSameIterType : std::false_type {};

/// value is true if Container has the same base iter type as IterType
template&lt;typename IterType, class Container&gt;
struct IsSameIterType&lt;IterType, Container, std::enable_if_t&lt;
        std::is_same_v&lt;base_type&lt;IterType&gt;, base_type&lt;iter_reference_t&lt;Container&gt;&gt;&gt;
    &gt;&gt; : std::true_type {};

/// true if all containers have the same iter type as FirstContainer
/// @see IsSameIterType
template&lt;class FirstContainer, class ... Containers&gt;
constexpr inline auto are_all_same_iter_v =
    (... &amp;&amp; IsSameIterType&lt;iter_reference_t&lt;FirstContainer&gt;, Containers&gt;::value);

template&lt;bool Condition, typename TrueType, typename FalseType&gt;
struct conditional {
    using type = FalseType;
};

template&lt;typename TrueType, typename FalseType&gt;
struct conditional&lt;true, TrueType, FalseType&gt; {
    using type = TrueType;
};

/// type is HeadType
template&lt;typename HeadType, typename ... Tail&gt;
struct Head {
    using type = HeadType;
};

/// type is HeadType
template&lt;typename HeadType&gt;
struct Head&lt;HeadType&gt; {
    using type = HeadType;
};

/// first type in List
template&lt;typename ... List&gt;
using first = typename Head&lt;List...&gt;::type;

template&lt;typename ... Containers&gt;
constexpr inline auto is_any_iter_const = (... || std::is_const_v&lt;iter_reference_t&lt;Containers&gt;&gt;);
</code></pre>
<p>Class definition:</p>
<pre><code class="language-C++">template&lt;typename ... Containers&gt;
class chain {
    std::tuple&lt;Containers&amp; ...&gt; containers;
public:
    chain(Containers&amp; ... containers) : containers(std::tie(containers...)) {
        static_assert(are_all_same_iter_v&lt;Containers...&gt;, 
            &quot;Iterators passed to chain must have the same value type and volatility&quot;);
    }

    chain(chain&lt;Containers...&gt;&amp;&amp;) = default;
    chain&lt;Containers...&gt;&amp; operator=(chain&lt;Containers...&gt;&amp;&amp;) = default;

    auto begin() const {
        return iter(this, 0, 0);
    }

    auto end() const {
        return iter(this, sizeof...(Containers), 0);
    }

    class iter {
        const std::tuple&lt;Containers&amp; ...&gt;* containers;
        unsigned curContainer, curIndex;


        template&lt;typename ... List&gt;
        using first_iter = decltype(std::declval&lt;first&lt;List...&gt;&gt;().begin());

        using self_t = chain&lt;Containers...&gt;::iter;
    public:
        using value_type = typename std::iterator_traits&lt;first_iter&lt;Containers...&gt;&gt;::value_type;
        using reference = typename conditional&lt;is_any_iter_const&lt;Containers...&gt;,
            std::add_const_t&lt;iter_reference_t&lt;first&lt;Containers...&gt;&gt;&gt;,
            iter_reference_t&lt;first&lt;Containers...&gt;&gt;&gt;::type;
        using pointer = typename conditional&lt;is_any_iter_const&lt;Containers...&gt;,
            std::add_const_t&lt;iter_pointer_t&lt;first&lt;Containers...&gt;&gt;&gt;,
            iter_pointer_t&lt;first&lt;Containers...&gt;&gt;&gt;::type;
        using difference_type = typename std::iterator_traits&lt;first_iter&lt;Containers...&gt;&gt;::difference_type;
        using iterator_category = std::random_access_iterator_tag;

        template&lt;typename DiffType&gt;
        friend auto operator+(self_t t, DiffType diff) 
            -&gt; std::enable_if_t&lt;std::is_integral_v&lt;DiffType&gt;, self_t&gt; 
        {
            auto res = t;
            bool keepLooping = true;
            while (keepLooping) {
                if (res.curContainer &gt;= 
                    std::tuple_size_v&lt;std::remove_reference_t&lt;decltype(*res.containers)&gt;&gt;)
                    break;
                tupleGet(*t.containers, res.curContainer, [&amp;](auto&amp; tup) {
                    const auto dist = std::distance(tup.begin(), tup.end());
                    if (res.curIndex + diff &gt;= dist) {
                        ++res.curContainer;                       
                        diff -= (dist - res.curIndex);
                        res.curIndex = 0;
                    }
                    else {
                        res.curIndex += diff;
                        keepLooping = false;
                    }
                });
            }
            return res;
        }
        template&lt;typename DiffType&gt;
        friend auto operator+(DiffType diff, const self_t&amp; t) 
            -&gt; std::enable_if_t&lt;std::is_integral_v&lt;DiffType&gt;, self_t&gt; 
        {
            return t + diff;
        }

        template&lt;typename DiffType&gt;
        friend auto operator-(self_t t, DiffType diff) 
            -&gt; std::enable_if_t&lt;std::is_integral_v&lt;DiffType&gt;, self_t&gt; 
        {
            auto res = t;
            bool keepLooping = true;
            while (keepLooping) {
                if (diff &gt; res.curIndex &amp;&amp; res.curContainer &gt; 0) {
                    diff -= (res.curIndex + 1);
                    res.curIndex = 
                    tupleGet(*t.containers, --res.curContainer, [&amp;](auto&amp; tup) {
                        const auto dist = std::distance(tup.begin(), tup.end());
                        return dist == 0 ? 0 : dist - 1;
                    });
                }
                else if (diff &lt;= res.curIndex) {
                    res.curIndex -= diff;
                    keepLooping = false;
                }
                else {
                    throw std::invalid_argument(std::format(&quot;&quot;));
                }
            }
            return res;
        }
        template&lt;typename DiffType&gt;
        friend auto operator-(DiffType diff, self_t t) 
            -&gt; std::enable_if_t&lt;std::is_integral_v&lt;DiffType&gt;, self_t&gt; 
        {
            return t - diff;
        }




        iter(const chain&lt;Containers...&gt;* parent, unsigned curContainer, unsigned curIndex) :
            containers(&amp;parent-&gt;containers), curContainer(curContainer), curIndex(curIndex) {}

        //iter() : parent(nullptr), curContainer(sizeof...(Containers)), curIndex(0) {}

        iter(const self_t&amp; other) = default;
        self_t&amp; operator=(const self_t&amp; other) = default;
        iter(chain&lt;Containers...&gt;::iter&amp;&amp; other) = default;
        self_t&amp; operator=(self_t &amp;&amp; other) = default;

        reference operator*() {
            return const_cast&lt;reference&gt;(*const_cast&lt;const self_t&amp;&gt;(*this));
        }

        std::add_const_t&lt;reference&gt; operator*() const {
            if (curContainer &gt;= sizeof...(Containers))
                throw std::out_of_range(&quot;Chain container index out of range&quot;);
            return
                *tupleGet(*containers, curContainer, [this](auto&amp; tup) {
                    auto it = tup.begin();
                    std::advance(it, curIndex);
                    return static_cast&lt;pointer&gt;(&amp;*it);
                });

        }

        self_t&amp; operator++() {
            tupleGet(*containers, curContainer, [this](auto&amp; tup) {
                auto it = tup.begin();
                std::advance(it, curIndex + 1);
                if (it == tup.end()) {
                    curIndex = 0;
                    ++curContainer;
                }
                else {
                    ++curIndex;
                }
             });
            return *this;
        }

        self_t operator++(int) {
            auto cpy = *this;
            ++(*this);
            return cpy;
        }

        auto operator==(const chain&lt;Containers...&gt;::iter&amp; other) const {
            return (other.containers == containers || other.containers == nullptr || containers == nullptr)
                &amp;&amp; other.curIndex == curIndex &amp;&amp; other.curContainer == curContainer;
        }

        auto operator!=(const chain&lt;Containers...&gt;::iter&amp; other) const {
            return !(*this == other);
        }

        auto operator-(self_t other) const {
            auto cntIdx = curContainer;
            auto index = curIndex;
            difference_type diff = 0;
            while (cntIdx &gt; other.curContainer) {
                diff += index;
                index = 
                tupleGet(*containers, --cntIdx, [&amp;](auto&amp; tup) {
                    return std::distance(tup.begin(), tup.end());
                });
            }
            return diff + index - other.curIndex;
        }

        bool operator&lt;(self_t other) const {
            return curContainer &lt; other.curContainer || curIndex &lt; other.curIndex;
        }
        bool operator&gt;(self_t other) const {
            return curContainer &gt; other.curContainer || curIndex &gt; other.curIndex;
        }
        bool operator&lt;=(self_t other) const {
            return *this &lt; other || *this == other;
        }
        bool operator&gt;=(self_t other) const {
            return *this &gt; other || *this == other;
        }

        self_t&amp; operator+=(difference_type d) {
            *this = *this + d;
            return *this;
        }

        self_t&amp; operator-=(difference_type d) {
            *this = *this - d;
            return *this;
        }

        self_t&amp; operator--() {
            *this -= 1;
            return *this;
        }

        self_t operator--(int) {
            auto cpy = *this;
            --(*this);
            return cpy;
        }

        reference operator[](difference_type diff) const {
            if (diff &gt; 0) {
                return *(*this + diff);
            }
            else {
                return *(this - std::abs(diff));
            }
        }
    };
};
</code></pre>
<p>Notice the two <code>operator-</code>. One takes another iterator, and returns the difference between the two iterators. 
The other <code>operator-</code> takes an iterator and difference type and moves the iterator similarly to <code>operator+</code>.</p>
<h2 id="iterator-zip"><a class="header" href="#iterator-zip">Iterator Zip</a></h2>
<p>Let's create a class <code>zip</code>, that can be constructed from an arbitrary amount of different containers. The definition for our
container concept is just a type that contains a semantically correct <code>begin()</code> and <code>end()</code> method.
Because I'm being a tad lazy, I'm going to forego the SFINAE enforcement of this concept.</p>
<p><code>zip</code> will simply have <code>begin()</code> and <code>end()</code> methods that return a forward iterator that iterates over all the containers at once.
&quot;De-referencing&quot; this iterator will return a tuple of the values of de-referencing iterators to all the containers.
The iterator will just be a forward iterator, and iteration will continue until the smallest container has been completely iterated through.</p>
<p>Let's start with the <code>zip</code> class which will be pretty simple. We'll store a tuple of references to containers.
We must use a tuple so that we can have an unknown amount of members of different types.</p>
<pre><code class="language-C++">template&lt;typename ... Containers&gt;
class zip {
    std::tuple&lt;Containers&amp;...&gt; containers;
public:
    zip(Containers&amp; ... containers) : containers(std::tie(containers...)) {}

    class iterator;

    iterator begin() {
        return iterator(containers);
    }

    iterator end() {
        return iterator();
    }

    const iterator begin() const {
        return iterator(containers);
    }

    const iterator end() const {
        return iterator();
    }
};
</code></pre>
<p><code>std::tie</code> creates a tuple of lvalue references; no constructor is called for any of the tuple elements.
<code>std::make_tuple</code> will copy or move construct each element of the tuple.
We declare the <code>zip</code> iterator class, which we'll define outside the <code>zip</code> class for neatness.</p>
<p>Notice that since <code>zip</code> holds references to containers, it must not outlive any container passed to it.</p>
<p>We'll make the iterator's default constructor construct an invalid iterator.
The iterator will need access to the <code>zip</code> class containers tuple.</p>
<pre><code class="language-C++">template&lt;typename ... Cs&gt;
class zip&lt;Cs...&gt;::iterator {
    bool invalid;
    std::tuple&lt;decltype(std::declval&lt;Cs&gt;().begin())...&gt; iterators;
    std::tuple&lt;decltype(std::declval&lt;Cs&gt;().end())...&gt; ends;
    
    using this_t = zip&lt;Cs...&gt;::iterator;

    template&lt;size_t N = 0&gt;
    bool is_end_iter() const {
        if constexpr (N &lt; sizeof...(Cs)) {
            return std::get&lt;N&gt;(iterators) == std::get&lt;N&gt;(ends) ||
                is_end_iter&lt;N + 1&gt;();
        }
        else {
            return false;
        }
    }
public:
    iterator(const std::tuple&lt;Cs&amp;...&gt; &amp; context) : invalid(false) {
        std::apply([this](auto&amp; ... containers) {
            iterators = std::make_tuple(containers.begin()...);
            ends = std::make_tuple(containers.end()...);
        }, context);
    }
    iterator() : invalid(true) {}

//...
</code></pre>
<p>We'll use an <code>invalid</code> flag to denote an iterator that reached the end of the smallest container.
Default constructing the zip iterator will set this flag to true.</p>
<p>We'll also store an iterator for each container, and the end iterator for each container.
Therefore, we can determine when the zip iterator is done iterating by testing if any of
the iterators equals its corresponding end iterator. This is what the <code>is_end_iter</code> method does.
If <code>N</code>, the integral template argument is less than the amount of containers we're iterating over,
then we check if the Nth iterator equals the Nth sentinel iterator. If it does, we return <code>true</code>.
Otherwise, we recurse and test the <code>N + 1</code> iterator.
If <code>N</code> is greater or equal to the amount of containers, then we simply return <code>false</code>, which is
the null element for boolean or. That is to say that <code>x == x || false</code>.</p>
<p>Let's look at the constructor. We use <code>std::apply</code> to unpack the elements of a tuple into
arguments of a variadic lambda. We can then use <code>std::make_tuple</code> and fold expressions to construct a tuple from
begin and end iterators. <code>containers</code> are passed by reference to avoid copies. Notice how we capture the <code>this</code>
pointer. If you remember, this is because we cannot capture member variables directly, but instead we must capture
the <code>this</code> pointer to the object they belong to.
<code>std::apply</code> is used because we cannot use a fold expression over template arguments. So the following won't compile:</p>
<pre><code class="language-C++">template&lt;typename ... Indicies&gt;
auto getTuple(Indicies ... indicies) {
    // where indicies is a pack of integers
    return std::make_tuple(std::get&lt;indicies&gt;(iterators)...);

    // expanding a pack inside the &lt;&gt; is fine,
    // but expanding a pack over the &lt;&gt; is not
}
</code></pre>
<p>Next, our iterator needs to support equality testing. Two <code>zip</code> iterators will be equal if they are both invalid
or their <code>iterators</code> tuple is the same.</p>
<pre><code class="language-C++">    bool operator==(const this_t&amp; other) const {
        return invalid &amp;&amp; other.invalid ||
            iterators == other.iterators;
    }

    bool operator!=(const this_t&amp; other) const {
        return !(*this == other);
    }
</code></pre>
<p>For de-referencing the iterator, we'll use a similar tactic as the constructor: use <code>std::apply</code> to unpack
the <code>iterators</code> tuple as arguments to a lambda. This lambda will then dereference each iterator, and use <code>std::tie</code>
to return a tuple of references.</p>
<pre><code class="language-C++">    auto operator*() {
        if (invalid)
            throw std::out_of_range(&quot;Attempt to derefence end iterator&quot;);
        return
            std::apply([this](auto&amp; ... iters) {
                return std::tie(*iters...);
            }, iterators);
    }

    auto operator*() const {
        if (invalid)
            throw std::out_of_range(&quot;Attempt to derefence end iterator&quot;);
        return
            std::apply([this](auto&amp; ... iters) {
            return std::tie(std::add_const_t&lt;decltype(*iters)&gt;(*iters)...);
                }, iterators);
    }
</code></pre>
<p>Lastly, we'll need to define <code>operator++</code>. Once again, we'll use <code>std::apply</code> to unpack the tuple elements as
arguments to a variadic lambda. Then we'll fold over <code>operator,</code> to increment each iterator. The comma operator in C++
is a binary operator that evaluates its left argument, then evaluates and returns the right argument.</p>
<pre><code class="language-C++">auto i = 0;

auto j = i += 10, i++;
// j is 10
// i is 11

auto k = &quot;Hello World&quot;, 0;
// k is 0
</code></pre>
<p>Since we only care about the side effects of the <code>++</code> operation, it doesn't matter that we discard the result of
incrementing them. After incrementing the iterators, we'll check if any of them equal their ending iterator.
If so, we'll set the <code>invalid</code> flag to <code>true</code>.</p>
<pre><code class="language-C++">    //this_t is a type alias for zip&lt;Cs...&gt;::iterator

    this_t&amp; operator++() {
        std::apply([](auto&amp; ... iters) {
            (++iters, ...);
        }, iterators);
        if (is_end_iter())
            invalid = true;
        return *this;
    }

    this_t operator++(int) {
        auto cpy = *this;
        ++(*this);
        return cpy;
    }
</code></pre>
<p>Finally, don't forget the type aliases we need for iterators! Here's the complete code:</p>
<pre><code class="language-C++">#pragma once
#include &lt;tuple&gt;
#include &lt;stdexcept&gt;


template&lt;typename ... Containers&gt;
class zip {
    std::tuple&lt;Containers&amp;...&gt; containers;
public:
    zip(Containers&amp; ... containers) : containers(std::tie(containers...)) {}

    class iterator;

    iterator begin() {
        return iterator(containers);
    }

    iterator end() {
        return iterator();
    }

    const iterator begin() const {
        return iterator(containers);
    }

    const iterator end() const {
        return iterator();
    }
};

template&lt;typename ... Cs&gt;
class zip&lt;Cs...&gt;::iterator {
    bool invalid;
    std::tuple&lt;decltype(std::declval&lt;Cs&gt;().begin())...&gt; iterators;
    std::tuple&lt;decltype(std::declval&lt;Cs&gt;().end())...&gt; ends;
    
    using this_t = zip&lt;Cs...&gt;::iterator;

    template&lt;size_t N = 0&gt;
    bool is_end_iter() const {
        if constexpr (N &lt; sizeof...(Cs)) {
            return std::get&lt;N&gt;(iterators) == std::get&lt;N&gt;(ends) ||
                is_end_iter&lt;N + 1&gt;();
        }
        else {
            return false;
        }
    }
public:
    iterator(const std::tuple&lt;Cs&amp;...&gt; &amp; context) : invalid(false) {
        std::apply([this](auto&amp; ... containers) {
            iterators = std::make_tuple(containers.begin()...);
            ends = std::make_tuple(containers.end()...);
        }, context);
    }
    iterator() : invalid(true) {}

    bool operator==(const this_t&amp; other) const {
        return invalid &amp;&amp; other.invalid ||
            iterators == other.iterators;
    }

    bool operator!=(const this_t&amp; other) const {
        return !(*this == other);
    }

    auto operator*() {
        if (invalid)
            throw std::out_of_range(&quot;Attempt to derefence end iterator&quot;);
        return
            std::apply([this](auto&amp; ... iters) {
                return std::tie(*iters...);
            }, iterators);
    }

    auto operator*() const {
        if (invalid)
            throw std::out_of_range(&quot;Attempt to derefence end iterator&quot;);
        return
            std::apply([this](auto&amp; ... iters) {
            return std::tie(std::add_const_t&lt;decltype(*iters)&gt;(*iters)...);
                }, iterators);
    }

    this_t&amp; operator++() {
        std::apply([](auto&amp; ... iters) {
            (++iters, ...);
        }, iterators);
        if (is_end_iter())
            invalid = true;
        return *this;
    }

    this_t operator++(int) {
        auto cpy = *this;
        ++(*this);
        return cpy;
    }

public:
    using difference_type = ptrdiff_t;
    using reference = decltype(*std::declval&lt;this_t&gt;());
    using value_type = std::remove_reference_t&lt;reference&gt;;
    using pointer = value_type*;
    using iterator_category = std::forward_iterator_tag;

};
</code></pre>
<p>And here's some usage examples:</p>
<pre><code class="language-C++">std::vector v5 = { -100, 40, 30, 700, 600, 300, 100, -50, 47, 573, 48 };
auto lst = { 'a', 'b', 'c', 'd' };
for (auto [letter, num] : zip(lst, v5)) {
    std::cout &lt;&lt; &quot;(&quot; &lt;&lt; letter &lt;&lt; &quot;, &quot; &lt;&lt; num &lt;&lt; &quot;)\n&quot;;
}
// (a, -100)
// (b, 40)
// (c, 30)
// (d, 700)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<p>Concurrent code can execute non-sequentially, or out of order. When something is concurrent, that <strong>does not</strong> imply that it will occur <em>in parallel</em>,
meaning at the exact same time as something else. <em>Parallelism</em> is when code executes <em>in parallel</em>, sometimes referred to as truly concurrent.</p>
<p>To explain the difference, let's look at the following example:</p>
<pre><code class="language-C++">int foo(int x) {
    int a = 10 * x * x;
    int b = 20 * x;
    int c = 30;
    return a + b + c
}

execConcurrent([]() { return foo(2); }); // task A
execConcurrent([]() { return foo(4); }); // task B
</code></pre>
<p>Consider we run this code on a system with a single logical CPU core. There is no hardware to support executing this code in parallel,
but we can still execute the code concurrently. From a programmer's perspective, the two functions may start and end at the same time,
but on a hardware level, there is no support in this example for the system to execute two instructions at once, or a single instruction
on multiple pieces of data. So the system might execute the code like this:</p>
<pre><code>A calls foo(2)
B calls foo(4)
A assigns A_a to 10 * 2 * 2
B assigns B_a to 20 * 4
A assigns A_b to 20 * 2
A assigns A_c to 30
B assigns B_b to 20 * 4
A computes the sum
B assigns B_c to 30
B computes the sum
B returns the sum
A returns the sum
</code></pre>
<p>This is concurrency because instructions were not executed sequentially for a given program; instructions of two tasks were interleaved.
However, it is not parallelism because instructions were executed linearly and one at a time.</p>
<p>When using the concurrency API, there's no easy way to know if code is running in parallel, or just concurrently.
And truthfully, it doesn't matter.</p>
<blockquote>
<p>&quot;All race conditions, deadlock conditions, and concurrent update problems are due to mutable variables.&quot;</p>
<p>- Uncle Bob</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>A thread is a parallel mode of execution. 
Whether it's truly parallel or not is a different story but from a programmer's perspective, things on two separate threads can occur at the same time. 
C++11 provides <code>std::thread</code>. Every joinable thread (we'll discuss that in a minute) has a thread id which can be used to identify threads. 
The id can be copied, stored and compared with other thread ids.
The actual implementation is abstracted, so do not assume it is an integer.
To get it you can call the member function <code>get_id()</code> or <code>std::this_thread::get_id()</code> to get the id of the current thread your code is running on.</p>
<p>A thread is constructed similarly to a bind object. It takes a callable object (including member function pointers) followed by any arguments to call it with and executes that right away on a new thread.</p>
<pre><code class="language-C++">std::thread t([]() {
auto cur id = std::this_thread::get_id();
// this code runs at the same time
});
t.get_id();
// as this code

A a;
std::thread t2(&amp;A::workerThread, &amp;a);
// note a must outlive t2
</code></pre>
<p>A thread can be joined or detached. When you detach a thread,
you sever the connection with it, and let it run in the background.
Most modern OSs will clean them up when your application terminates.
When you join a thread, you wait for it to finish before moving on.
A thread is said to be <em>joinable</em> if it has neither been detached nor joined previously, and it was not default constructed (so it was provided with something to run). </p>
<p>Let me pose a question for you. What do you think should happen when a joinable thread is destroyed?
Should the application wait for the thread to finish or detach the thread?
If you said &quot;not sure&quot;, well that's basically the answer the C++ Standard Committee concluded.
If you join on destruction, then there's the possibly this could cause horrible hidden blocks in you code as your code must wait for the thread to finish.
If you detach it on destruction then there's almost the certain possibility than any outside state it uses (say things captured in a lambda) will be destroyed.
At best this will look like an invalid memory access, and the code will throw, at worst this will look like some garbage or half garbage
(maybe only the last byte in the object is reused) leading to broken invariants and hard-to-find bugs.
So what happens? Well the program terminates. The Committee took the &quot;dead programs tell no lies&quot; approach.
Thus, you must make sure a thread is <strong>unjoinable on all paths</strong>. If this sounds like &quot;performing some action no matter what&quot;, then you might already be thinking RAII. </p>
<pre><code class="language-C++">void myFunc();

std::thread m(&amp;myFunc);

if(m.joinable())
m.detach(); // sever ties with thread

class jthread {
private:
    std::thread t;
public:
    template&lt;typename ... Args&gt;
    jthread(Args&amp;&amp; ... args) {
        t = std::thread(std::forward&lt;Args&gt;(args)...);
    }
    
    jthread() = default;
    // default constructed thread is not joinable 
    // (no thread is started)
    
    
    ~jthread() {
        if(t.joinable())
            t.join();
    }
}
</code></pre>
<p>Threads are move only. This intuitively makes sense. How could we make a unique copy?
We could start a new thread using the same callable object,
but a user might not expect such behavior and not make their callable object safe to be run on two independent threads.</p>
<p>Threads are limited resources. Earlier I used the term &quot;truly&quot; concurrent because that hardly ever happens.
First off, your computer can only support a number of truly concurrent operations to begin with.
On your CPU this is normally your &quot;core count&quot;. However even this is a bit of a fudged number sometimes. Intel has something they call &quot;virtual cores&quot;; they duplicate some common components in each core, but not all of them.
This allows certain stages of the pipeline to occur at the same time, but not every stage.
To get the amount of threads supported concurrently, use <code>std::thread::hardware_concurrency()</code>. </p>
<p>Moreover, Amdahl's Law states:
<img src="concurrency/../res/AmdahlsLaw.PNG" alt="Amdahl's Law Image" />
Let's say our application spends 20% (quite a good chunk) of its time doing parallel work, then it can only be improved by a factor of:
1/(1 - 0.2) = 1.25
no matter how many threads or cores you have.</p>
<p>There's more to the story, but my main point is don't overuse threads.
When you have much more threads than your hardware can handle, you get what's called <em>oversubscription</em> and <em>task switching</em>.
In order to support more threads than processor, each processor will have to perform small bits of a task at a time, then switch to another.
To switch tasks, the processor has to save all the state of the current thread, store it, and load up the next thread and state of that.
This can take a lot of time and if it has to do this excessively... no bueno.</p>
<p>My point is threading is powerful, but it's not to be used everywhere.</p>
<h3 id="jthread"><a class="header" href="#jthread">JThread</a></h3>
<p>C++20 adds a jthread class, which joins on destruction (&quot;joining thread&quot;). It also allows the thread to be interrupted via a <code>stop_token</code>.
I will say no more, but show a code sample from cppreference. </p>
<pre><code class="language-C++">using namespace std::chrono_literals;

void f(std::stop_token stop_token, int value)
{
    while (!stop_token.stop_requested()) {
        std::cout &lt;&lt; value++ &lt;&lt; ' ' &lt;&lt; std::flush;
        std::this_thread::sleep_for(200ms);
    }
    std::cout &lt;&lt; std::endl;
}

int main()
{
    std::jthread thread(f, 5);
    std::this_thread::sleep_for(3s);
    // The destructor of jthread calls
    // request_stop() and join().
    
    
    thread.request_stop() // call manually
    auto ss = thread.get_stop_source();
    ss.request_stop(); //requests stop
    bool b = ss.stop_requested();
    bool c = ss.stop_possible();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutexes-and-locks"><a class="header" href="#mutexes-and-locks">Mutexes and Locks</a></h1>
<p>&quot;Shared state is broken state&quot;<sup class="footnote-reference"><a href="#1">1</a></sup>.
If you have two threads reading from the same piece of memory, that's fine, but if you have one reading while another is writing you can get tons of issues.
Firstly, the reading thread might not read a completely changed value on an object (ie. halfway between changing an integer) then for larger data types like classes,
a reading thread might only read some new values (ie. say the first boolean and integer, but not the last string).
Therefore, we need a way to synchronize multiple data accesses on the same data.</p>
<p>First, what exactly is an object? The standard defines it as a &quot;region of storage&quot;.
An object is stored in one or more memory locations and can consist of sub-objects.
For example, a struct is an object where each member is a sub-object (with possibly sub-sub-objects).
Adjacent bit-fields are their own object but share a memory location.
However, zero length bit-fields break up the adjacency and separate bit-fields into different memory locations.
Each variable is an object, and variables of fundamental or primitive types, no matter their size, take up exactly one memory location.
Multiple threads can safely and concurrently access different memory locations.</p>
<pre><code class="language-C++">struct A {
    int a; //obj
    bool b; //obj
    char c; //obj
    unsigned long d : 24, e : 8; 
    //two objs in same mem location
    unsigned spacer : 0;
    char f : 4, g : 4; 
    //2 objs same mem
}
</code></pre>
<p>Each object has a modification order, or the sequence of reads and writes that occur to it.
All threads must agree upon the modification order of a single object, but they don't have to agree on the modification order of an object relative to another.</p>
<h3 id="thread-local"><a class="header" href="#thread-local">Thread Local</a></h3>
<p>Sometimes you don't want shared state.
For those times you have the <code>thread_local</code> storage modifier.
Thread local variables are each unique to their own thread, and must also be static.
You don't need to synchronize on thread-local storage because each thread has their own copy.</p>
<pre><code class="language-C++">class Bar {
private:
    static thread_local int localInt;
public:
    void doFoo() {
        // perform a computation with localInt
        // no synchronization needed
    }

}
</code></pre>
<p>If you can, avoid shared state.
It slows down concurrent applications (now they must serially access the state) and is harder to reason about.</p>
<p>I won't dive into the details, but two architectures of concurrency without shared state are Actors aka CSP, and Blackboards.
For the actor model, think of each thread as its own actor. Each actor can only communicate to other actors via a one way messaging system.
As messages come, an actor processes it to completion and has an internal state machine. 
For the backboard model, think of a bunch of investigators working on a case.
Each thread can put information on the blackboard and all other threads can process the information and add more to the blackboard.
Information comes in any order, and the threads have no knowledge about each other.</p>
<h2 id="mutexes"><a class="header" href="#mutexes">Mutexes</a></h2>
<p>Of course things aren't always as peachy as being able to avoid shared state.
When those times come, you must enforce a modification order between objects.
If you don't, you have a <em>race condition</em> where one thread is racing another to access the state. </p>
<p>One tool to avoid that are mutexes which stand for MUTually EXclusive. Mutexes basically enforce
serial access to pieces of data. Threads lock a mutex before executing instructions that cannot be completed by multiple threads
at once. Once a thread has obtained the lock, other threads that try to lock the mutex must wait until the
thread that has the mutex releases it. When a thread is done with a mutex, it must release it so other threads
can acquire it and execute the code the mutex protects.</p>
<p>In C++, we have <code>std::mutex</code>. I'm not even going to enumerate the member functions of a mutex because you should basically never use it directly.
Instead, you want to wrap it in a class such as <code>std::lock_guard&lt;&gt;</code> or <code>std::scoped_lock&lt;&gt;</code>.
A lock guard is the simplest RAII object for a mutex.
When it's constructed it locks immediately and won't unlock until its destroyed.
It's neither moveable or copyable, it simply guards a piece of code that uses shared state.
Its lack in functionality is made up for by being lightweight.</p>
<pre><code class="language-C++">std::mutex mu;
std::queue&lt;char&gt; sharedState;

void workerThread() {
    while(/* do work */){
        std::lock_guard&lt;std::mutex&gt; lk(mu);
        if(!sharedState.empty()){
            auto c = sharedState.front();
            sharedState.pop();
            // process it
        }
    }
}
std::thread t1(&amp;workerThread);
std::thread t2(&amp;workerThread);
std::thread t3([&amp;mutex, &amp;sharedState](){
    while(/* do work*/){
        auto c = //compute c
        std::lock_guard&lt;std::mutex&gt; lk(mutex);
        sharedState.push(c);
    }
});
</code></pre>
<p>Now looking at the code, we see that in the worker thread, we process the data while still holding the lock. What if that takes a long time? Could we fix it by doing this?</p>
<pre><code class="language-C++">void workerThread(){
    bool empty = false;
    {
        std::lock_guard&lt;std::mutex&gt; lk(mu);
        empty = sharedState.empty();
    }
    if(!empty){
        {
            std::lock_guard&lt;std::mutex&gt; lk(mu);
            //front and pop
        }
        // process as before
    }
}
</code></pre>
<p>Let's say that we take the lock and store the value <code>false</code> from the call to <code>empty()</code> into the local variable <code>empty</code>.
After releasing the lock, let's say that another thread pops off the last element of the stack.
Now when the first thread goes to pop an element off the stack, it will find that it's already empty!
In general, we want to use locks to make operations like this atomic, so a thread can't be interrupted when its doing this.
Moreover, in general we want to hold a lock for as narrow of a scope as possible, and as little time as possible.
However, as shown in the above example, we can't lock on too fine of a scale so that single operations can be interrupted by other threads.</p>
<p><code>scoped_lock&lt;&gt;</code> is pretty much exactly like <code>lock_guard</code>, however <code>scoped_lock</code> allows locking multiple mutexes at the same time.
Generally, <code>std::scoped_lock</code> should be preferred to <code>std::lock_guard</code>.</p>
<pre><code class="language-C++">std::mutex m1, m2;

{
    std::scoped_lock lk(m1, m2);
    // compiler deduces themplate type
    // full definitions is:
    // std::scoped_lock&lt;std::mutex, std::mutex&gt; lk(m1, m2);
}
</code></pre>
<p>Let's look at a more powerful lock. <code>std::unique_lock</code> can be unlocked and re-locked and it can be moved. </p>
<pre><code class="language-C++">std::unique_lock&lt;std::mutex&gt; lk(mu, std::lock_deferred);
// don't lock on construction
lk.lock(); //lock it.
//OR std::lock(lk);

if(!sharedState.empty()){
    auto c = sharedState.front();
    sharedState.pop();
    lk.unlock(); //unlock
    // process it
}
</code></pre>
<p><code>std::lock()</code> allows locking two locks at the same time. 
Using <code>std::unique_lock</code>, we're able to easily lock the mutex,
check if the shared stack isn't empty and if it isn't, pop the top of the stack,
then finally unlock the lock to perform processing without inhibiting other threads
from processing elements separately.</p>
<p>You don't have to worry about forgetting to unlock a <code>std::unique_lock</code> since <code>std::unique_lock</code> will unlock itself during destruction.</p>
<pre><code class="language-C++">std::mutex m1, m2;

std::lock(m1, m2);
// lock m1 and m2 atomically together
std::lock_guard&lt;std::mutex&gt; lk1(m1, std::lock_adopt);
// take over an already locked mutex
std::lock_guard&lt;std::mutex&gt; lk2(m2, std::lock_adopt);

// OR

std::unique_lock&lt;std::mutex&gt; lk3(m1, std::lock_deferred), lk4(m2, std::lock_deferred);
std::lock(lk3, lk4);

//OR even better

std::scoped_lock lk(m1, m2);

// lock on construction
std::unique_lock&lt;std::mutex&gt; lk5(m1);
</code></pre>
<p>Note: Although I show them all in the same code sample, you <strong>cannot</strong> lock an already locked mutex.
<code>std::mutex</code> is <strong>not</strong> reentrant.</p>
<p>Notice how these RAII objects are templates.
That sort of implies that there is more than one type of mutex. </p>
<p>We also have the <code>std::shared_mutex</code>. 
A shared mutex allows threads to access data concurrently by using a <code>std::shared_lock</code>, and will only allow exclusive access using a <code>std::unique_lock</code>.
This is commonly referred to as a <em>reader-writer</em> locks because typically you have a group of threads safely reading data at the same time,
and one thread writing data exclusively. This is used in data structures where the usage pattern is to commonly read and infrequently update data.</p>
<pre><code class="language-C++">/**
* Calculates an id based on the current msg count and 
* the thread id of the calling thread
* Since we're only working with 1 byte, there can 
* only be max 32 threads to one msg formatter 
* and only 8 writes before a read per thread
* @return unique id for the message
*/
uint8_t calcId(std::atomic&lt;uint8_t&gt;&amp; counter) {
    static std::map&lt;std::thread::id, uint8_t&gt; threadIds;
    static std::shared_mutex threadIdMu;
    // shared mutex
    static uint8_t idCounter = 0;
    
    auto index = counter++ % 8;
    uint8_t id = index &lt;&lt; 5;
    std::shared_lock lk(threadIdMu);
    // lock for reading

    auto it = 
        threadIds.find(std::this_thread::get_id());
    if (it != threadIds.end()) {
        // common case
        id |= it-&gt;second;
    }
    else {
        // rare case

        lk.unlock(); //unlock reading
        std::unique_lock lk2(threadIdMu);
        // lock for writing

        threadIds.emplace(std::this_thread::get_id(), 
           static_cast&lt;uint8_t&gt;(idCounter));
        id |= (idCounter++ &amp; 0b11111);
    
    }
    return id;
}
</code></pre>
<p>As you can see, we use <code>std::unique_lock</code> to get exclusive access and write to the map and <code>std::shared_lock</code> to get shared access read from the map.
Shared locks have the same semantics as <code>unique_lock</code>, except for being shared access of course.
When a thread wants to get exclusive access, it blocks other threads from locking the mutex for either shared or exclusive access, waits for all in-progress operations to stop, then
performs the operation and unlocks th lock. Threads waiting for the exclusive lock get priority. So then what happens if we have more threads looking for exclusive access than shared access? 
Well, we can end up with a situation known as
<em>starvation</em> where threads continually acquire the exclusive lock leaving threads waiting for the shared lock for a long time. Thus, it's important such locks be used in situations
where shared access is the common case and exclusive access happens less frequently.</p>
<p>Earlier I mentioned reentrant locks. Let's see that in C++. C++ has <code>std::recursive_mutex</code> which allows one thread to lock the mutex multiple times
and requires the thread to unlock it the same amount of times it has locked it. Think of this as basically allowing nested locks within a single thread.</p>
<pre><code class="language-C++">class Foo {
    std::recursive_mutex mu;
public:
    void stuff() {
        std::lock_guard&lt;std::recursive_mutex&gt; lk(mu);
        // do some stuff
    }
    void moreStuff() {
        std::lock_guard&lt;std::recursive_mutex&gt; lk(mu);
        // complex stuff
        stuff();
    }
}
</code></pre>
<p>We have some code reuse here, which is great. Unfortunately, if we were to use a normal <code>std::mutex</code>, this code would deadlock because when we call <code>stuff()</code> from <code>moreStuff()</code>,
we'd be waiting for a lock, yet we already have the lock!
Basically, the thread would be waiting for itself to give up the lock, yet it won't give up the lock because it's waiting for a lock.
<code>std::recursive_mutex</code> avoids this problem, and you see we can happily implement <code>moreStuff()</code> in terms of <code>stuff()</code>.</p>
<p>Speaking of waiting, as I mentioned earlier, when you lock a mutex, you wait for it to become available if you don't have it.
What if you don't want to wait if it's not available, or at least not wait too long? We can use a
<code>std::timed_mutex</code> or <code>std::recursive_timed_mutex</code>! When using these, our RAII wrappers will be able to be able to use the member functions <code>try_lock()</code>,
<code>try_lock_for()</code>, and <code>try_lock_until()</code>. After a call to such functions, we can query if we obtained the lock with the member <code>owns_lock()</code>.
This allows us to avoid blocking (<code>try_lock()</code>), or avoid blocking for long periods of time.</p>
<pre><code class="language-C++">using namespace std::chrono_literals;
std::timed_mutex mu;

std::unique_lock&lt;std::timed_mutex&gt; lk(mu, std::lock::deferred);
lk.try_lock_for(500ms); //wait 500ms if not available

if(lk.owns_lock()){
    //exclusive access
}
</code></pre>
<h3 id="once-flag"><a class="header" href="#once-flag">Once Flag</a></h3>
<p>Let's say you need to call some code once. It seems overkill to have a boolean flag, and a mutex to protect it. That's why we have <code>std::call_once</code>.</p>
<pre><code class="language-C++">std::once_flag once;

std::call_once(once, []() {
    //execute this once
});
// pass the once_flag and a callable object to std::call_once
</code></pre>
<h3 id="deadlock"><a class="header" href="#deadlock">Deadlock</a></h3>
<p>I mentioned deadlock before, it's basically where no progress is made because one thread is waiting for another, but that thread is waiting for the first thread. More formally, deadlock occurs when all of the following conditions are met:</p>
<ul>
<li>Bounded Resources - we have a limited number of resources that many threads may try to access.</li>
<li>No preemptions - a thread must wait for another thread to finish before taking the resource. Basically, threads are not stopped or interrupted during the time that is has the resource.</li>
<li>Hold and Wait - a thread holding a resource waits for another resource.</li>
<li>Circular Waiting - there exists a cycle in a resource acquisition graph. For example, thread <code>A</code> waits for <code>B</code>, who waits for <code>C</code>, who waits for <code>A</code>.</li>
</ul>
<p>Typically Bounded Resources and No Preemptions are not conditions we can do much about, so most strategies at avoiding deadlock aim to prevent Hold and Wait and Circular Waiting from occuring at the same time.</p>
<p>Here are some guidelines to avoid deadlock:</p>
<ul>
<li>
<p>Use <code>std::lock()</code> or <code>std::scoped_lock&lt;&gt;</code> if you need to acquire multiple locks together</p>
</li>
<li>
<p>Avoid nested locks</p>
</li>
<li>
<p>Avoid calling user supplied code when holding a lock. This could possible lead to nested locks, since we don't know what that code does</p>
</li>
<li>
<p>Always acquire and release locks in the same order</p>
</li>
<li>
<p>Use a lock Hierarchy</p>
<p>A Hierarchical lock is one which enforces an ordering. You can only lock locks going up (or down) the hierarchy.
You can google for a simple implementation of one.</p>
</li>
</ul>
<p>Deadlock and proper locking granularity are very simple concepts to describe,
but takes practice in order to identify and write code that considers both issues.
Thus, I'm going to refer you to C++ Concurrency in Action for more information.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Professor Myers</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="condition-variables-latches-barriers-and-semaphores"><a class="header" href="#condition-variables-latches-barriers-and-semaphores">Condition Variables, Latches, Barriers, and Semaphores</a></h1>
<p>In the previous section I showed a common multhithreading architecture, producer-consumer,
where we had some worker threads and producer threads.
Now in that section, the consumer threads spin locked,
constantly looping to check if there was something for them to do.
This wastes precious cycles and prevent something else from being done on that core while it's spinning.
This is exactly the motivation of a condition variable, which lets you put a thread to sleep while it waits for another thread to notify it and wake up.</p>
<pre><code class="language-C++">std::condition_variable cv;
std::mutex mu;
std::queue&lt;/*something*/&gt; q;

void workerThread(){
while(/* some flag*/){
    std::unique_lock&lt;std::mutex&gt; lk(mu);
    if(q.empty()){
        cv.wait(lk, [&amp;q]() {
            return !q.empty()
        });
    }
    auto t = q.front();
    q.pop();
    lk.unlock();
    // process it
}
}
void producer() {
while(/* something */){
    auto t = //compute it
    std::unique_lock&lt;std::mutex&gt; lk(mu);
    q.push(t);
    lk.unlock();
    // not holding mutex when calling notify()
    cv.notify_one();
}
}
</code></pre>
<p>A few things to note. First, when we wait for the lock, we pass the lock and a predicate to <code>wait()</code>.
We must use a <code>std::unique_lock</code> because the condition variable will handle unlocking the lock for us.
A condition variable will release the lock allowing other threads to acquire it. When the thread wakes up, the condition variable
retakes the lock (waiting if another thread already has it) and then resumes execution from where it left off.
We pass a predicate to the <code>wait</code> function so that when the thread wakes up, it will execute the predicate.
If the predicate returns <code>true</code>, then execution resumes. Otherwise, the thread releases the lock and goes back to sleep.
You may be wondering: &quot;wouldn't being woken up be enough to know that data is available?&quot; 
The answer is no, because of <em>spurious wakeups</em> and <em>lost wakeups</em>.
A spurious wakeup is when a condition variable wakes up randomly, and not because it was notified. 
A lost wakeup is when a condition variable is notified before a thread waits upon it.
Thus, when the thread waits on the condition variable, it will never wake up because the notification was already sent.
Neither are faults of C++, but rather limitations of condition variables in the OS.
Thus, a predicate is passed which is checked before the thread waits on a condition variable and immediately after a thread wakes up.
When the predicate returns <code>true</code>, the thread can proceed from waiting. 
If the condition variable waits, it unlocks the lock and essentially goes to sleep. 
When it awakes, it acquires the lock again, and if the predicate is true continues on. Otherwise, it releases the lock and resumes sleep.
If, on the other hand, the predicate returns true before the condition variable puts the thread to sleep, the thread's execution
will just continue on as if the wait call was never there.
Passing the predicate is optional, but in most cases you want it.</p>
<p>The condition variable also has <code>wait_for()</code> and <code>wait_until()</code> and which allow you to pass <code>std::duration</code>s or <code>std::time_point</code>s to wait for a specified amount of time
or wait until the system clock reaches a certain time.</p>
<p>Now for the producer thread.
Notice we release the lock before calling <code>notify_one()</code>. 
If we didn't, then the consumer thread might awake to find the lock is still held, and thus must block until the lock is released.
This is just good practice to avoid premature pesimization. We also call <code>notify_one()</code>, which as the name suggests wakes up one thread.
There is also a <code>notify_all()</code>, which awakes all waiting threads.</p>
<p>There's a slight problem with this implementation.
What if the worker thread throws when processing the data from the queue?
Well the data is already popped off the queue, and no other thread will be able to process it. Here's a modification we can make to avoid this.</p>
<pre><code class="language-C++">{
    auto t = q.front();
    q.pop();
    lk.unlock();
    try{
        //process
    } catch(...) {
        {
            std::scoped_lock lg(mu);
            q.push(t);
            // t should have a nothrow copy
            // if not, wrap it in a smart pointer
            // and have the queue hold smart pointers
        }
        cv.notify_one();
        
    }
}
</code></pre>
<p>There are nicer ways to do this (for starters, this probably should be broken up into multiple
functions because it's doing way more than one thing), but this is the basic idea.</p>
<p>A <code>std::condition_variable</code> only works with <code>std::unique_lock</code>. 
To do this with a <code>shared_lock</code> or another type, use <code>std::condition_variable_any</code>.
Other than that the interface is the same.</p>
<h2 id="latches-and-barriers"><a class="header" href="#latches-and-barriers">Latches and Barriers</a></h2>
<p>These are new to C++20, but they can be accessed in C++17 as part of the <code>std::experimental</code> namespace.</p>
<p>A barrier is something that stops the sequence of execution for a thread, until multiple threads reach it.
Once a thread reaches a barrier, they can drop themselves from the barrier (barrier no longer will wait on them).
Once x threads reach the barrier, the barrier releases and resets.</p>
<pre><code class="language-C++">std::barrier barrier(3); //3 threads must wait
int result[3];
void doWork() {
    while(true){
        //do some work
        result[id] = //result.
        barrier.arrive_and_wait();
        // barrier.arrive(); don't wait
        // barrier.arrive_and_drop(); decrements wait count
        int res = result[/*some other id*/];
    }
}
</code></pre>
<p>doWork() can be run on 3 different threads. Each thread will perform a computation, update its result,
and wait for the others. Notice something interesting: result is unprotected shared state.
Why is this ok? Well, I'm not going to talk much about memory ordering, but I will say this:</p>
<p>An instruction that is <em>sequenced-before</em> another on the same thread of execution (so, comes first top-to-bottom) <em>happens-before</em> the second instruction.
The barrier provides a mechanism to <em>synchronize-with</em> another thread. So if <code>A</code> happens-before <code>B</code>, and <code>B</code> synchronizes-with <code>C</code>,
and <code>C</code> happens-before <code>D</code>, then <code>A</code> <em>inter-thread-happens-before</em> <code>D</code>. 
Thus, utilizing data from <code>A</code> in <code>D</code>, is safe. There's more to this story but that's a good start.
So when a thread arrives at the barrier, all the updates that happened on that thread before the barrier are synchronized to all other threads ater the barrier.
Let's say thread <code>A</code> assigns its result to <code>result[0]</code>. Then <code>A</code> reaches the barrier and waits. When thread <code>B</code> and <code>C</code> arrive at the barrier,
the wait count will reach <code>3</code> and all the threads will be released and continue execution.
During this process, the threads synchronize the modifications made to <code>result</code> so that all threads
can see the results stored in <code>result</code> prior to the barrier.
Now thread <code>C</code> is safe to read <code>result[0]</code> from thread <code>A</code>.
If however, <code>A</code> made another update to <code>result[0]</code> after it resumed from the barrier, then <code>C</code> might read the old value (the one set before the barrier),
the new value, or something in-between.</p>
<p>A <code>std::flex_barrier</code> is very similar to a barrier, however its constructor also takes a callable object that returns an <code>int</code>.
When all threads are released from the barrier, this callable object is run on one thread, and the resulting integer will be the new
thread count for the barrier.</p>
<p>A latch is exactly like a barrier, but it cannot be reset.</p>
<pre><code class="language-C++">std::latch latch(4);
void worker() {
    //do work
    latch.count_down();
}

//spawn 3 workers which call worker()
//do some work of its own
latch.arrive_and_wait();
// counts down latch and waits for count to be zero
// now access results of workers

// we also have
latch.try_wait() 
// which tests if the count is zero
</code></pre>
<h3 id="semaphore"><a class="header" href="#semaphore">Semaphore</a></h3>
<p>A semaphore is essentially a counter.
Unlike mutexes, it doesn't have to be accessed from a single thread of execution.
When using mutexes, you can't unlock a mutex you don't have, but a semaphore is just a counter.
Thus, one thread can acquire the semaphore and another thread can release it. 
A semaphore has two main operations: wait (acquire) and signal (release). Acquire decrements the semaphore's count.
If the count is already 0, it will wait until it can decrement the count. Release will do the opposite,
it will increment the semaphore which will unblock acquire.
Like the others, you can use <code>try_acquire</code> or <code>try_acquire_for</code> to avoid waiting if the count is already 0.</p>
<p>A <code>std::binary_semaphore</code> is a special case of a semaphore (<code>std::counting_semaphore</code>) where the count only goes up to 1.</p>
<pre><code class="language-C++">std::counting_semaphore&lt;20&gt; sem(0); 
//initialize count to 0 with a least max value of 20
std::deque q;
void worker() {
    while(true){
        sem.acquire();
        // decrement count
        // synchronize recent changes from the producer thread

        auto item = q.front();
        q.pop_front();
        // process
    }
}
void producer() {
    while(true){
        //compute data
        q.push_back(/*data*/);
        sem.release();
        // increment count
    }
}

std::thread t(&amp;worker);
producer();
sem.max(); //get semaphore max value
</code></pre>
<p>Notice how the semaphore is essentially acting as a counter for the elements in the queue.
Unlike mutexes, the semaphore doesn't have to be released on the same thread that it's acquired.
As a template parameter, the semaphore takes the least max value, essentially the smallest maximum value the semaphore will count up to.
A binary semaphore is just a type alias for <code>std::counting_semaphore&lt;1&gt;</code>.</p>
<p>Similar to the barrier, each corresponding <code>acquire()</code> and <code>release()</code> match up so that modifications on a thread prior to the call to <code>release()</code>
will be visible on another thread after the call to <code>acquire()</code>. Therefore, <code>std::deque</code> does not need a lock protecting it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-promises-and-futures"><a class="header" href="#async-promises-and-futures">Async, Promises, and Futures</a></h1>
<p>Earlier I mentioned that threads take void return functions.
Well, they don't have to, but returning something from a thread isn't going to do anything useful.
That isn't the case for futures. Futures are essentially a handle to a concurrent task that allows you to wait for and fetch the result of the task. The basic operations of futures are:</p>
<ul>
<li><code>get()</code> - Blocks until the result is ready, then returns the result</li>
<li><code>valid()</code> - Returns true if the future is associated with shared state</li>
<li><code>wait()</code>, <code>wait_for()</code>, and <code>wait_until()</code> 
These functions return a <code>std::future_status</code> which indicates if the future is ready (can call <code>get()</code> without blocking) or not</li>
</ul>
<p>Futures are returned from <code>std::async</code> which may run a task in parallel.
When using <code>std::async</code>, the library controls if the code is run on a new thread or sequentially. The library implementation chooses the best option to avoid over-subscription and excessive task switching.
If you must force it to run in parallel, pass <code>std::launch::async</code> as the first parameter.
The next parameter to <code>std::asycnc</code> would be the callable object to run, and any remaining parameters would be arguments passed to that callable object.
This works similarly to <code>std::bind</code>. <code>std::async</code> will then return a <code>std::future</code>, which is like a handle for a value that isn't available yet, but is expected
in the future.</p>
<pre><code class="language-C++">int foo();
class A {
public:
    int computeNumber(int seed) {
    int num = //...
    return num;
    }
};
A a;
int seed = 20;
std::future&lt;int&gt; fu = std::async(&amp;A::computeNumber, &amp;A, seed);
// if you pass a member function, the first argument needs to be a pointer
// to the owning object (remember, this is an implicit first argument)

// do some stuff

int res = fu.get();
// if async did not launch a parallel task
// then at this point it will execute the code 
// in sequence either way, get() will wait 
// until the result is available

std::vector&lt;std::future&lt;int&gt;&gt; futures;
futures.emplace_back(std::async(std::launch::async, [](){
    return /* some result*/
}));
// emplace a task that is always run on a new thread

futures.emplace_back(std::async(std::launch::deferred, &amp;foo));
// std::launch::deferedd forces the task to be run on the current thread

for(auto&amp; fu : futures) {
    auto status = fu.wait_for(500ms);
    if(status == std::future_status::ready) {
        int res = fu.get();
    }
}
</code></pre>
<p>Like threads, futures are move-only.
So notice when we iterate through the vector, we use <code>auto&amp;</code> instead of <code>auto</code>.
This is because, if you remember our type deduction rules, a plain <code>auto</code> is exactly like a plain <code>T</code>.
Therefore, it will copy by-value. Futures cannot be copied (nor did we want to copy it), so we use <code>auto&amp;</code> to get a reference to the deduced type.</p>
<p>We also have <code>std::launch::deferred</code> which is diametrically opposed to <code>std::launch::async</code>.
Instead of requiring a parallel mode of execution, it requires execution be deferred until <code>get()</code> is called.</p>
<p><code>get()</code> can <strong>only be called once</strong> per future object. Once <code>get()</code> is called, when the result is ready, the future moves out whatever shared state it had.
At this point it becomes invalid.
You can check if a future is valid by calling <code>valid()</code>. If you do call <code>get()</code> twice on the same future, you will get a <code>std::future_error</code>.
If a future is destroyed without calling <code>get()</code>, the destructor will wait for the task to finish.</p>
<p><code>std::async</code> is great for recursive algorithms, times when you don't know how best to split up work among different threads ahead of time,
or using functional programming idioms with concurrent programming.</p>
<p>Here's and example of a parallel merge sort.</p>
<pre><code class="language-C++">#include &lt;future&gt;
#include &lt;algorithm&gt;
template&lt;typename T&gt;
void mergeSort(std::vector&lt;T&gt;&amp; vec, size_t begin, size_t end) {
    if (end &gt; begin + 1) {
        const auto middle = (begin + end) / 2;
        auto fu = std::async([&amp;]() { mergeSort(vec, begin, middle); });
        mergeSort(vec, middle, end);
        fu.get();
        std::inplace_merge(&amp;vec[begin], &amp;vec[middle], vec.data() + end);
    }
}
</code></pre>
<p>What's going on is that we start with the entire vector, and at each step we subdivide the vector into two halves.
One half is (possibly) performed in parallel while the main thread is doing the other half.
If we used pure threads here, then we could quickly get up to too large of an amount of threads.
We start big, and go into smaller and smaller chunks so that the new threads are likely created for the big chunks,
and the smaller chunks are likely executed sequentially.</p>
<p>Notice also that the merge sort function doesn't return anything and performs the operation in-place. We can still use futures however.
In this case we use a future to notify when the task is completed instead of using condition variables and mutexes.
Consider using void futures to notify one-off events.</p>
<p>Since <code>mergeSort</code> is a template, we wrap it in a lambda and pass it to <code>std::async</code> instead of passing its address and function arguments directly.
This is because it's difficult to get the address of a template function.</p>
<p>Since <code>end</code> is going to be off the back of the vector for some calls to <code>std::inplace_merge</code>, we don't get the end pointer by doing <code>&amp;vec[end]</code>, because
that would be undefined behavior if <code>end &gt;= size()</code>. Finally, I'd also like to remind you that doing <code>&amp;vec[index]</code> will not work for boolean vectors.
For an explanation, refer to <a href="concurrency/../basic_containers/vector.html">the vectors section in the basic containers chapters</a>.</p>
<p>Now what if you wanted to be able to call <code>get()</code> multiple times?
Let's say you have multiple threads that all need some result.
Well the C++ standard has given us the shared future <code>std::shared_future</code>. The differences are quite similar to a <code>unique_ptr</code> vs a <code>shared_ptr</code>.
The <code>shared_future</code> is both moveable and copyable.
We can convert a future to a <code>shared_future</code> by calling the <code>share()</code> member function.
Once shared, multiple threads can then wait on the result and multiple threads can call <code>get()</code>.</p>
<pre><code class="language-C++">std::shared_future&lt;X&gt; fu;
void doWork(){
    auto val = fu.get();
    // do something
}
fu = std::async(std::launch::async, &amp;getResult).share();
std::thread t1(&amp;doWork), t2(&amp;doWork);
</code></pre>
<p>Other than that the interface is exactly the same.</p>
<h3 id="continuations"><a class="header" href="#continuations">Continuations</a></h3>
<p>The <code>std::experimental::future</code> provides another member function <code>then()</code>.
This allows you to schedule some code to run when the future becomes ready instead of having to check it yourself by calling <code>get()</code> or <code>wait()</code>.
This is known as a <em>continuation</em>. It takes any kind of callable object, similar to bind. <code>std::experimental::when_all()</code>
allows you to pass a variable amount of futures, and it will return a future that becomes ready when all the futures are ready.
Furthermore, <code>std::experimental::when_any()</code> does a similar thing, except its future will become ready once any of the passed futures are ready.</p>
<h3 id="packaged-task"><a class="header" href="#packaged-task">Packaged Task</a></h3>
<p>std::async isn't the only way to create futures.
We also have <code>std::packed_task</code>. 
Packaged task associates a callable object with a future.
The <code>packaged_task</code> is manually executable via <code>operator()</code>.
Essentially, it allows you to package together a callable object and its associated future, then move it somewhere to be called.
So the main difference compared to <code>std::async</code> is that you control when, where, and how it's executed.
Consider this basic thread pool, which is something that maintains multiple worker threads that the user can use to complete tasks.</p>
<pre><code class="language-C++">class ThreadPool {
private:
    std::queue&lt;std::packaged_task&lt;int(void)&gt;&gt; q;
    std::vector&lt;std::jthread&gt; thread;
    std::condition_variable cv;
    std::mutex mu;

    // function that is run on each worker thread
    // of the thread pool
    void process(std::stop_token stop) {
        /* while thread isn't interrupted:
            wait for new task if queue is empty
            acquire lock
            pop task of work queue
            release lock
            run task that was popped of the queue
        */
        while(!stop.stop_requested()){
            std::unique_lock&lt;std::mutex&gt; lk(mu);
            if(q.empty()){
                cv.wait(lk, [&amp;q](){
                    return !q.empty();
                });
            }
            auto pt = std::move(q.front());
            q.pop();
            lk.unlock();
            pt(); //execute packaged_task
        }
    }
public:
    // Creates a pool with tCount amount of worker threads
    ThreadPool(int tCount) {
        for(auto i = 0; i &lt; tCount; ++i){
            threads.emplace_back(
                std::jthread(&amp;ThreadPool::process, this));
        }
    }

    std::future&lt;int&gt; addWork(std::function&lt;int(void)&gt; f) {
        std::packaged_task&lt;int(void)&gt; pt(f);
        // construct packaged_task from functor

        auto fu = pt.get_future();
        // get associated future
        {
            std::lock_guard&lt;std::mutex&gt; lk(mu);
            q.push(std::move(pt));
            // push new task to complete on queue
        }
        cv.notify_one();
        // notify worker threads that there's a new task
        return fu;
        }
    }
}'

int fibo(int val) {
    if(val &lt;= 1) return val;
    return fibo(val - 1) + fibo(val - 2);
}

ThreadPool pool(std::thread::hardware_concurrency());
// create a thread pool with the amount of threads the system can support truly concurrently
auto future = pool.addWork(std::bind(&amp;fibo, 345));
</code></pre>
<p>First, we use the new C++20 jthread. This will ensure that threads are cleaned up properly, and if a thread throws while being created the threads that started already are cleaned up correctly.
It also allows us to interrupt the thread. Our thread pool doesn't provide that feature to the clients, but jthread will interrupt on destruction before joining.
We call <code>get_future()</code> on the packaged task to get the associated future and return it to the client so that they can receive the result.
Since packaged tasks are move only, we have to use <code>std::move</code> to explicitly move it.
We use a condition variable to notify the thread pool of new work to do, and a <code>unique_lock</code> to control access to the shared queue.</p>
<h3 id="promise"><a class="header" href="#promise">Promise</a></h3>
<p>There's one final way to create a future, and that's from a promise. A promise is like the writing end of a future.
You can call <code>set_value()</code> or <code>set_exception()</code> on a promise and that information will be relayed to the future.
These functions will make the future ready. <code>set_value()</code> will set the data returned from calling <code>get()</code> on the future.
<code>set_exception()</code> will set the exception thrown when <code>get()</code> is called on the future.
If an error occurs during the call to <code>set_value()</code>, then an exception is set on the promise.
The promise <strong>must outlive the future</strong> because the promise is what owns the state, not the future.
If the promise gets destroyed before the future gets the data, then the exception <code>std::future_error::broken_promise</code> is set instead.
When you call <code>get()</code> on a future, the data owned by the promise is moved to the future and returned to the client.
You can get a future from a promise by calling <code>get_future()</code> just like packaged tasks.</p>
<pre><code class="language-C++">std::promise&lt;std::string&gt; p;
void compute() {
    try{
        std::string s = //some calculation
        p.set_value(s);
        // if the copy fails here
        // the promise automatically sets an exception
    } catch(...){
        p.set_exception(std::current_exception());
        // captures whatever exception was thrown and
        // stores it in the future
    }
}

std::thread t(&amp;compute);
auto fu = p.get_future();

std::cout &lt;&lt; fu.get() &lt;&lt; std::endl;
</code></pre>
<p>Just like how you can't call <code>get()</code> multiple times on a future,
you can't set a value multiple times on the same promise.
Think of it as a one-direction pipe from promise to future which will close after you send a message on it. </p>
<p>I'd also like to point out <code>std::current_exception()</code>, which I think needs no further explanation than my comments</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomics"><a class="header" href="#atomics">Atomics</a></h1>
<p>Do you remember how I said we can have a situation where an integer is half-updated?
Well that's because normal read and writes are not atomic.
When something is atomic, it is basically an indivisible operation. An atomic operation is either fully completed, or not started.
Which means it forces some kind of modification order between threads. For most primitive types, atomic data types are lock free,
that is they are implemented using purely atomic operations provided by the ISA (Instruction Set Architecture, think of this as the API the hardware provides to software).
This isn't always the case and sometimes they are implemented via locks. You can call the <code>is_lock_free()</code> member function to determine this at runtime.
The <code>is_always_lock_free</code> static constant will tell you at compile time if the atomic is lock free on all supported architectures for the compiler.</p>
<p>One atomic type that is <strong>always</strong> lock-free is <code>std::atomic_flag</code>.
It's extremely primitive and only offers two functions: <code>clear()</code> and <code>test_and_set()</code>. <code>clear()</code> sets the flag to &quot;false&quot;, and <code>test_and_set()</code>
will return the last value of the flag and set it to &quot;true&quot;. That's it.
Now, as simple as it is, this is enough to provide a synchronizes-with relationship between two threads.
Remember, a synchronizes-with relationship allows any updates prior to the synchronization point on thread <code>A</code> to be
visible to thread <code>B</code> after the synchronization point.</p>
<pre><code class="language-C++">std::atomic_flag flag;
void processor() {
    while(true) {
        if(!flag.test_and_set()){
            auto val = data.front();
            data.pop_front();
        }
    }
}
void producer() {
    while(true) {
        data.push_back(/*data*/);
        flag.clear();
    }
}
</code></pre>
<p>This is very similar to our barrier example.
The processor will never read data from the front unless the flag is false.
The producer will never set the flag to false unless there is data on the queue.
Thus, it is perfectly safe to access the queue without a lock.
We say that such synchronization forces each thread to recognize the changes made in the other prior to the synchronization.
In this case the processor must recognize changes the producer made to the queue prior to the producer clearing the flag.
I'll talk about this more in the next chapter, but each core has their own cache.
Synchronization like this forces a core to update their cache with the new data from another processor's cache.
This is how objects can have different relative modification orders to each other according to different threads.
Let's say thread <code>A</code> updates value <code>a</code> to 3, then 5, and 6. Then thread <code>B</code> updates value <code>b</code> to 20, then 30 then 40.
Both threads will see <code>a -&gt; 3 -&gt; 5 -&gt; 6</code> and <code>b -&gt; 20 -&gt; 30 -&gt; 40</code>.
However, the relative ordering (ie. <code>a -&gt; 5</code> before or after <code>b -&gt; 20</code>) will differ depending on the memory ordering used. 
I'm going to only discuss the strictest (and default) memory ordering: sequentially consistent but there are others.
Sequentially consistent memory ordering enforces a total ordering.
So with <code>std::seq_cst</code> we can ask if <code>a \to 5</code> happened before <code>b \to 20</code> and get an answer.
On other orderings such an inquiry is moot because each thread will have a different answer to that question.</p>
<p>So let's look at some more useful atomic types. The most basic operations on atomic types are <code>store()</code>, <code>load()</code>,
<code>exchange()</code>, <code>compare_exchange_strong()</code>, and <code>compare_exchange_weak()</code>. <code>store()</code> and <code>load()</code> are rather self-explanatory.
<code>exchange()</code> will return the old value and store a new value that's passed to it as a parameter. We call these RMW (read-modify-write) operations.
<code>compare__exchange</code>. isn't going to be very important to our discussion here, but they are vital for the development of lock free data structures. 
<code>compare_exchange_weak(expected, desired)</code> will compare <code>expected</code> with the value of the atomic, if they are equal, then <code>desired</code> will be stored.
If they are unuequal, <code>expected</code> will be updated with whatever is currently stored in the atomic.
Equality is tested by byte-wise comparisons such as <code>memcmp</code>. It <strong>will not</strong> use any form of overloaded <code>==</code> if your type provides own.
Given this, floats and doubles may lead to <code>compare_exchange</code> returning improper results due to slight differences in representation of the same number.
<code>compare_exchange_weak()</code> will also fail if the exchange cannot be guaranteed to be atomic.
This happens if the ISA does not have an atomic <code>compare_exchange</code> instruction, and the scheduler interrupts the thread.
This is known as a <em>spurious failure</em>.
<code>compare_exchange_strong</code> is guaranteed to return <code>false</code> only if expected was not equal to the current value in the atomic.
Internally, it uses a loop on <code>compare_exchange_weak</code>. <code>std::atomic&lt;&gt;</code> is a template class. Here's the same flag implementation, but this time with <code>std::atomic&lt;bool&gt;</code>.</p>
<pre><code class="language-C++">std::atomic&lt;bool&gt; flag = false;
//initialize to false
void processor(){
    while(true) {
        if(flag.load()){
            auto val = data.front();
            data.pop_front();
        }
    }
}
void producer() {
    while(true){
        data.push_back(/*data*/);
        flag.store(true);
        flag = true;
        // overloaded operator=()
    }
}
</code></pre>
<p>Because atomic variables, are, well atomic, no locking or synchronization mechanism is needed to access them from multiple threads.</p>
<pre><code class="language-C++">std::atomic&lt;int&gt; count = 0;
void processor(){
    while(count.load() &lt; 500){
        ++count;
        // overloaded ++
    }
}
std::thread t1(&amp;processor), t2(&amp;processor);
</code></pre>
<p>This isn't a particularly useful code sample, but it does show how numerical types
have <code>++</code> and <code>--</code> both postfix and prefix versions overloaded. Instead of <code>++</code> and <code>--</code>, we also have the functions <code>fetch_add()</code>, <code>fetch_sub()</code>, <code>fetch_and()</code> etc.
Numerical atomics also overload <code>+</code>, <code>+=</code> and other arithmetic functions.</p>
<p>Finally, atomic also has free functions for each member function.
For example <code>std::atomic_load()</code>. They are specialized for each primitive atomic type and also for <code>std::shared_ptr</code>.
However, now there is <code>std::experiemental::shared_ptr</code> and in C++20 we can use <code>std::atomic&lt;std::shared_ptr&gt;&gt;</code>.</p>
<p>In C++20, we also have the <code>std::atomic_ref</code>.
The interface is exactly the same as any other atomic type, but it is constructed from an existing lvalue reference.
Once an <code>atomic_ref</code> is created, access to that object must be exclusively through <code>atomic_ref</code> instances. </p>
<p>Here's a very basic example</p>
<pre><code class="language-C++">template&lt;typename T&gt;
class lock_free_stack
{
private:
    struct node
    {
         T data;
         std::atomic&lt;std::shared_ptr&lt;node&gt;&gt; next;
         node(T const&amp; data_): data(data_) {}
    };
    std::atomic&lt;shared_ptr&lt;node&gt;&gt; head;
public:
    void push(T const&amp; data)
    {
        auto const new_node = 
            std::make_shared&lt;node&gt;(data);
        new_node-&gt;next = head.load();
        // another thread could change head here
        while(!head.compare_exchange_weak(new_node-&gt;next, new_node));
        /* 
        while head != new_node-&gt;next:
            update new_node-&gt;next to be head
        when head == new_node-&gt;next, set head to be new_node
        */
    }
    void pop(T&amp; result)
    {
         auto old_head = head.load();
         while(
            !head.compare_exchange_weak(old_head,old_head-&gt;next));
            result = old_head-&gt;data;
    }
</code></pre>
<p>When we push something, we first set the new node's next pointer to whatever the head is.
Then, we keep checking to make sure <code>head</code> hasn't been updated by checking that our new node's next pointer is still the head pointer.
If it is, then <code>head</code> is atomically set to <code>new_node</code>.
If <code>head</code> has changed and is no longer <code>new_node-&gt;next</code>, then we update <code>new_node-&gt;next</code> and try again.</p>
<p>To pop from the stack, we follow a similar process.
We first get a copy of head.
Then, as long as <code>head</code> hasn't changed, we atomically set <code>head</code> to whatever it is pointing to next.
If <code>head</code> has changed, then we update <code>old_head</code> and try again.
Notice we have an output parameter.
This is an over generalization, but generally speaking for pop operations such as this we have two options.
Return by reference via output parameter or make the user pass a smart pointer. The reason is that a copy operation can throw.
Moreover, when we return by smart pointer (whose copy cannot throw), we could not allocate the smart pointer in <code>pop()</code> because the allocation can fail.</p>
<p><code>std::atomic&lt;shared_ptr&lt;T&gt;&gt;</code> does not make accesses of the underlying data thread safe, but it makes changing the actual pointer value thread safe. </p>
<p>Lock free data structures are generally hard to design and even harder to get right, so only go for it if it is <strong>necessary</strong>.
They're even harder when we relax the memory ordering and start using relaxed or acquire-release memory ordering instead of sequentially consistent.
As far as I know however, x86 only supports sequentially consistent memory ordering.</p>
<p>Here's a common issue with lock-free data structures known as the <em>ABA</em> problem. Consider:</p>
<ol>
<li>Thread 1 reads a value <code>A</code> from a variable. Then Thread 1 does something to <code>A</code> (such as dereference it).</li>
<li>Thread 1 is stalled</li>
<li>Thread 2 performs an operation changing the variable's value to <code>B</code>. Another thread does something based on the new value <code>B</code> so that it invalidates <code>A</code> (such as freeing <code>A</code>)</li>
<li>Another thread then changes the value back to <code>A</code> based on the new data (such as a new pointer with the same address)</li>
<li>Thread 1 resumes, uses a <code>compare_exchange</code> to find that the value is still <code>A</code> (although now it's a different <code>A</code>), and continues on with invalid data.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multithreading-considerations"><a class="header" href="#multithreading-considerations">Multithreading Considerations</a></h1>
<p>As I alluded to earlier, multhithreading isn't all peachy, not even getting into the extra difficulty of writing multithreaded code.</p>
<h3 id="memory-hierarchy-basics"><a class="header" href="#memory-hierarchy-basics">Memory Hierarchy Basics</a></h3>
<p>The memory hierarchy is a design to optimize the tradeoff between speed and cost in memory.
Disk space is really cheap and we can have a lot of it.
But the downside is that it's really slow.
To overcome this computers have a memory hierarchy.
At the top we have registers. These are typically a few words in size (32 - 64 bits) and are used for direct computations by the processor (adding, subtracting, etc.).
They're right at the heart of the action so to speak. Below that we have cache. Cache is typically divided into 3 levels L1 to L3 where L1 is smaller and faster and L3 is larger and slower.
Cache is also on the processor but slower to access and farther away but much bigger than registers (L3 will typically be a few MB, L1 a few KB).
After that we have main memory or RAM. Following that we have non-volatile storage (will retain state after power loss) such as disk space, SSD, nVMEs etc.
When a processor looks for a value, it first looks at the highest level in the hierarchy and moves down.
If it's not there, that's called a miss and finding the data would be a hit.
So as its looking for data the processor goes lower and lower in the hierarchy until it finds what it's looking for.
When it does, it doesn't just load the minimum amount of data it needs. Instead, we apply the principle of spatial locality which states that data stored
together is likely accessed together. There's also the principle of temporal locality which states that data defined together (near in time) is typically used together.
Thus, when the cpu needs to swap out data in its cache for data in main memory, it does so chunks at a time.
Furthermore, typical architectures implement a <em>write-back</em> policy. This means that an updated block in a higher level of the hierarchy is only stored back in the lower levels of the hierarchy
when that block is replaced.</p>
<p>This is how we can have different relative modification orders between threads.
To be more efficient, threads won't synchronize with main memory unless they have to.
Using relaxed memory ordering or acquire/release will allow threads to just work off the data in their own cache.
Thus when thread <code>A</code> asks for value <code>b</code> from thread <code>B</code>,
a relaxed memory ordering will allow the thread to just go to its cache and see whatever value it has there.
This may not be the latest <code>b</code>, but at one point it was <code>b</code>.
To put this another way, imagine there is a man in a cubicle with a phone. People use the phone and tell him to write down numbers, which he does, keeping a sequential list of values.
People can also use this phone to query numbers. The man must give each person the last number they received or any number that was written down after that number. Thus, even though the man may have
more recent numbers, he only has to give each caller a number at least as recent as the last number they know about. <sup class="footnote-reference"><a href="#1">1</a></sup>
Acquire-release memory ordering creates synchronization points between matching acquire and release calls similarly to a semaphore. </p>
<p>It's also important to note that not all ISA's support these differences in memory orders.
x86 for example, doesn't have much different between sequentially consistent and all the order memory orderings.
The atomic operations used at the ISA level are essentially the same.</p>
<p>If you are considering relaxing memory orderings: first get it right with sequentially consistent ordering, then see if changing the ordering will reap a reward.
Remember to use profiling tools to see where bottlenecks are.</p>
<h3 id="cache-ping-pong"><a class="header" href="#cache-ping-pong">Cache Ping Pong</a></h3>
<p>Consider what would happen if you are constantly mutating shared state.
When using sequentially consistent memory ordering (or even relaxed memory ordering if these are RMW operations), and a thread updates some data,
a global modification order must be enforced. Thus, the data must be written back to main memory and loaded by the other threads.
This is a slow process and if it's happening constantly this can really slow down your program.</p>
<h3 id="false-sharing"><a class="header" href="#false-sharing">False Sharing</a></h3>
<p>Remember how data is read in chunks from main memory? Consider what would happen if each thread's data is close together.
Every time you read or write something, you'd have to go to main memory, get the latest data from the other threads and load it back into your cache because
each thread's data is read and written together. This can cause a lot of <em>contention</em>. C++ provides us with <code>std::thread::hardware_destructive_interference_size()</code>
which returns the maximum sized <code>cache line</code> which is how much data is read at once into the cache.</p>
<h3 id="oversubscription"><a class="header" href="#oversubscription">Oversubscription</a></h3>
<p>I kind of mentioned this earlier, but basically a computer only has a limited amount of cores.
That number is the maximum amount of threads that can occur truly in parallel.
Anything more than that requires <em>task switching</em> which is when the cpu must save the state of the current thread and resume execution on another.
This just sounds slow, and it is!</p>
<h2 id="execution-policies"><a class="header" href="#execution-policies">Execution Policies</a></h2>
<p>Many STL algorithms now have an overload where the first argument is its execution policy.
No matter the execution policy, all algorithms will have slightly different semantics when a policy (even the sequential one) is specified.
If an exception other than <code>std::bad_alloc</code> is thrown, they will terminate the program and if the algorithm normally guarantees a running time of <code>N</code>,
then the execution specified version guarantees <code>O(N)</code>. There are 3 policies:</p>
<ul>
<li>Sequenced Policy (<code>std::execution::sequenced_policy</code>)
Forces sequential operation on a given thread. 
Mandates a set order of operations, but this order may differ from the normal non-policy-specified version.
Can rely that operations are performed on the same thread, but cannot rely on any given order.</li>
<li>Parallel Policy (<code>std::execution::parallel_policy</code>)
Operations performed on the same thread must not be interleaved and must have a definite ordering.
Operations cannot cause data races, they must protect any shared state via synchronization objects.
This is a good choice for introducing parallelism.</li>
<li>Parallel Unsequenced Policy (<code>std::execution::parallel_unsequenced_policy</code>)
Operations may be interleaved on the same thread and between different threads.
Operations <strong>cannot</strong> use any synchronization objects.
Operations may start on one thread and finish on a different one.
Good for things that don't have any shared state.</li>
</ul>
<p>To use a policy, pass an instance of the policy class to an algorithm.</p>
<pre><code class="language-C++">std::vector v = //..
std::for_each(std::execution::par, v.begin(), v.end(), 
    [](auto&amp; elem) {
        elem += 10;
    });
</code></pre>
<p>Pass <code>std::execution::par</code> for parallel, <code>std::execution::seq</code> for sequenced and <code>std::execution::par_unseq</code>, for parallel un-sequenced.</p>
<h2 id="memory-order"><a class="header" href="#memory-order">Memory Order</a></h2>
<p>Store operations can have <code>std::memory_order_relaxed</code>, <code>std::memory_order_release</code>, or <code>std::memory_order_seq_cst</code>.
Loads can have <code>std::memory_order_relaxed</code>, <code>std::memory_order_acquire</code>, or <code>std::memory_order_seq_cst</code>.
RMW (read-modify-write such as <code>operator++</code>) can have <code>std::memory_order_relaxed</code>, <code>std::memory_order_acquire</code>, <code>std::memory_order_release</code>, <code>std::memory_order_acq_rel</code>, or
<code>std::memory_order_seq_cst</code>.</p>
<p><code>seq_cst</code> is the strictest and default order and enforces a total modification order between threads.
That means that at the end of the day, there is some concrete order of events taking place that all threads recognize.
When an atomic with <code>seq_cst</code> memory ordering is set, all threads see the updated value. You can think of <code>seq_cst</code> memory ordering
as enforcing that all threads work off a single memory location.</p>
<p>Relaxed memory ordering is the weakest, and it basically allows processors to more or less only work off their local cache and synchronize their cache to main memory when they see fit.
During a relaxed load, the only constraint is that a thread will read a value at least as recent as the last value they know about.
Consider that thread <code>A</code> stores 23 to variable <code>a</code> and then 100 to <code>b</code>, and then thread <code>B</code> stores 42 to <code>a</code> and then 200 to <code>b</code>.
The next time <code>A</code> loads <code>a</code>, it might still be 23. However, it may load <code>b</code> and see the value is 200.
In fact, the next 100 times <code>A</code> loads <code>a</code>, it might still only read 23.
In thread <code>A</code>'s perspective, <code>b</code> was updated to 200 before <code>a</code> was updated to 42.</p>
<p>For thread <code>B</code> however, the next time it loads <code>a</code> or <code>b</code> it must get 42 and 200 respectively,
because it already knows about these more recent values. Thread <code>B</code> could not load 23 from <code>a</code> after
storing <code>42</code> to it because it already knows about the more recent modification.
In thread <code>B</code>'s perspective, <code>a</code> was updated to 42 before <code>b</code> was updated to 200.</p>
<p>Exchange operations in a relaxed memory ordering are a little stronger. Extending the cubicle analogy,
and exchange would be like telling the man to write down a certain number and give you the last number in the list.
An exchange will always read the most recent value available.
Similarly, a compare exchange operation would be like telling the man: &quot;I think <code>x</code> is at the bottom of the list,
if it is, write down <code>y</code>, otherwise tell me what is at the bottom of the list.&quot;</p>
<pre><code class="language-C++">std::atomic&lt;bool&gt; x = false, y = false;
std::atomic&lt;int&gt; z = 0;
void write() {
    x.store(true, std::memory_order_relaxed);
    y.store(true, std::memory_order_relaxed);
}
void read() {
    while(!y.load(std::memory_order_relaxed)); //wait for y to be true
    if(x.load(std::memory_order_relaxed));
        ++z;
}
int main() {
    //write() and read() on separated threads

    //z can be 0 because when y is true, no guaruntee x is true on the thread executing read()
    //  even though x is updated before y on the thread executing write()

    //in seq_cst memory ordering, z can never be 0
}
</code></pre>
<p>During an acquire-release operation, we store a value with a release memory ordering and load with an acquire memory ordering.
A release operation <em>synchronizes-with</em> an acquire operations that reads the same value the release operation stored.
Thus, any updates that occur to thread <code>A</code> prior to the release operation are available on thread <code>B</code> after the acquire operation.
This is the same idea behind barriers and semaphores.</p>
<p>Consider:</p>
<pre><code class="language-C++">std::atomic&lt;bool&gt; x = false, y = false;
std::atomic&lt;int&gt; z = 0;
void write() {
    x.store(true, std::memory_order_relaxed);
    y.store(true, std::memory_order_release);
}
void read() {
    while(!y.load(std::memory_order_acquire)); //wait for y to be true
    if(x.load(std::memory_order_relaxed));
        ++z;
}
int main() {
    //write() and read() on separated threads

    /* z can not be 0 this time
    this is because the load from y synchronizes with the store to y
    any updates that are sequenced before the store to y become visible
    to the thread that loads from y

    Notice how we achieved the same results as seq_cst memory ordering
    with weaker (and more efficient) memory orderings
    */
}
</code></pre>
<p>Acquire/release memory ordering can be thought of like so:
Imagine that when we tell the man a value, we also give him a batch number that value is part of and let him know if that update is the last number in the batch.
Now when we load values, the man will tell us if the value he gave us was the last number in a batch, and if it is he'll inform us who gave him that batch along with the batch number.
Now let's call up a woman in another cubicle playing the same game. This time, we'll ask her for a number and inform her we know about batch number <code>X</code> from caller <code>Z</code>.
This time, not only does the woman have to give us a number more recent than the last number we loaded or stored from her, but she also has to give us a number at least as recent
as any value in batch <code>X</code> from caller <code>Z</code>.</p>
<p>Last thing to mention is something called a <em>release sequence</em>. If you have a release store, acquire load, and a sequence of RMW operations that happen in between the load and store,
this forms a release sequence. The RMW operations in between can have <em>any</em> memory ordering and the acquire will still synchronize with the final load.</p>
<pre><code class="language-C++">void populate_queue() {
    //populdate data on queue
    count.store(numberOfItems - 1, std::memory_order_release);
}

void consume_queue() {
    while(true) {
        int index;
        if((index = count.fetch_sub(1, std::memory_order_acquire) &lt;= 0) {
            //RMW -= operation

            //wait
            continue;
        }
        process(queue[index]);
    }
}
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Analogy from C++ Concurrency In Action, see book for more information</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="linked-list-with-hand-over-hand-locking"><a class="header" href="#linked-list-with-hand-over-hand-locking">Linked List with Hand-Over-Hand Locking</a></h2>
<pre><code class="language-C++">#include &lt;shared_mutex&gt;
teamplate&lt;typename T&gt;
class LinkedList
{
    struct node {
        std::shared_mutex localLock;
        T data; ///&lt; Invalid iff empty is true
        bool empty;

        std::unique_ptr&lt;node&gt; next;
        ///Invariant: next is null iff empty is true

        node() : data(), empty(true), next(nullptr) {}

        template&lt;typename U&gt;
        node(U&amp;&amp; data) : data(std::forward&lt;T&gt;(data)), empty(false),
            next(std::make_unique&lt;node&gt;()) {};

        template&lt;typename U&gt;
        void set(U&amp;&amp; data) {
            this-&gt;data = std::forward&lt;T&gt;(data);
            empty = false;
            if (!next) {
                next = std::make_unique&lt;node&gt;();
            }
        }
    };

    std::unique_ptr&lt;node&gt; root;
private:
    template&lt;typename U&amp;&amp;&gt;
    void unique_push(std::unique_ptr&lt;node&gt; * currentLast, U&amp;&amp; data) {
        std::unique_lock lk1(currentLast-&gt;get()-&gt;localLock);
        while (!currentLast-&gt;get()-&gt;empty) {
            currentLast = &amp;currentLast-&gt;get()-&gt;next;
            std::unique_lock lk2(currentLast-&gt;get()-&gt;localLock);
            swap(lk1, lk2);
        }
        currentLast-&gt;get()-&gt;set(std::forward&lt;U&gt;(data));
    }
public:
    LinkedList() : root(std::make_unique&lt;node&gt;()) {};

    template&lt;typename U&gt;
    auto push_back(U&amp;&amp; data) -&gt; std::enable_if_t&lt;std::is_same_v&lt;strip_t&lt;U&gt;, T&gt;&gt; 
    {
        using std::swap;
        auto n = &amp;root;
        // n is a unique_ptr&lt;node&gt; *
        std::shared_lock lk1(n-&gt;get()-&gt;localLock);
        while (!n-&gt;get()-&gt;empty) {
            n = &amp;n-&gt;get()-&gt;next;
            std::shared_lock lk2(n-&gt;get()-&gt;localLock);
            swap(lk1, lk2);

            // hand over hand locking
            // lk1 and lk2 are swapped, lk1 then goes out of scope
            // releasing the lock
        }

        lk1.unlock();
        // another thread can take an exclusive lock and make a change here
        // we must finish up last push on a writter lock
        // we cannot upgrade a shared_lock to unique_lock
        // bc if two threads try to do that at the same time they'll deadlock
        unique_push(n, std::forward&lt;U&gt;(data));
    }

    bool find(const T&amp; e) const {
        using std::swap;
        auto n = &amp;root;
        std::shared_lock lk1(n-&gt;get()-&gt;localLock);
        while (!n-&gt;get()-&gt;empty) {
            if (n-&gt;get()-&gt;data == e) return true;

            n = &amp;n-&gt;get()-&gt;next;
            std::shared_lock lk2(n-&gt;get()-&gt;localLock);
            swap(lk1, lk2);

        }

        return false;
    }
};
</code></pre>
<p>Here's the idea behind hand-over hand locking: We take the first lock, and use that lock to secure the next lock.
Once the next lock is secure we release the first lock and continue.
This ensures the order in which we acquire and release the locks is the same among all threads.
We can use <code>swap()</code> to put the first lock in the new lock's variable (which is about to be destroyed and released the first lock),
and put the new lock into the first lock to keep the new lock around.</p>
<p>We cannot have hand-over-hand locking occurring in two directions simultaneously. This will deadlock because one direction will have
the opposite locking order as the other.</p>
<p>We use reader-writer locks because in this simple linked list, we must do a lot of traversing for both finding and inserting values.
Since we can have multiple threads traversing the list at once, we'll make those use the reader lock.
When a thread is ready to update the last value, it unlocks the reader lock and takes the writer lock. However,
at this point, another thread may have already gotten the writer lock, modified the last value, then released the lock.
So once we have the writer lock, we must ensure that the last node is still the last node, and if not, traverse to the last node.
During this traversal process we want to hold writer locks so that the thread can't keep failing to push a value onto the end of the list.</p>
<p>In order to make the code simpler, we guarantee that the root node is never null by storing an empty flag in each node.
This way, we don't need a separate lock for the root node pointer itself.
Sometimes you may find inserting dummy nodes in between nodes with actual data may also help for similar reasons.</p>
<p>Now what about delete? Well, to make things easier we'll make the root node to always be empty. This allows us not have a separate
root mutex outside the node. Since we'll always have a root node, we don't really need to dynamically allocate it with a pointer.
We'll also change to that a <code>nullptr</code> <code>next</code> indicates that the node is the last node. We won't need an empty boolean anymore since
the root node will always be empty.</p>
<p>Here's our modified linked list:</p>
<pre><code class="language-C++">class LinkedList
{
    struct node {
        std::shared_mutex lock;
        T data;

        std::unique_ptr&lt;node&gt; next;
        ///Invariant: next is null iff node is terminal

        template&lt;typename U&gt;
        node(U&amp;&amp; data) : data(std::forward&lt;T&gt;(data)), next(nullptr) {};
    };

    node root;
private:
    template&lt;typename U&amp;&amp;&gt;
    void unique_push(node * currentLast, U&amp;&amp; data) {
        using std::swap;
        std::unique_lock lk1(currentLast-&gt;lock);
        while (currentLast-&gt;next) {
            currentLast = currentLast-&gt;next.get();
            std::unique_lock lk2(currentLast-&gt;lock);
            swap(lk1, lk2);
        }
        currentLast-&gt;data = std::forward&lt;U&gt;(data);
    }
public:
    LinkedList() : root(std::make_unique&lt;node&gt;()) {};

    template&lt;typename U&gt;
    auto push_back(U&amp;&amp; data) -&gt; std::enable_if_t&lt;std::is_same_v&lt;strip_t&lt;U&gt;, T&gt;&gt; 
    {
        using std::swap;
        auto n = &amp;root;
        // n is a node *
        std::shared_lock lk1(n-&gt;lock);
        while (n-&gt;next) {
            n = n-&gt;next.get();
            std::shared_lock lk2(n-&gt;lock);
            swap(lk1, lk2);
        }

        lk1.unlock();
        // another thread can take an exclusive lock and make a change here
        // we must finish up last push on a writter lock
        // we cannot upgrade a shared_lock to unique_lock
        // bc if two threads try to do that at the same time they'll deadlock
        unique_push(n, std::forward&lt;U&gt;(data));
    }

    bool find(const T&amp; e) const {
        using std::swap;
        auto n = &amp;root;
        std::shared_lock lk1(n-&gt;lock);
        while (n-&gt;next) {
            if (n-&gt;data == e) return true;

            n = n-&gt;next.get();
            std::shared_lock lk2(n-&gt;lock);
            swap(lk1, lk2);

        }

        return false;
    }

    void remove(const T&amp; e) {
        auto n = &amp;root;
        std::unique_lock lk(n-&gt;lock);
        while (n-&gt;next) {
            const auto next = n-&gt;next.get();
            std::unique_lock nextLock(next-&gt;lock);
            if (next-&gt;data == e) {
                n-&gt;next = std::move(next-&gt;next);
            } else {
                lk.unlock();
                n = next;
                lk = std::move(nextLock);
            }
        }
    }
};
</code></pre>
<p>Since the root is always empty and never null, during deletion we can always be checking if we should delete the next node and never have to worry about
keeping track of a previous node's lock. Notice also deletion always uses a <code>unique_lock</code>.
This ensures that a thread that started behind the deletion thread can never traverse past it.
This isn't particularly important, but it does prevent querying <code>find()</code> from returning <code>true</code> for a node
that's about to be deleted on another thread. However, if the querying thread started ahead of the deletion thread and stayed ahead, this
may still occur.</p>
<h2 id="thread-queue"><a class="header" href="#thread-queue">Thread Queue</a></h2>
<pre><code class="language-C++">template&lt;typename T&gt;
class ThreadQueue {
    struct node {
        std::unique_ptr&lt;T&gt; data; ///&lt; Terminal iff data is null
        std::unique_ptr&lt;node&gt; next;

        node(std::unique_ptr&lt;T&gt; &amp;&amp; data) : data(std::move(data)), next(std::make_unique&lt;node&gt;()) {}

        node() : data(nullptr), next(nullptr) {}
    };

    std::unique_ptr&lt;node&gt; head;
    node * tail; ///&lt; Tail always points to a terminal node
    std::mutex headMu, tailMu;
    // Invariant: always lock head before tail if locking both

    std::condition_variable dataCond;

    node* getTail() {
        std::scoped_lock lk(tailMu);
        return tail;
    }
public:
    ThreadQueue() : head(std::make_unique&lt;node&gt;()) {
        tail = head.get();
    }


    template&lt;typename U&gt;
    void push_front(U&amp;&amp; data) {
        auto new_node = std::make_unique&lt;node&gt;(
            std::make_unique&lt;T&gt;(std::forward&lt;U&gt;(data)));
        // allocation doesn't need a lock
        // perform it before getting lock

        // new_node can't be const so we can move it
        {
            std::scoped_lock lk(headMu);
            new_node-&gt;next = std::move(head);
            head = std::move(new_node);
        }
        dataCond.notify_one();

        // notifty condition variable after lock unlocks

    }

    template&lt;typename U&gt;
    void push_back(U&amp;&amp; data) {
        auto new_data = std::make_unique&lt;T&gt;(std::forward&lt;U&gt;(data));
        auto next_node = std::make_unique&lt;node&gt;();
        {
            std::scoped_lock lk(tailMu);
            tail-&gt;data = std::move(new_data);
            tail-&gt;next = std::move(next_node);
            tail = tail-&gt;next.get();

        }
        dataCond.notify_one();

    }

    std::optional&lt;std::unique_ptr&lt;T&gt;&gt; pop_front() {
        std::scoped_lock lk(headMu);
        if (head.get() != getTail()) {
            const std::optional&lt;std::unique_ptr&lt;T&gt;&gt; out 
                = { std::move(head-&gt;data) };
            head = std::move(head-&gt;next);
            // new head is not nullptr because we know head != tail
            return out;
        }
        // due to invariant, if head is tail, then queue is empty
        return {};
    }

    std::unique_ptr&lt;T&gt; wait_pop() {
        std::unique_lock head_lk(headMu);
        dataCond.wait(head_lk, [this]() { return head.get() != getTail(); });
        // will not wait if head.get() != tail

        // head != tail here
        auto data = std::move(head-&gt;data);
        head = std::move(head-&gt;next);
        return *data;
    }

    bool empty() const {
        std::scoped_lock lk(headMu);
        return head.get() == getTail();
    }
};
</code></pre>
<p>For operations requiring both head and tail locks, we must enforce an order in which to lock them. I chose to always lock the head before locking the tail.
We create a <code>getTail</code> helper to not forget to lock the tail when doing tail-head comparisons to check emptiness.
This class has an invariant that tail always points to a terminal (next pointer is null) node. Therefore, when <code>head.get() == tail</code>,
the queue is empty. Also remember: things we want to move cannot be declared <code>const</code>. Move construction/assignment mutates the variable that we move from.
Therefore, many of these variables are declared <code>auto</code> even though it may appear that they should be <code>const auto</code>.</p>
<p>Also notice that <code>push_front()</code> doesn't modify the existing head node. This allows two threads to push to the front and back of the queue simultaneously.
<code>push_front()</code> adds a new head node, keeping the existing one as is, and <code>push_back()</code> modifies the current terminal node.
So even when <code>head.get() == tail</code>, the two operations can occur at the same time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c20"><a class="header" href="#c20">C++20</a></h1>
<p>In light of my tip to stay updated, I'm going to provide a very brief tour of some C++20 features.
Some others C++20 features that I don'tmention here or in the concurrency section include: constexpr constructors and destructors, a better date library,
<code>consteval</code>, <code>constinit</code>, <code>std::format</code>, and <code>std::syncstream</code>s.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>Concepts are probably my favorite C++ 20 features (so far).
I showed you an example before but now I'm going to take some more time to explain them.
Concepts are essentially &quot;meta-types&quot;. They provide a type system to templates.
Here's the motivation: not every template function can do something meaningful for every type.
Instead of producing strange error messages when a type that doesn't provide the expected interface is used
(In GCC I once got one over a couple hundred lines, which is rookie numbers),
the compiler will fail a little more gracefully.
We &quot;solved&quot; this already with SFINAE and CRTP, but concepts provides greater language support.</p>
<p>Let's start with the <code>requires</code> clause, aka <em>constraints</em>.
The <code>requires</code> keyword can be added after the function declaration or the template declaration,
and imposes some constraint on the types that the template parameter can bind to.
It takes a constant boolean expression, that when false, prevents that type from binding.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
    requires std::is_arithmetic_v&lt;T&gt;
T add5(T t) {
    return t + 5;
}

auto r = add5(20);
auto bad = add5(&quot;Hello&quot;); //error!
</code></pre>
<p>As you can see, this dovetails nicely with pre C++20 type traits. 
The <code>requires</code> clause can be passed any constant, boolean expression.
When the evaluation of this expression is <code>false</code>, the function or class instantiation will fail to be generated.
The constant expression doesn't have to be one involving a template type.</p>
<p>This is all well and good, but for complicated type checks, this is quite annoying.
That's why we can define our own concepts.
A concept is a special type of constant boolean expression (in the TS, you'd put <code>bool</code> before <code>concept</code> in the definition).
In fact, concepts <em>do</em> evaluate to booleans, so you can use them anywhere you can use a <code>bool</code>. One way to define them is as such:</p>
<pre><code class="language-C++">template&lt;typename T&gt;
concept MyConcept = std::is_arithmetic_v&lt;T&gt; || 
                    std::is_pointer_v&lt;T&gt;    ||
                    std::is_enum_v&lt;T&gt;;
                    
template&lt;MyConcept MC&gt;
void do(MC m);
// do only binds with types that statisfy MyConcept

template&lt;typename T&gt;
    requires MyConcept&lt;T&gt;
void do2(T m);
// do2 requires all types to satisfy MyConcept

template&lt;typename T&gt;
void do3(T m) requires MyConcept&lt;T&gt;;

static_assert(MyConcept&lt;int&gt;); 
// use it as a bool

template&lt;typename T&gt;
concept MyConcept2 = MyConcept&lt;T&gt; &amp;&amp;
    std::is_signed_v&lt;T&gt;;
// Define a concept in terms of another
</code></pre>
<p>A concept can be used as the &quot;type's type&quot; in a template argument, or can be used in a constraint.
In this example the concept is set equal to some constant expression, and we use it by having it as a constraint
via <code>requires</code> or as the <code>typename</code> keyword in a template argument list.</p>
<p>Concepts are templates themselves, and the first template type argument is the type the concept is being tested on.</p>
<p>Let's see a little more complex examples.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
concept SingletonDeadReferencePolicy = requires(T a) {
	T::onDeadReference();
};
// type must have a static function 
// onDeadReference()

template&lt;template &lt;typename&gt; typename T, typename R&gt;
concept SingletonCreatePolicy = requires(T&lt;R&gt; a) {
	{T&lt;R&gt;::create()} -&gt; std::same_as&lt;R*&gt;;
	{T&lt;R&gt;::free(std::declval&lt;R*&gt;())} noexcept;
};
// type must have a static function create() the returns an R*
// must also have a static, noexcept free() function that
// takes an R*


template&lt;typename R, typename T&gt;
concept StaticCastableTo = requires(T a) {
	static_cast&lt;R&gt;(a);
};
// checks if T can be cast to R
// notice the use of a, which is an &quot;instantiation&quot; of the type T
</code></pre>
<p>Concepts can have constraint blocks, which are blocks that start with <code>requires(...)</code>.
These constraint blocks are passed instances of the template arguments of the concept.
Constraint blocks are similar to the practice of using <code>std::void_t</code> to ensure that a type has certain type aliases, or instance or static members.
Since concepts are checked at compile time, no real instance is actually passed to the constraint block,
instead these instances serve just like the &quot;instances&quot; we created with <code>std::declval&lt;&gt;</code>.
Therefore, we use these instances to check that a type has certain instance members or can be passed to certain functions.</p>
<p>The constraint block will contain a series of expressions that are unevaluated.
Type <code>T</code> satisfies the concept if all expressions are valid.
We can also check the return type of these expressions satisfy a specific concept by wrapping them in <code>{}</code> and followed then with <code>-&gt;</code>.
To the right of the arrow, we put the concept that we want the return type of the expression to satisfy. 
Standard concepts such as <code>std::same_as</code> are defined in the <code>&lt;concepts&gt;</code> header.</p>
<p>Concepts can also be used to check for member type aliases, and we can nest other concepts as well by putting a <code>requires</code> clause
inside the constraint block.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
concept TList = requires(T list) {
	typename T::Value;
	typename T::Next;
};
// Type must have a member type alias called Value
// and Next

template&lt;typename T&gt;
concept MyConcept = requires(T a) {
	{ typename T::Value } -&gt; std::same_as&lt;int&gt;; 
	//requires to have a typedef/using for int

	{a.member} -&gt; std::derived_from&lt;Base&gt;; 
	//requires instance member named member derived from Base

	{a.otherMember} -&gt; std::same_as&lt;bool&amp;&gt;;
	// otherMember is type bool

	{a.function()} -&gt; std::is_convertable_to&lt;int&gt;; 
	//function that returns something that can be an int
	
	requires std::derived_from&lt;TBase&gt;;
	// type type must derive from TBase
}
</code></pre>
<p>Concepts are excellent for PBD and templates. Prefer concepts over SFINAE.
The same rules for when to use <code>template</code> and <code>typename</code> everywhere else in C++
also applies to using <code>template</code> and <code>typename</code> in constraints.
So, generally speaking, if we want to check a type has a member type alias, we use
the <code>typename</code> keyword and if we want to check a type has a template method,
we need the <code>template</code> keyword.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Modules help with some problems of includes in C++.
They are compiled independently of the transnational units that import them and unlike headers, are saved in a binary format.
Thus, once they're compiled, they are quick to load and remain unchanged and independent of the code that depends on them.
You may define a module in separate interface and implementation files, or all in one file.
In modules, code is not available outside the module unless it's explicitly exported.
Furthermore, macros and includes used in one module do not affect the code that imports the module. Here's an example:</p>
<pre><code class="language-C++">//begin interface file MyModule.ixx
//--------------------------------------
export module MyModule; 
//declare module interface
export import std.core;
//reexport std.core and import it
// (not something you need to do but I just wanted
// to show re-exporting)

namespace ModuleNS {
    int internalFunc();
    
    
    export int getInt(); 
    //give a function external linkage
}
</code></pre>
<pre><code class="language-C++">//begin implementation file MyModule.cppm
//---------------------------------------
module MyModule; //module implementation, no export

int ModuleNS::internalFunc() {
    return //...
}
// no export keyword
int ModuleNS::getInt() {
    return ModuleNS::internalFunc();
}
</code></pre>
<pre><code class="language-C++">//begin Main.cpp
//----------------------------------------
import MyModule;

int i = ModuleNS::getInt();
int bad = ModuleNS::internalFunc(); //error
</code></pre>
<p>For the interface file, we must explicitly export the things we want to make available to outside code.
An implementation file does not contain the keyword export, but it can import other modules. We can also define a module all in one file as well.</p>
<pre><code class="language-C++">export module Module2;


import std.core; //module version of standard library
#include &lt;some_file.h&gt; // only affects this module
// can include normal headers as well

import &lt;iostream&gt; //compatability with standard lib headers
#define INTERNAL_DEFINE_ONLY 1

export namespace EntireExportedNS {
    void exportedFoo() {
        std::cout &lt;&lt; &quot;Foo&quot; &lt;&lt; std::endl;
    }
    
    std::string exportedBar() {
        return &quot;Bar&quot;;
    }
    
    template&lt;typename T, typename U&gt;
    auto sum(T a, U b) {
        return a + b;
    }
}
//template functions can be defined in modules
</code></pre>
<p>When we export a namespace like above, all the names in the namespace are exported.
I'm not sure if this is a quirk, but I have found that exporting a template directly does not seem to work, but it can be done if you put it in an exported namespace.</p>
<p>You may be curious how templates can be defined in modules if they are precompiled.
Well that's because they aren't exactly precompiled. Instead, they're stored as abstract syntax trees.</p>
<p>Modules also have <em>partitions</em> that allow an implementation to be split up into multiple files.
Last time I checked, this is currently unsupported, at least in MSVC.
I also believe that modules are still in early stages for other compilers and is the most fleshed out in MSVC. </p>
<p>Here's the partition syntax. A partition is specified following a colon and can be used exactly like a module.</p>
<pre><code class="language-C++">// Begin file hello.cpp
// ------------------------------
export module Hello:inter; 
// partition :inter of module Hello
#include &lt;string_view&gt;
// interface partition of Hello
export void SayHello
  (std::string_view const &amp;name);

// Begin file helloImpl.cpp
// -------------------------------
module;
#include &lt;iostream&gt;
// implementation partition of Hello
module Hello:impl; 
import :inter; // import the interface partition
import &lt;string_view&gt;; 

using namespace std;
void SayHello (string_view const &amp;name)
// matches the interface partitionss exported
// declaration
{
  cout &lt;&lt; &quot;Hello &quot; &lt;&lt; name &lt;&lt; &quot;!\n&quot;;
}

// Begin file hello.ixx
// --------------------------------------
export module Hello;
// reexport the interface partition
export import :inter; 
import :impl; // import the implementation partition
// export the string header-unit
export import &lt;string_view&gt;;  
</code></pre>
<p><sup class="footnote-reference"><a href="#1">1</a></sup>
To use in MSVC, module interfaces must have the .ixx file extension and module implementations must have the .cppm extension.
You must also download the experimental module extensions to the C++ build tools and enable it with the compiler flag <code>/experimental:module</code>.
Modules are currently unsupported in cmake with the ninja build system.</p>
<p>Here's a narrow cast utility re-implemented with concepts and modules:</p>
<pre><code class="language-C++">export module Cast;
import std.core;

// module linkage definitions
// not visible to users
// integral to integral (or enum)
template&lt;typename R, typename T&gt;
requires 
    (std::is_arithmetic_v&lt;R&gt; &amp;&amp; 
    (std::is_arithmetic_v&lt;T&gt; || std::is_enum_v&lt;T&gt;))
bool isSignMismatch(T val) {
	return val &lt; static_cast&lt;T&gt;(0) &amp;&amp; 
	    !std::is_signed_v&lt;R&gt;;
}
//integral to enum overload
template&lt;typename R, typename T&gt;
requires 
    (std::is_enum_v&lt;R&gt; &amp;&amp; 
    (std::is_arithmetic_v&lt;T&gt; || std::is_enum_v&lt;T&gt;))
bool isSignMismatch(T val) {
	return (val &lt; static_cast&lt;T&gt;(0) &amp;&amp; 
	!std::is_signed_v&lt;std::underlying_type_t&lt;R&gt;&gt;);
}
//non integral types
template&lt;typename R, typename T&gt;
bool isSignMismatch(T val) {
	return false;
}
// these constraints can be cleaned up as concepts

// exporting the public interface
export namespace SUtil {
	template&lt;typename R, typename T&gt;
	concept StaticCastableTo = requires(T a) {
		static_cast&lt;R&gt;(a);
		// defines this concept as being able to
		// cast from the type in question to R
	};

	/**
	 * Safely casts &lt;T&gt; to &lt;R&gt; if value can fit inside &lt;R&gt;
	 */
	template&lt;typename R, StaticCastableTo&lt;R&gt; T&gt;
	    requires StaticCastableTo&lt;T, R&gt;
	R narrow_cast(T value) {
		if (static_cast&lt;T&gt;(static_cast&lt;R&gt;(value)) != value)
			throw std::bad_cast();
		return static_cast&lt;R&gt;(value);
	}

	/**
	 * Safely casts &lt;T&gt; to &lt;R&gt; if value can fit inside &lt;R&gt;
	 * Fails if value is &lt; 0 and R is unsigned
	 */
	template&lt;typename R, StaticCastableTo&lt;R&gt; T&gt;
	    requires StaticCastableTo&lt;T, R&gt;
	R strict_narrow_cast(T value) {
		if (isSignMismatch&lt;R&gt;(value)) throw std::bad_cast();
		return narrow_cast&lt;R&gt;(value);
	}
}

// not part of narrow cast --------------
export class Person {
private:
    int age;
public:
    int getAge() {
        return age;
    }
}
</code></pre>
<p>While templates can be in modules, they only seem to be able to go in module interface files, for (presumably) the same reasoning as having to put them in header files.
I didn't try it, but I'm sure you can manually instantiate a finite number of templates the same way you would if you put a template definition in a source file.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://accu.org/journals/overload/28/159/sidwell/">Sample Source</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ranges"><a class="header" href="#ranges">Ranges</a></h1>
<p>One of tips I give at the end of this is to keep function parameters to a minimum.
Yet, the STL has plenty of functions that take quite a lot, upwards of 5 or 6.
Typically, this occurs when passing pairs of iterators because the STL was missing an abstraction: a range.</p>
<p>Ranges are a concept.
Each type of range corresponds to a type of iterator that satisfies the concept.
We have, as you'd expect <code>std::ranges::input_range</code>, <code>output_range</code>, <code>bidirectional</code>, <code>forward</code>, <code>random_access</code>, and <code>contiguous</code> along with <code>sized_range</code> (size can be determined in constant time),
<code>borrowed_range</code> (iterators not tied to lifetime of the object and are always safe to dereference) and a few others.
The basic requirements to construct a range is that a type provides an iterator via <code>begin()</code>, and an ending sentinel via <code>end()</code>. </p>
<p>We looked at <code>std::string_view</code> before, and a range is basically just an extension and generalization of that idea. But, remember, a range is not a type, it's a concept.
Thus, a vector, map, list, anything can be used as a range. It only just needs a <code>begin()</code> and <code>end()</code> member function. </p>
<p>What about pointers you ask? Well, we can wrap them in a <code>std::span</code> which takes a pointer and size, and provides the required interface for a range.
You can choose to use a span with a static or dynamic length. You can also use <code>std::ranges::subrange</code>, passing a begin and end iterator to convert traditional
C++ iterators into a range.</p>
<pre><code class="language-C++">
template&lt;std::range R&gt;
void func(R&amp;&amp; range){
    std::ranges::for_each(std::forward&lt;R&gt;(range), 
    [](auto&amp; i){
        std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    });
    std::cout &lt;&lt; std::endl;
}

auto myStr = &quot;Hello World&quot;;
std::span&lt;const char&gt; dynamicSpan 
    {myStr, strlen(myStr) + 1};

int nums[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

std::span&lt;int, 10&gt; staticSizedSpan {nums};

std::vector v = {20, 10, 4};
std::string str = &quot;Hello&quot;;
const auto vRange = std::ranges::subrange(v.begin(), v.end());

func(str);
func(v);
func(staticSizedSpan);
func(dynamicSpan);
func(vRange);
</code></pre>
<p>The ranges namespace defines range version of each STL algorithm.
Actually, that's a lie. They don't operate on ranges they operate on views.
A view is something that can view or transform the underlying contents of a range.
It's important to note that operations on views are <em>lazy evaluated</em>,
the result is computed on-demand, not up-front.
Furthermore, views follow a functional paradigm: they don't mutate the actually container.</p>
<pre><code class="language-C++">std::vector v = {10, 20, 30.0, 40.55};
for(auto&amp; it : std::views::reverse(v)){
    std::cout &lt;&lt; it &lt;&lt; std::endl;
}
</code></pre>
<p>This does not create a new vector, nor does it modify the existing one.
Instead, it determines the next element, in reverse order, at each iteration.
All the views are callable objects. These objects overload <code>operator|</code> to provide pipelining capabilities. Here's an example:</p>
<pre><code class="language-C++">auto range = v
    | std::views::filter([](auto&amp; x){ return x % 2})
    | std::views::reverse
    | std::views::take(5);
</code></pre>
<p>This will construct a view from v, that &quot;contains&quot; only the first 5 odd numbers from back to front.
You can see the bitwise or operator is overloaded to work exactly like the unix pipe or pipeline operators in other languages.</p>
<p>Notice how each functor also has a partial application form.
<code>std::views::take(5)</code> returns another functor, this time with only 1 parameter and that's the range to operator on.
The traditional function syntax of take would be <code>std::views::take(v, 5)</code>;</p>
<p>Here's another example:</p>
<pre><code class="language-C++">std::map&lt;int, std::string&gt; m = //...

for(auto it : std::views::keys(m)
            | std::views::sort
            | std::views::drop(10)
            | std::views::transform(
                [](auto&amp; key){ return key * 10}))
{
    std::cout &lt;&lt; it &lt;&lt; std::endl;
}
</code></pre>
<p>This will take the keys of the map, sort them, skip the first 10, and for the rest: iterate over each and transform them by multiplying by 10. </p>
<p>Notice that <code>it</code> is not declared <code>auto&amp;</code>, this is because transform, and other &quot;mutating&quot; view transformations don't mutate anything and thus return rvalues.
You may think of a view as an immutable range of sorts.</p>
<p>Here's some more examples:</p>
<pre><code class="language-C++">std::string csv = &quot;Hello,How,House,Happiness&quot;;
std::string sentence = &quot;Hello My name is Bob&quot;;

auto sentence1 = csv | std::views::split(',') 
    | std::views::drop(1) | std::views::take(2);
//How, House

auto sentence2 = sentence | std::views::split(' ');
//My, name, is, Bob in some order


auto isPrime = [](int x) {
    for (auto j = 2; j * j &lt;= x; ++j) {
        if (x % j == 0) return false;
    }
    return true;
};
auto primes = std::views::iota(100)
    | std::views::filter(isPrime)
    | std::views::take(10);
// MSVC doesn't seem to like iota, but it is in the library reference
// so I'm pretty sure this is right
for (auto i : primes) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}
// generate the first 10 prime numbers starting from 100.
</code></pre>
<p><code>std::views::iota</code> can take one or two parameters.
The one parameter version creates an infinite stream starting with the value of the parameter and incremented one at a time.
The two parameter version is a finite stream of values between the first parameter and the second parameter.</p>
<p>Here's another example of passing a range to a function. This returns an iterator if the value was found or an empty optional if not.</p>
<pre><code class="language-C++">template&lt;std::ranges::range R, typename T&gt;
auto bsearch(R&amp;&amp; range, T val) 
    -&gt; std::optional&lt;decltype(range.begin())&gt; 
{
	auto first = std::ranges::lower_bound(range, val);
    // do not forward because we continue to use range

	if (first != range.end() &amp;&amp; *first == val) {
		return first;
	}
	return {};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coroutines"><a class="header" href="#coroutines">Coroutines</a></h1>
<p>At the time of writing this, I really don't know much about these. I'll explain the basics, but I will continue to look into this topic on my own time.
In short, coroutines are functions that can be suspended and resumed mid-execution.
They are stackless: they don't use a stack to store their activation records.
I believe this is a quality of C++20 coroutines and not a requirement of coroutines in general.
Instead of the traditional subroutine model: a caller executes a subroutine from the start,
waits until completion and then resumes, a coroutine execution can be interleaved.
The coroutines are more like partners, one makes progress, yields to the other, the second makes progress, yields to the first and so on.
To this end, they provide concurrency, but not parallelism.
When you use the operators <code>co_return</code>, <code>co_yield</code>, and/or <code>co_await</code> in a function,
the compiler converts it to a coroutine with a finite state machine to control program flow and transfers.
C++20 provides a pretty low-level API that's designed for library writers to build upon.
For a good coroutine library, check out <a href="https://github.com/lewissbaker/cppcoro">cppcoro</a> and for more detailed information, check our <a href="https://lewissbaker.github.io/">Lewis Baker's github</a>.</p>
<p>Coroutines (henceforth referred to as &quot;coro&quot;) can be resumed,
suspended, and destroyed.
Resuming a coro will transfer execution back to it at where it left off.
Suspending one will save the current suspension point onto the activation frame and return control to the awaiter/caller.
Destroying a coro cleans up the activation frame.
The activation frame for coroutines are known as coroutine frames which contains space for parameters, local variables, temporaries, execution state (how to resume) and promises (for return values).</p>
<p>C++20 provides two interfaces for coros, a <code>promise_type</code> and <code>awaiter</code>.
Note that these interfaces are not interfaces in the OOP sense, but rather concepts with certain functions (static interfaces) that the compiler calls when turning a function into a coroutine.
It should also be noted that the coro promise is not the same as the concurrency promise.</p>
<p>An awaiter specifies three methods: <code>await_suspend()</code>, <code>await_resume()</code>, and <code>await_ready()</code>.
When you call <code>co_await</code> on the object, the compiler first checks if the promise defines a function <code>await_transform()</code>, which will be called if it exists otherwise the compiler just gets the awaiter directly.</p>
<p><code>await_ready()</code> returns a bool indicating if the next value to be produced by the coro is ready.
Internally, when you <code>co_await</code> on an awaiter, it calls <code>await_ready()</code>, if it returns true, it will then call <code>await_resume()</code>, otherwise <code>await_suspend()</code> is called.</p>
<p><code>await_suspend()</code> takes in a handle to a coro, and can either return <code>void</code> or the handle to the coro to resume.
The latter is known as a <em>symmetric transfer</em> and prevents allocating excess stack frames.
This works by following a premise similar to tail recursion vs non-tail recursion.
When a coro is suspended, the compiler stores all relevant state and creates a <code>coroutine_handle</code> object.</p>
<p><code>await_resume()</code> is what produces the return type for a <code>co_await</code> expression.</p>
<p>A <code>promise_type</code> specifies methods for customizing the behavior of the coro itself.
The <code>promose_type</code> interface has a few methods including <code>initial_suspend()</code>, <code>final_suspend()</code>, <code>yield_value()</code>, <code>return_value()</code>, <code>get_return_object()</code>, and <code>unhandled_exception()</code>.
<code>initial_suspend()</code> is called on the first suspension of the coro, <code>final_suspend()</code> and <code>yield_value()</code> are called from <code>co_yield</code>, <code>return_value()</code> is called from <code>co_return</code>,
and <code>get_return_object()</code> is for returning the result of the coro.
<code>unhandled_exception()</code> is called in a catch block for any exception the propagates out.
For initial and final suspend, the standard defined <code>std::suspend_always</code> and <code>std::suspend_never</code> can be returned to control suspension behavior.</p>
<p><code>co_return</code> takes the place of a normal <code>return</code> call, while <code>co_yield</code> doesn't clean up the coro frame, but instead returns a value and resumes execution on the cooperating coro or caller.</p>
<p>The <code>promise_type</code> is wrapped in an <code>std::coroutine_handle&lt;&gt;</code> which allows the holder to manage the coro and call operations such as <code>resume()</code>, <code>destroy()</code>, and <code>done()</code>.</p>
<p>This probably made little sense, probably because I'm not even quite sure if it all made sense to me.
So here's an example. A generator is something that evaluates lazily. If you are familiar with Python <code>range()</code> is an example of a generator.
SSo for this example we'll implement a <code>range()</code> function with coroutines.
We can do this without coros with just iterators, but where's the fun in that.
The general structure will be that we have a <code>Generator</code> class with a promise type and an iterator.
Each time the iterator is incremented, it resumes the coro which uses <code>co_yield</code> to produce a value.
Let's first start by defining our promise type.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
struct Generator {
	// must be named promise_type
	struct promise_type {
		std::variant&lt;T const*, std::exception_ptr&gt; value;

		void throwIfException() {
			if (value.index() == 1) {
				std::rethrow_exception(std::get&lt;1&gt;(value));
			}
		}

		//Functions required for a coroutine promise

		std::suspend_always initial_suspend() {
			// suspend on creation to step through manually
			return {};
		}
		std::suspend_always final_suspend() noexcept {
			// suspend on return instead of destroying state
			return {};
		}
		std::suspend_always yield_value(T const&amp; other) {
			value = std::addressof(other);
            // assign data to value

            // std::addressof() gets the address of a variable even if someone
            // (evily) overloaded `operator&amp;`
			return {};
		}

		void return_void() {}

        // gets the return object from the promise
		Generator&lt;T&gt; get_return_object() {
			return Generator&lt;T&gt;(handle_type::from_promise(*this));
		}
		// called by compiler if coro produces an exception
		void unhandled_exception() {
			value = std::current_exception();
		}
        
        // this function called by co_await
        //
        // disable awaiting on the generator since
        // it can be an infinite stream of values
		void await_transform() = delete;
	};
</code></pre>
<p>We store the value of our coro as a variant, since it can hold either a value or an exception.
We define the necessary functions to satisfy the <code>promise_type</code> interface.
Notice we define, but don't implement <code>await_transform</code> which prevents anybody from calling <code>co_await</code> on this promise.
Next we'll define the iterator:</p>
<pre><code class="language-C++">	using handle_type = std::coroutine_handle&lt;promise_type&gt;;
	struct iterator {
		handle_type handle;
		
		// iterator trait typedefs
		using iterator_category = std::input_iterator_tag;
		using value_type = T;
		using difference_type = ptrdiff_t;
		using pointer = T const*;
		using reference = T const&amp;;

		iterator&amp; operator++() {
		    // resume the coro
			handle.resume();

			if (handle.done()) {
				auto &amp; pro = handle.promise();
				handle = nullptr;
				pro.throwIfException();
			}
			return *this;
		}

		bool operator==(const iterator&amp; other) const {
			return handle == other.handle;
		}

		bool operator!=(const iterator&amp; other) const {
			return !(*this == other);
		}

		T const&amp; operator*() {
			return *std::get&lt;0&gt;(handle.promise().value);
		}

		T const&amp; operator-&gt;() {
			return operator*();
		}
	};
</code></pre>
<p>For an iterator in an enhanced for-loop, the compiler needs to be able to compare equality with <code>==</code> and <code>!=</code>,
so we define those which delegate the comparisons to the handle.
We also provide derefence capability, which will throw if an exception is stored in the variant instead of a value.
In the iterator incrementation, we resume the coro. If the coro finishes abruptly, then we know an error has occurred and rethrow the exception.
Here's the rest of the Generator:</p>
<pre><code class="language-C++">    // local variable handle to coro
	handle_type handle{ nullptr };

	friend void swap(Generator&lt;T&gt;&amp; a, Generator&lt;T&gt;&amp; b) {
		std::swap(a.handle, b.handle);
	}

	Generator() = default;

	Generator(const handle_type&amp; handle) :
		handle(handle) {};

	Generator(handle_type&amp;&amp; handle) :
		handle(std::move(handle)) {}

	Generator(Generator&lt;T&gt;&amp;&amp; other) {
		swap(*this, other);
	}

	Generator&amp; operator=(Generator&lt;T&gt;&amp;&amp; other) {
		swap(*this, other);
		return *this;
	}

	Generator(Generator&lt;T&gt;&amp;) = delete;
	Generator&lt;T&gt;&amp; operator=(Generator&lt;T&gt;&amp;) = delete;

	~Generator() {
		if (handle)
			handle.destroy();
	}

	iterator begin() {
		handle.resume();

		if (handle.done()) {
			handle.promise().throwIfException();
			return { nullptr };
		}

		return { handle };
	}
	iterator end() {
		return { nullptr };
	}
};

template&lt;typename T&gt;
Generator&lt;T&gt; range(T begin, T end) {
	while (begin != end) {
		co_yield begin++;
	}
}
template&lt;typename T&gt;
Generator&lt;T&gt; range(T end) {
	T begin{};
	while (begin != end) {
		co_yield begin++;
	}
}
</code></pre>
<p>We use RAII features to destroy the coro frame on destruction of the generator.
We provide move capabilities and remove copy capabilities.
Finally, we provide <code>begin()</code> and <code>end()</code> methods to our generator so it can be used in a for loop.
Notice our coroutine doesn't explicitly create a Generator itself.
Instead, the compiler handles all of that and constructs the coro handle to pass to the generator. Here's the usage:</p>
<pre><code class="language-C++">int main() {
    for (auto i : range(10)) {
        printf(&quot;%d &quot;, i);
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>Here's another example. This one is a Task class which allows tasks to be scheduled and lazily evaluated when you await them.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
struct Task {
	struct promise_type;
	using handle_t = std::coroutine_handle&lt;promise_type&gt;;
	
	// promise type
	// similar as last time
	struct promise_type {
		std::variant&lt;T, std::exception_ptr&gt; value;
		std::coroutine_handle&lt;&gt; previous;

		Task get_return_object() {
			return { handle_t::from_promise(*this) };
		}
		std::suspend_always initial_suspend() { return {}; }
		struct final_awaiter {
			bool await_ready() noexcept { return false; }
			void await_resume() noexcept {}
			std::coroutine_handle&lt;&gt; await_suspend(handle_t handle) 
			    noexcept 
			{
				if (auto prev 
				    = handle.promise().previous; prev) {
				    //symmetric transfer to &quot;caller&quot; if there was one
				    //this is known as init-if syntax and
				    //is in C++17
					return prev;
				}
				else
					return std::noop_coroutine();
			}
		};
		final_awaiter final_suspend() noexcept {
			return {};
		}
		void unhandled_exception() {
			value = std::current_exception();
		}
		void return_value(T&amp;&amp; val) {
		    // sets value on co_return
			value = std::forward&lt;T&gt;(val);
		}

	};

	handle_t handle;


	Task(handle_t h) :
		handle(h) {};
	~Task() {
		if (handle)
			handle.destroy();
	}
	//move operations not defined
	
	
	struct awaiter {
		handle_t handle;
		// always execute the coro
		bool await_ready() noexcept { return false; }
		
		// this is the return value of an 
		// co_await expression
		// rethrow if we caught an error
		T await_resume() {
			auto var = handle.promise().value;
			if (var.index() == 1)
				std::rethrow_exception(std::get&lt;1&gt;(var));
			else
				return std::get&lt;0&gt;(var);
		}
		auto await_suspend(handle_t h) {
			handle.promise().previous = h;
			return handle;
		}
	};
	// overload co_await
	awaiter operator co_await() {
		return awaiter{ handle };
	}
	
	// get result from a non coroutine function
	// main cannot be a coro
	T operator()() {
		handle.resume();
		auto var = handle.promise().value;
		if (var.index() == 0)
			return std::get&lt;0&gt;(var);
		else
			std::rethrow_exception(std::get&lt;1&gt;(var));
	}
};
</code></pre>
<p>A few things to point out is that <code>main()</code> cannot be a coro.
Thus, no calls to <code>co_await</code>, <code>co_yield</code> etc. can occur inside it.
To circumvent this in our simply example, we define an <code>operator()</code> for getting the result of the task from a normal function.
We also use C++17's init-if syntax that allows you to form an if statement like so:</p>
<pre><code class="language-C++">if(auto = /*initializer*/; /*condition*/){

}
</code></pre>
<p>The condition block and following if-else block has scope of the initialized variable.
Usage of the task looks like the following:</p>
<pre><code class="language-C++">Task&lt;int&gt; getNum() {
    co_return 5;
}
Task&lt;int&gt; getCollector() {
    auto v1 = getNum();
    auto v2 = getNum();
    co_return co_await v1 + co_await v2;
}
int main() {
    auto result = getCollector();
    printf(&quot;%d \n&quot;, result());
    return 0;
}
</code></pre>
<p>Once again, notice no <code>co_await</code> calls were performed in main.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rocketship-operator"><a class="header" href="#rocketship-operator">Rocketship Operator</a></h2>
<p>This is actually called the 3-way-comparison operator, but it's colloquially known as the Rocketship Operator.</p>
<p>If you've ever implemented a comparable type, you may know the pain of manually defining all <code>&lt;=, ==, !=, &gt;= &lt;, &gt;</code> and then defining them again so that they are commutative.
If so, then the three-way comparison <code>( &lt;=&gt; )</code> is what you need! Given the following syntax:
<code>a &lt;=&gt; b</code>
It returns an object that is implicitly convertible to an <code>int</code> that is:</p>
<ul>
<li><code>&lt; 0</code> if <code>a &lt; b</code></li>
<li><code> = 0</code> if <code>a == b</code></li>
<li><code> &gt; 0</code> if <code>a &gt; b</code></li>
</ul>
<p>What it actually returns is an object of type <code>std::strong_ordering</code> or <code>std::partial_ordering</code>, which are convertible to integers.
<code>std::strong_ordering</code> has 3 members, <code>std::strong_ordering::equal</code>, <code>less</code>, and <code>greater</code>.
<code>std::partial_ordering</code> has 4: <code>equivalent</code>, <code>less</code>, <code>greater</code> and <code>unordered</code>.</p>
<p>The nice thing about our little rocketship here <sup class="footnote-reference"><a href="#1">1</a></sup>, is that we don't have to explicitly use it to take advantage of it. Consider:</p>
<pre><code class="language-C++">#include &lt;compare&gt;
struct Person {
    std::string name;
    int age;
    
    Person(std::string n, int a) 
        : name(n), age(a) {}
    
    auto operator&lt;=&gt;(const Person&amp; other) {
        return age &lt;=&gt; other.age;
    }
    
    auto operator&lt;=&gt;(int age) {
        return this-&gt;age &lt;=&gt; age;
    }

    auto operator&lt;=&gt;(char c) {
        if (name.empty())
            return std::partial_ordering::unordered;
        c = toupper(c);
        if (auto first_letter = toupper(name[0]); first_letter &lt; c)
            return std::partial_ordering::less;
        else if (first_letter == c)
            return std::partial_ordering::equivalent;
        else
            return std::partial_ordering::greater;
    }
}

Person p {&quot;PersonA&quot;, 20};
Person p2 {&quot;PersonB&quot;, 18};
Person p3 {&quot;ABB&quot;, 18};

if(p2 &lt; p) {
    //this executes
}
if(100 &gt;= p) {
    //this executes
}
auto val = p2 == p3; //true
</code></pre>
<p>The compiler uses <code>operator&lt;=&gt;</code> to generate definitions for all other comparison functions! It also uses this to generate communative versions of each comparison operator as well!
Traditionally, if we defined <code>&gt;=</code> for an <code>int</code> and our type,
we'd have to define two versions.
One where the integer is the left-hand parameter, and the other where the integer is the right.
With the spaceship operator, the compiler handles that for us.
Indeed, what's actually going on is the compiler is generating all the comparison functions for us. </p>
<p>There is a slight problem. For some types, such as strings, some comparison operations are much faster than others, namely <code>==</code> and <code>!=</code>.
If two strings aren't the same size, they cannot be equal, and we can do this check quickly before lexicographically comparing them character by character.
However, determining if one string is less than another always requires an <code>O(n)</code> lexicographic comparison.
The good news is that's perfectly fine because the compiler will implement <code>==</code> independently of the spaceship operator and handle that for you.
If you had your own type with your own equality comparison that wasn't simply delegating the comparison to a member, you can simply define your own operator==().
Any manually defined comparison operators will take precedence over the rocketship operator.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>No innuendo intended</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>Here we'll look at some common tools and libraries used in C++. What I present aren't the only implementations of their kind but, popular ones on Linux.</p>
<p>For most Linux distros, these tools can be installed via the package manager (packages <code>cmake</code>, <code>doxygen</code> and <code>gdb</code>). 
Note that you will likely need to install <code>graphviz</code> for Doxygen. 
For Windows, you can find precompiled binaries online (I'll provide links in their relative chapters) except for gdb and gprof, which are Linux tools.</p>
<blockquote>
<p>&quot;If you give people tools, and they use their natural abilities and their curiosity, they will develop things in ways
that will surprise you very much beyond what you might have expected.&quot;</p>
<p>- Bill Gates</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-and-debugging"><a class="header" href="#testing-and-debugging">Testing and Debugging</a></h1>
<p>In this chapter we'll look at useful tools for testing and debugging. 
Besides the obvious usage of finding bugs, testing also forces us to program with an interface in mind, not an implementation. 
A lot of times, to write tests we'll be forced to create a test implementation and a real one. 
Thus, this forces us to create an interface in which both implementations can subtype. For example, when testing an HTTP client, it can be hard to write tests using a live connection to an HTTP server. 
First of all if the reading logic is incorrect, it becomes terribly difficult to even see the error responses from the server. 
Secondly, such error messages aren't going to be the most useful in tracking down bugs in your code. 
So, we can abstract away the live connection behind an interface, and have a live implementation and test implementation which might just write data to a buffer in memory.</p>
<p>A common misconception is that testing early and often is a tradeoff: more time spent now means less time debugging later and that we can streamline the development process, if necessary, 
by putting off tests until later. While it makes sense, Jason Gorman and Uncle Bob have found that lack of testing takes more time in both the short and long term. 
Testing can guide our design process, identify oversights in the specification, help us learn new libraries, and more.</p>
<h2 id="tdd"><a class="header" href="#tdd">TDD</a></h2>
<p>TDD stands for test-driven development, and it's the common unit testing methodology to write tests before you write the code that it's testing. The TDD programming cycle is as follows:</p>
<ol>
<li>Create a failing unit test</li>
<li>Write code to make that unit test pass</li>
<li>Clean, refactor, and ensure it still passes</li>
<li>Repeat</li>
</ol>
<p>Some advocate the following 3 laws of TDD, which lock you into cycles of roughly 30 to 60 seconds:</p>
<ol>
<li>Do not write code until you write a failing unit test</li>
<li>Do not write more test code than is sufficient to fail. Not compiling is failing.</li>
<li>Do not write more production code than is necessary to make a failing test pass.</li>
</ol>
<p>Sometimes the amount of test code to rival or exceed the amount of production code. 
Furthermore, many advocate that test code should be just as clean and well-designed as production code. 
This is because that test code must be as easy to change as production code, the two code bases must grow and evolve together. 
If the test code is rigid, then they'll either have to be rewritten every time the production code changes (leaving you vulnerable to forgetting corner cases), 
or the rigidness of the test code will make you unwilling to make the necessary changes to production code. 
Ideally, the only different between test and production code is performance. 
For example, in production you might want to have overloads for passing and returning lvalue and rvalue references while during testing you might find it sufficient to simply pass by value. 
However, it's vital that test code be as readable and clean as production. 
Clean test code can even serve as documentation (in Rust, examples written in documentation comments, can be run by the test framework to ensure they pass).</p>
<p>Tests should be:</p>
<ul>
<li><strong>F</strong>ast - quick and easy to run. One command or one button to run all tests and get a quick result.</li>
<li><strong>I</strong>ndependent - should not rely on any order of tests being run and not depend on other tests</li>
<li><strong>R</strong>epeatable - run in any environment on any machine</li>
<li><strong>S</strong>elf-validating - have a single boolean (pass/fail) output</li>
<li><strong>T</strong>imely - should be able to write somewhat quickly before writing production code</li>
</ul>
<p>To state TDD another way, the steps are basically: Red, Green, Refactor. 
First you make it Red: create a failing test. This is vital because you need to know your test doesn't always pass. 
It would get cumbersome to have tests of tests so this red step is essentially the manual testing of our test case. 
Then you make it Green: make the test pass as fast as possible. Embrace bad engineering, don't worry about design patterns in this step just figure out how to implement the feature in the simplest way possible. 
In this step the goal is to wrap your head around a correct solution. It's hard to do two things at once so trying to make something clean and correct at the same time can make things extremely difficult. 
Finally, refactor: you've already implemented a solution once, so you will have a better idea of what patterns and idioms will work to clean up the code. 
You'll be able to more easily organize the code since you already know what it's doing. This step should NOT lead you to write new tests.</p>
<p>You should test to an interface, not an implementation. 
In other words, only test the public API. The thing that should trigger writing a test case is not a new function or class, but rather a new requirement of the software, or a new behavior in an interface. 
Some people find that &quot;Behavior Driven Development&quot; is a better name than &quot;Test Driven Development&quot; for this reason. 
So for example, when developing a helper method, you most likely shouldn't start by writing a failing test case for it, the tests for methods the helper is used in cover it already. 
This isn't always the best approach however: you might not be sure if the helper method is correct, or you might not be sure how to go about implementing whatever algorithm you're trying to write. 
In this case we can drop down into a lower &quot;gear&quot; and use TDD for the implementation details. However, once the algorithm is implemented, these tests should be deleted because they rely on an 
implementation and thus make the implementation details rigid. Tests should not know about the implementation. 
This should not be confused with me saying &quot;glass-box testing is bad&quot;, rather what I'm saying is you don't want to enforce any constraints on the implementation. 
You may very well pick corner cases to test based on the implementation and code coverage, but changing the implementation or refactoring should not make these tests fail.</p>
<p>Sometimes, you might find you have a clear idea of what you're trying to implement. 
In this case we can &quot;shift&quot; into a higher &quot;gear&quot; and streamline this red, green, refactor process. You might choose to go straight from red to refactor and make a clean solution as you are making a correct one. 
Sometimes you might find that what you're implementing is so simple, it doesn't even warrant TDD.</p>
<p>The &quot;unit&quot; in unit testing is often times a module, and although OOP languages realize modules as classes, this does not mean every class is a module. 
A module satisfies an abstraction, and can be composed of multiple classes. But even so, a module may not be a &quot;unit&quot;. 
Kent Beck highlights that the &quot;unit&quot; in a unit test is the test itself. In this sense he means that tests must be independent of each other.</p>
<blockquote>
<p>&quot;I'm not a great programmer; I'm just a good programmer with great habits.&quot;</p>
<p>- Kent Beck</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="google-test"><a class="header" href="#google-test">Google Test</a></h1>
<p>GTest is Google's C++ unit testing framework. It's not the only one out there, but it is a good one.</p>
<p>We'll use CMake to automatically download, generate, and build GTest from github. In the next unit. We'll discuss CMake in more detail so these may not make the most sense right now.
In the top directory, we'll want to have a <code>CMakeLists.txt</code> and a <code>GTestCMakeLists.txt.in</code> that looks like this:</p>
<p>CMakeLists.txt</p>
<pre><code class="language-Python">cmake_minimum_required (VERSION 3.8)

project (&quot;Tests&quot;)

macro(external_add filename pkname)
	configure_file(${filename} &quot;${CMAKE_SOURCE_DIR}/external/${pkname}-download/CMakeLists.txt&quot;) 
    # Copy file specified as first argument of macro into external/gtest-download/CMakeLists.txt
    # and execute it (will download lib)

	execute_process(COMMAND &quot;${CMAKE_COMMAND}&quot; -G &quot;${CMAKE_GENERATOR}&quot; .
		WORKING_DIRECTORY &quot;${CMAKE_SOURCE_DIR}/external/${pkname}-download&quot;)
    # Run CMake generator in download directory

	execute_process(COMMAND &quot;${CMAKE_COMMAND}&quot; --build .
		WORKING_DIRECTORY &quot;${CMAKE_SOURCE_DIR}/external/${pkname}-download&quot;)
    # Run build command in generated src directory from the previous command

	set(${pkname}_SUBDIRS &quot;${CMAKE_SOURCE_DIR}/external/${pkname}-src&quot;
	&quot;${CMAKE_SOURCE_DIR}/external/${pkname}-build&quot;)
    # Set a variable called gtest_SUBDIRS
endmacro() 

#Install googletest
external_add(GTestCMakeLists.txt.in gtest)
# calls the macro with the first argument as GTestCMakeLists.txt.in
# and the second argument as gtest

set(gtest_force_shared_crt ON CACHE BOOL &quot;&quot; FORCE)

add_subdirectory(${gtest_SUBDIRS})
# Run CMake in subdirectories (GTest has its own CMakeLists.txt)


enable_testing()
include (CTest)

# Enable CMake testing
# Allows CMake commands to find and run tests

# Include sub-projects.
add_subdirectory (&quot;Tests&quot;)
</code></pre>
<p>GTestCMakeLists.txt.in</p>
<pre><code class="language-CMake">cmake_minimum_required(VERSION 3.8)
project(gtest-download NONE)

include(ExternalProject)
ExternalProject_Add(googletest
	GIT_REPOSITORY https://github.com/google/googletest.git
	GIT_TAG master
	SOURCE_DIR &quot;${CMAKE_SOURCE_DIR}/external/gtest-src&quot;
	BINARY_DIR &quot;${CMAKE_SOURCE_DIR}/external/gtest-build&quot;
	CONFIGURE_COMMAND &quot;&quot;
	BUILD_COMMAND &quot;&quot;
	INSTALL_COMMAND &quot;&quot;
	TEST_COMMAND &quot;&quot;
	)
# Download GTest from github
</code></pre>
<p>You project directory should look something like this:</p>
<pre><code>Tests
|   CMakeLists.txt
|   GTestCMakeLists.txt
|
|---external
|   |   gtest-download
|   |   gtest-build
|   |   gtest-src
|   |
|---Tests
|   |   CMakeLists.txt
|   |   main.cpp
|   |
|---out
</code></pre>
<p>Next, in the CMakeLists.txt file of the project subdirectory. Let's add an executable and link it with gtest</p>
<pre><code class="language-Python">cmake_minimum_required (VERSION 3.8)

# Add source to this project's executable.
add_executable (Test1 &quot;main.cpp&quot;)
target_link_libraries (Test1 PRIVATE GTest::gtest PRIVATE GTest::gtest_main)
# Linking with gtest_main allows us to use GTests' main function for us
add_test (NAME Test1 COMMAND Test1)
# create a test called Test1 which runs the target Test1
</code></pre>
<p>Finally, in main.cpp Let's write a basic test:</p>
<pre><code class="language-C++">#include &lt;gtest/gtest.h&gt;

TEST(SuiteName, testName) {
    ASSERT_TRUE(true);
}
</code></pre>
<p>Linking with <code>gtest_main</code> allows us to not write a main method. Which, sometimes we may need but would look like this:</p>
<pre><code class="language-C++">int main(int argc, char ** argv) {
    testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}
</code></pre>
<p>On Linux, you can execute tests with the command <code>make test</code>, or execute <code>ctest</code> in the build directory of the project.</p>
<p>In GTest, we can create a new test with the <code>TEST()</code> macro which takes as its first parameter the name of the suite and as a second parameter the name of the test. Both names must be valid C++ identifiers however they also must not contain underscores. Although we declare no variables <code>SuiteName</code> and <code>testName</code>, this still works because the macro stringifies whatever you type. Thus, the literal text entered for the suite name and test name becomes the actual name. So these arguments are not strings. Internally, this macro creates a class that uses <code>SuiteName</code> and <code>testName</code> for its name. Prepending either the suite or test name with &quot;DISABLED_&quot; will disable the test. Within a test, we can use gtest assertions or expectations to ensure behavior is as we expect. If an assertion fails, the test fails and exits immediately. If an expectation fails, the test fails but continues to run. Both assertions and expectations are named the same except expectations use <code>EXPECT_</code> while assertions are named <code>ASSERT_</code>.</p>
<p>It's generally good practice to minimize the amount of assertions per test (some developes advocate for one assertion per test). This makes it very easy to find what failed when you see that a test failed.</p>
<p>Let's look at some more useful assertions.</p>
<pre><code class="language-C++">TEST(SuiteName, testName2) {
    ASSERT_EQ(100 * 3, 300); // ==
    ASSERT_NE(100, 0); // !=
    ASSERT_LE(100, 100); // &lt;=
    ASSERT_LT(-20, 1); // &lt;
    ASSERT_GE(20, 19); // &gt;=
    ASSERT_GT(20, 0); // &gt;
    
    ASSERT_FLOAT_EQ(2.5f, 5.f / 2.f); // == but takes into account float precision loss
    ASSERT_DOUBLE_EQ(2.5, 5. / 2.); // same as above but for doubles
    ASSERT_NEAR(5, 6, 2); 
    // similar idea but you can specify the absolute difference 
    // such that two values are considered equal as the third arg

    ASSERT_ANY_THROW(throw std::string(&quot;hello&quot;));

    ASSERT_THROW(throw std::runtime_error(&quot;Test&quot;), std::runtime_error);

    ASSERT_NO_THROW([](){
        std::cout &lt;&lt; &quot;Hello&quot;;
    }());
}
</code></pre>
<p>Now what happens if a test fails? Well, we get a pretty helpful error message.</p>
<pre><code class="language-C++">TEST(SuiteName, testName3) {
    ASSERT_EQ(300 - 24, 7859 * 5634);
}

</code></pre>
<pre><code>../../Tests/Tests/main.cpp (&lt;line number here&gt;) expected equality of these values:
    300 - 24
        Which is: 276
    7859 * 5634
        Which is: 44277606
</code></pre>
<h2 id="printing"><a class="header" href="#printing">Printing</a></h2>
<p>Suppose we wanted to assert the equality of a user defined type. What would the error message be if the instances
aren't equal? Well, by default GTest will simply print a hex dump of each object. For some things, this might actually be
useful, but for most objects this is basically just gibberish. One way that we can tell GTest how to display custom objects by overloading <code>operator&lt;&lt;</code>. This is all well and good, but for some classes you might already have defined an <code>operator&lt;&lt;</code>, or you might not want to add something to a class's interface that only exists for testing purposes. Well in those cases, we can define a <code>PrintTo</code> function which returns <code>void</code> and takes two arguments: a <code>const</code> reference to our class and a pointer to an <code>std::ostream</code>.</p>
<pre><code class="language-C++">/// Overrides Gtest's print behavior
void PrintTo(const TestConfig&amp; test, std::ostream* os) {
  *os &lt;&lt; test.testName &lt;&lt; &quot;\n&quot;;
  *os &lt;&lt; &quot;\tStart: (lat=y= &quot; &lt;&lt; test.gpsRoverStart.y &lt;&lt; &quot;, lon=x= &quot; &lt;&lt; test.gpsRoverStart.x &lt;&lt; &quot;)\n&quot;;
  *os &lt;&lt; &quot;\tTarget: ('&quot; &lt;&lt; test.targetLocation.header.frame_id &lt;&lt; &quot;', x= &quot;
    &lt;&lt; test.targetLocation.point.x &lt;&lt; &quot;, y= &quot; &lt;&lt; test.targetLocation.point.y &lt;&lt; &quot;)\n&quot;;
  for (auto&amp; tag : test.arTagsUtm) {
    *os &lt;&lt; &quot;\tTag: (x= &quot; &lt;&lt; tag.x &lt;&lt; &quot;, y= &quot; &lt;&lt; tag.y &lt;&lt; &quot;)\n&quot;;
  }
  *os &lt;&lt; &quot;\tSuccess: &quot; &lt;&lt; test.expectSuccess &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<p>Now when printing our custom type, we'll be able to get data formatted however we'd like instead of just a hex dump. </p>
<p>Moreover, the gtest test macros actually return a stream. So we can use them to print extra information if the assertion fails.</p>
<pre><code class="language-C++">ASSERT_EQ(5, 4) &lt;&lt; &quot;Dummy test, this should fail!&quot;;
</code></pre>
<h2 id="test-fixtures"><a class="header" href="#test-fixtures">Test Fixtures</a></h2>
<p>A lot of times tests will need to share data or logic. In that case we can use a test fixture. 
A test fixture is a class derived from <code>testing::Test</code>. Any protected members will be available in all tests that use the fixture. 
It can provide a default constructor/destructor or override the members <code>SetUp()</code> and <code>TearDown()</code> to provide initialization and cleanup logic for any shared data. 
The constructor and <code>SetUp()</code> are called before each test and the destructor and <code>TearDown()</code> is called after each one. 
When I say &quot;shared data&quot;, I don't mean that the actual instances of each member are shared, but rather each test has its own instance of the same members.</p>
<p>Internally, the <code>TEST</code> macro creates a class that is a subtype of <code>Test</code>. 
We can create a test fixture and use the macro <code>TEST_F</code> to create a test that subtypes this custom fixture. 
The first argument to <code>TEST_F</code> is the test fixture name, and the second argument is the name of the test.</p>
<pre><code class="language-C++">class RingbufferFixture : public testing::Test {
protected:
    std::unique_ptr&lt;Ringbuffer&lt;int&gt;&gt; r1, r2;

    void SetUp() override {
        r1 = std::make_unique&lt;Ringbuffer&lt;int&gt;&gt;(10);
        r2 = std::make_unique&lt;Ringbuffer&lt;int&gt;&gt;(10);

        r2.push_back(10);
        r2.push_back(20);
        r2.push_back(30);
    }

    void r2Add(std::initializer_list&lt;int&gt; elems) {
        for (e : elems) {
            r2.push_back(e);
        }
    }
};

TEST_F(RingbufferFixture, startEmpty) {
    ASSERT_TRUE(r1.empty());
}

TEST_F(RingbufferFixture, pushChangesSize) {
    ASSERT_EQ(r2.size(), 3);
}

TEST_F(RingbufferFixture, maxSizeUpheld) {
    r2Add({1, 2, 3, 4, 4, 5, 5, 7, 8, 9});
    ASSERT_EQ(r2.size(), 10);
}

TEST_F(RingbufferFixture, basicIndex) {
    ASSERT_EQ(r2[0], 10);
    ASSERT_EQ(r2[1], 20);
    ASSERT_EQ(r2[2], 30);
    r2Add({40, 50, 60});
    ASSERT_EQ(r2[3], 40);
    ASSERT_EQ(r2[4], 50);
    ASSERT_EQ(r2[5], 60);
}

TEST_F(RingbufferFixture, loopingTest) {
    ASSERT_EQ(r2[0], 10);
    ASSERT_EQ(r2[1], 20);
    ASSERT_EQ(r2[2], 30);
    r2Add({40, 50, 60, 70, 80, 90, 100, 200, 300});
    ASSERT_EQ(r2[0], 100);
    ASSERT_EQ(r2[1], 200);
    ASSERT_EQ(r2[2], 300);
}
</code></pre>
<h2 id="parameterized-tests"><a class="header" href="#parameterized-tests">Parameterized Tests</a></h2>
<p>Right now, if we wanted to do randomized or repeated testing on different inputs, we'd need to use loops in a single test. 
That's not too bad, but it can get hard to debug what input caused the test to fail. 
More annoyingly, it would require us to write a loop in all test cases we'd want to repeat on different inputs. 
Luckily, we can use parameterized tests. First, we create a test fixture which inherits from <code>::testing::TestWithParam&lt;T&gt;</code> where <code>T</code> is the type of the input. 
If we need multiple inputs we can make <code>T</code> a tuple. Then we define our tests similar to the test fixture but with the <code>TEST_P</code> macro.</p>
<pre><code class="language-C++">class ParameterizedRBFixture : public ::testing::TestWithParam&lt;int&gt; {
protected:
    const int startingSize = 10;
    Ringbuffer&lt;int&gt; rb{startingSize};

};

TEST_P(ParameterizedRBFixture, pushTest) {
    const int param = GetParam(); // get param to test
    rb.push_back(param);
    ASSERT_EQ(rb[0], param);
}

TEST_P(ParameterizedRBFixture, pushSizeTest) {
    const int param = GetParam(); 
    for(auto i = 0; i &lt; param; ++i) {
        rb.push_back(i);
    }
    ASSERT_EQ(rb.size(), std::min(param, startingSize));
}


INSTANTIATE_TEST_CASE_P(RingBufferTests, ParameterizedRBFixture,
    testing::Values(1, 711, 1989, 2013));
// Calls ALL tests of the fixture with the specified values

// instead of specifying values by a parameter pack, we can also use
// testing::ValuesIn() which generates values from an array, container, or begin and end iterator

int vals[] = {4, 56, 70, 0, 100, 230};

INSTANTIATE_TEST_CASE_P(RingBufferTests, ParameterizedRBFixture,
    testing::ValuesIn(vals));


// Using an iterator for randomized testing:

class UniformIntGenerator {
    std::mt19937 generator {std::random_device{}()};
    std::uniform_int_distribution&lt;int&gt; random{0, 2};
    uint64_t maxCount, curCount;
    constexpr static uint64_t finished = ~0;
    int val;
public:
    using value_type = int;
    using difference_type = size_t;
    using pointer = int*;
    using reference = int&amp;;
    using iterator_category = std::forward_iterator_tag;

    UniformIntGenerator(uint64_t maxGenerations, int minVal, int maxVal) : random({minVal, maxVal}),
        maxCount(maxGenerations), curCount(0), val(random(generator)) {}

    /// Construct sentinel iterator
    UniformIntGenerator() : maxCount(0), curCount(finished), val(0) {}

    int operator*() const {
        if (curCount == finished) {
            throw std::out_of_range(&quot;Random generator exceeded generation limit&quot;);
        }
        return val;
    }

    UniformIntGenerator&amp; operator++() {
        if (curCount + 1 &lt; maxCount) {
            val = random(generator);
            ++curCount;
        } else {
            curCount = finished;
        }
        return *this;
    }

    UniformIntGenerator operator++(int) {
        const auto cpy = *this;
        ++(*this);
        return cpy;
    }

    bool operator==(const UniformIntGenerator&amp; other) const {
        return curCount == other.curCount;
    }

    bool operator!=(const UniformIntGenerator &amp;other) const {
        return !(*this == other);
    }
};

INSTANTIATE_TEST_CASE_P(RingBufferTests, ParameterizedRBFixture,
    testing::ValuesIn(UniformIntGenerator(100, -30, 30), UniformIntGenerator()));
// Use a begin and end iterator


</code></pre>
<p>Now instead of each single test looping over a list of values, we can make the entire test fixture take an argument and pass a series of parameters to the test fixture. 
I'd also like to mention that instead of specifying values, <code>testing::Range(start, end, [optional increment])</code> can be used instead of <code>testing::Values()</code> or <code>testing::ValuesIn()</code> to get a sequence of values 
starting at <code>start</code>, ending at <code>end</code>, and incrementing by 1 or <code>increment</code> each step.</p>
<p>If all you want to do is simply repeat tests, you can use the <code>--gtest_repeat</code> command-line parameter to simply call the tests over again.</p>
<h2 id="typed-tests"><a class="header" href="#typed-tests">Typed Tests</a></h2>
<p>Typed tests are quite similar, except they allow you to make a test fixture a template and specify the template arguments to repeat all tests with. 
A difference with typed tests however, is that we must define the test suite as typed using the macro <code>TYPED_TEST_SUITE</code> along with indicating that a test should be typed with the <code>TYPED_TEST</code> macro.</p>
<pre><code class="language-C++">template&lt;typename T&gt;
class RBFix : public testing::Test {
protected:
    const int size = 10;
    Ringbuffer&lt;T&gt; rb{size};
};

using RBTestTypes = testing::Types&lt;char, int, void*, long long&gt;; // type alias is needed here
TYPED_TEST_SUITE(RBFix, RBTestTypes); // takes test fixture and types to instantiate it on

TYPED_TEST(RBFix, emptyTest) {
    ASSERT_TRUE(rb.empty());
}

// all tests will repeat for each type

</code></pre>
<p>Accessing protected members of a test fixture in a typed test case requires the usage of the <code>this</code> pointer. This is because each test case becomes a unique class that inherits the test fixture. 
Since this test fixture is a template, and C++ requires an explicit <code>this</code> pointer to refer to members of a base template class, we must use an explicit <code>this</code> pointer in the test cases.</p>
<p>We also can have typed parameterized tests by making the fixture a template and inheriting from <code>testing::TestWithParams&lt;&gt;</code>. 
Each test case would then use the <code>TYPED_TEST_P</code> macro. These types of tests would need to be registered and instantiated with macros.</p>
<h2 id="matchers"><a class="header" href="#matchers">Matchers</a></h2>
<p>GTest provides the generalized assertion <code>ASSERT_THAT</code> and <code>EXPECT_THAT</code>. The first argument is an object, and the second object is a matcher. 
Matchers are objects which ensure that a certain condition is met. There are matchers for containers, strings, numbers, etc. 
Matchers are part of GMock, and must be included with <code>&lt;gmock/gmock.h&gt;</code>. To link gmock, add <code>PRIVATE GTest::gmock</code> to the <code>target_link_libraries</code> call in CMake.</p>
<p>Matchers can also be composed into larger ones using <code>testing::AllOf()</code>, <code>testing::AnyOf()</code>, <code>testing::Not()</code> and <code>testing::Conditional(cond, m1, m2)</code>. 
The conditional uses <code>m1</code> if the condition is true, otherwise <code>m2</code>. Here are some examples, although I suggest taking a look at the documentation <a href="https://google.github.io/googletest/reference/matchers.html">here</a>.</p>
<pre><code class="language-C++">using namespace testing;
ASSERT_THAT(num, AllOf(Gt(10), Lt(40))); // 10 &lt; num &lt; 40

ASSERT_THAT(str, StartsWith(&quot;Hello&quot;)); 
ASSERT_THAT(str, MatchesRegex(&quot;Id: [0-9]+&quot;));
ASSERT_THAT(str, StrCaseEq(&quot;hElLo&quot;)); // equals ignore case
ASSERT_THAT(str, ContainsRegex(&quot;^Name&quot;)); // whole string does not have to match
ASSERT_THAT(str, AnyOf(EndsWith(&quot;goodbye&quot;), HasSubstr(&quot;hello&quot;))); 
// str.find(&quot;hello&quot;) != std::string::npos || str.find(&quot;goodbye&quot;) == str.size() - strlen(&quot;goodbye&quot;)

ASSERT_THAT(vec, Contains(100));
ASSERT_THAT(vec, ContainerEq(vec2)); // same as ASSERT_EQ but provides more informative error message

ASSERT_THAT(vec, ElementsAre(e0, e1, e2));
ASSERT_THAT(vec, WhenSorted(ElementsAre(e0, e1, e2))); 
// sorts the container first using operator&lt;, then applies the matcher (in this case ElementsAre)
// in this case we sort the vector, then check elements

ASSERT_THAT(vec, WhenSortedBy([](auto a, auto b) { return a &gt; b}, ElementsAreArray(vec2)));
// sorts by a comparator, then applies matcher
// in this case when check that the elements are the same as another container
// (can be an array, container, or begin and end iterators)

ASSERT_THAT(vec, UnorderedElementsAre(e0, e1, e2));
ASSERT_THAT(vec, UnorderedElementsAreArray(list.begin(), list.end()));
ASSERT_THAT(vec, UnorderedElementsAreArray(list));

ASSERT_THAT(vec, IsSubsetOf(vec3));
ASSERT_THAT(vec, IsSuperSetOf(e0, e2, e5));
// both IsSubset and IsSuperSet can take a container, comma separated elements, begin and end iterators, 
// or a begin iterator and size
// in both of these matchers, order doesn't matter

ASSERT_THAT(tuple, FieldsAre(42, &quot;hi&quot;));

struct S {
    int age;

    bool canRide() const {
        return age &gt;= 13;
    }
}

ASSERT_THAT(object, Field(&amp;S::age, Le(18))); // s.age &lt;= 18
// ensures that an object has a given member
// and that member satisfies a matcher

ASSERT_THAT(object, Property(&amp;S::canRide, 
    Conditional(object.age &gt;= 13, Eq(true), Eq(false))));
// ensures that an object has the given no parameter const member function which, 
// when called, returns a value that matches the given matcher

ASSERT_THAT(ptrToVec, Pointee(SizeIs(Gt(10))));
// matches what the pointer points to with the given matcher
// ptrToVec-&gt;size() &gt; 10
</code></pre>
<p>You might also find matchers useful as predicates for STL functions. This can be done using the <code>Matches()</code> function:</p>
<pre><code class="language-C++">std::vector v = {10, 20, 30, 450};
auto it = std::find(v.begin(), v.end(), Matches(AllOf(Gt(10), Lt(100))));
</code></pre>
<p>Likewise, you might find that you want to use a predicate as a matcher. This can be done by wrapping the predicate inside the <code>Truly()</code> function.</p>
<pre><code class="language-C++">const auto isOdd = [](int a) { return a % 2; };
// predicate just needs to return something implicitly convertible to bool

ASSERT_THAT(num, Not(Truly(isOdd)));
// assert num is even
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmock"><a class="header" href="#gmock">Gmock</a></h1>
<p>GMock provides the ability to mock implementations. For example let's say that you are testing some logic which performs some operation on data received fromm a database. 
To keep tests fast, and the logic verifiable, it's probably useful to have a mock database which you can control. 
What we can do is create a database <em>gateway</em>: an interface that abstracts away the concrete database implementation. 
Then we can have a concrete production class, and a second concrete mock class acts like a real database. 
Gmock makes developing such a class much easier by providing macros to generate method implementations and assert passed parameters and calling conditions 
(ex. how many times the function is called, when it's called, etc.).</p>
<p>The googletest github repo contains both gtest and gmock. So the only thing we need to do to use gmock is add gmock to the <code>target_link_libraries</code> call for our test in CMake.</p>
<pre><code>target_link_libraries(Test PRIVATE GTest::gtest_main PRIVATE GTest::gmock)
</code></pre>
<p>Then in our test file we can include <code>&lt;gmock/gmock.h&gt;</code>.</p>
<p>We can mock methods of a class (we cannot mock free functions) with the <code>MOCK_METHOD</code> macro which takes the method return type, name, arguments surrounded by parentheses, 
and optionally and qualifiers surrounded by parentheses such as <code>const</code>, <code>noexcept</code>, and <code>override</code>. 
Ref qualifiers and calling convention can also be specified in this parameter by surrounding the qualifier in <code>ref()</code> and <code>Calltype()</code>, respectively. Mock methods must always be public.</p>
<pre><code class="language-C++">class MyMock {
public:
    MOCK_METHOD(std::string, getName, (), (const));
    // std::string getName() const;

    MOCK_METHOD(int, mult, (int, int), (const, noexcept));
    // int mult(int, int) const;

    MOCK_METHOD(void, setAge, (int));
    // void setAge(int);
};
</code></pre>
<p>In a test, we can use the <code>EXPECT_CALL</code> macro to assert that a method gets called, use <em>matchers</em> to assert conditions about the passed arguments, and use <em>actions</em> and <em>cardinalities</em> to 
control the behavior of the mocked method. The first argument to <code>EXPECT_CALL</code> is an instance of a mock class, the second argument is the name of the method that should be called and matchers surrounded by parentheses. 
The nth matcher in the parentheses applies to the nth argument of the method call.</p>
<p>We discussed matchers in the last chapter, but one matcher we haven't discussed is <code>testing::_</code> which is a matcher that matches anything.</p>
<pre><code class="language-C++">using namespace testing;
TEST(MockTest, sqrtCalled) {
    MyMock mock;
    EXPECT_CALL(mock, mult(_, AnyOf(Eq(10), Gt(100))));
    // _ indicates the first argument can be anything
    

    mock.mult(2, 300); // passes because the second argument is &gt; 100
}
</code></pre>
<h2 id="actions"><a class="header" href="#actions">Actions</a></h2>
<p>This is great to check that a function is called, but let's make the mock method do something. 
We can specify an action to <code>WillOnce</code> or <code>WillRepeatedly</code> by chaining these function calls after the <code>EXPECT_CALL</code> macro.</p>
<pre><code class="language-C++">EXPECT_CALL(mock, mult(_, AnyOf(Eq(10), Gt(100))))
    .WillOnce(/* action 1*/)
    .WillOnce(/* action 2*/)
    .WillOnce(/* action 3*/)
    .WillRepeatedly(/* action 4 */);
// let n be the number of times mock.mult is called
// if n &lt;= 3, do action_n
// else do action_4
</code></pre>
<ul>
<li><code>Return([optional value])</code> - returns from a void function or returns the passed value</li>
<li><code>ReturnArg&lt;N&gt;()</code> - returns the nth argument to the function (0 based)</li>
<li><code>ReturnRoundRobin(vectorOrInitializerList)</code> - circles through elements in the container, returning each one and moving to the next</li>
<li><code>ReturnRef(variable)</code> - returns reference to <code>variable</code></li>
<li><code>Throw(exn)</code> - throws <code>exn</code></li>
<li><code>Assign(&amp;variable, value)</code> - assigns <code>value</code> to <code>variable</code>. Expects a pointer as the first argument</li>
<li><code>SaveArg&lt;N&gt;(pointer)</code> - saves the nth argument to the value pointed to by <code>pointer</code>.</li>
<li><code>DeleteArg&lt;N&gt;()</code> - deletes the nth argument, which should be a pointer</li>
<li><code>SetArgReferee&lt;N&gt;(value)</code> - assigns the nth argument to <code>value</code>. The arg should be a reference</li>
<li><code>Invoke(f)</code> - calls the callable object <code>f</code> with the parameters passed to the function
<ul>
<li><code>Invoke(objectPointer, member function pointer)</code></li>
</ul>
</li>
<li><code>InvokeWithoutArgs(f)</code> - invokes a function taking no arguments</li>
<li><code>InvokeArgument&lt;N&gt;(args...)</code> - invokes the nth argument as a callable object passing in <code>args...</code></li>
</ul>
<p>We can also compose actions as well:</p>
<ul>
<li><code>DoAll(actions...)</code> - self-explanatory</li>
<li><code>IgnoreResult(action)</code> - ignore the result of an action</li>
<li><code>WithArg&lt;N&gt;(action)</code> - executions <code>action</code> with the nth argument passed
<ul>
<li><code>WithArgs&lt;N0, N1, N...&gt;(action)</code></li>
</ul>
</li>
</ul>
<p>More information is available <a href="https://google.github.io/googletest/reference/actions.html">here</a>.</p>
<p>So let's mock our class:</p>
<pre><code class="language-C++">TEST(MockTest, testActions) {
    MyMock mock;
    EXPECT_CALL(mock, mult(_, AnyOf(Eq(10), Gt(100))))
        .WillRepeatedly(Invoke([](auto a, auto b) { return a * b; }));
        // we don't actually need to wrap the callable object in Invoke()

    const std::initializer_list&lt;std::string&gt; names = { &quot;Molly&quot;, &quot;Andrew&quot;, &quot;Jimmy&quot;, &quot;Julia&quot;, &quot;Kathy&quot;, &quot;Roger&quot; };
    EXPECT_CALL(mock, getName())
        .WillRepeatedly(ReturnRoundRobin&lt;std::string&gt;(names));

    int prevAge = 0;
    EXPECT_CALL(mock, setAge(Gt&lt;int&amp;&gt;(prevAge))) // specify that prevAge is passed by reference, could also pass std::ref(prevAge)
        .WillRepeatedly(SaveArg&lt;0&gt;(&amp;prevAge));


    ASSERT_EQ(mock.mult(2, 300), 2 * 300); 
    mock.setAge(1);
    mock.setAge(2);
    mock.setAge(4);
    mock.setAge(10);
    //  mock.setAge(8); // error, 8 is &lt; prevAge
    ASSERT_THAT(std::vector&lt;std::string&gt; { mock.getName() }, IsSubsetOf(names));
}
</code></pre>
<h2 id="cardinalities-and-sequences"><a class="header" href="#cardinalities-and-sequences">Cardinalities and Sequences</a></h2>
<p>Without <code>WillOnce</code> or <code>WillRepeatedly</code>, the test will fail if the called function is called more than once. 
This is because, by default, the expectation has a cardinality (amount of times the function can be executed) of <code>1</code>. 
We can change this behavior by the <code>Times()</code> member function and passing it a cardinality such as:</p>
<ul>
<li><code>AnyNumber()</code></li>
<li><code>AtLeast(n)</code></li>
<li><code>AtMost(n)</code></li>
<li><code>Between(n, m)</code></li>
<li><code>Exactly(n)</code> or just a number <code>n</code> directly</li>
</ul>
<p>By default, each usage of <code>WillOnce</code> increments the expected call count by <code>1</code> (starting from <code>0</code>), and the presence of <code>WillRepeatedly</code> allows the function to be called any number of times.</p>
<pre><code class="language-C++">TEST(MockTest, testCardinalities) {
    MyMock mock;
    EXPECT_CALL(mock, mult(_, _))
        .Times(2);

    EXPECT_CALL(mock, getName())
        .Times(Between(1, 10));

     mock.getName();

    mock.mult(1, 1);
    mock.mult(0, 0);

   
}
</code></pre>
<p>If you want to enforce that calls occur in a certain order (say that <code>mult</code> must be called before <code>getName</code>), 
we can use an <code>InSequence</code> RAII object to enforce that functions are called in the order the <code>EXPECT_CALLS</code> are called. 
All invocations of the gmock macros that occur while an <code>InSequence</code> object is alive synchronizes the order of these expectations.</p>
<pre><code class="language-C++">TEST(MockTest, testCardinalities) {
    MyMock mock;
    {
        InSequence seq;

        EXPECT_CALL(mock, mult(_, _))
            .Times(2);

        EXPECT_CALL(mock, getName())
            .Times(Between(1, 10));
    }

    EXPECT_CALL(mock, setAge(_))
        .Times(AnyNumber());

    mock.setAge(10); 
    // set age not synchronized in block with InSequence object
    // can occur in any order
  
    mock.mult(1, 1);
    mock.mult(0, 0);
    // enforces that calls to mult must occur before calls
    // to getName

    mock.setAge(20);

    mock.getName();
 
}
</code></pre>
<p>For more flexible sequences, gmock provides the <code>InSequence()</code> and <code>After()</code> functions. 
This works by constructing a DAG and enforcing the functions are called in topological order. 
We can use the <code>InSequence()</code> function and pass in <code>InSequence</code> objects to make that mock part of the specified sequences. Mocks in the same sequence must be called in the order they are defined. </p>
<pre><code class="language-C++">using ::testing::Sequence;
...
    Sequence s1, s2;

    EXPECT_CALL(foo, A()) 
        .InSequence(s1, s2);
    // foo(A()) is in sequence s1 and s2
    EXPECT_CALL(bar, B()) 
        .InSequence(s1);
    // bar(B()) in sequence s1, must occur after foo(A())
    EXPECT_CALL(bar, C())
        .InSequence(s2);
    // bar(C()) in sequence s2, must occur after foo(A())
    EXPECT_CALL(foo, D())
        .InSequence(s2);
    // foo(D()) in sequence s2, must occur after foo(D())
</code></pre>
<p>This creates the following DAG:</p>
<pre><code>       +---&gt; B
       |
  A ---|
       |
        +---&gt; C ---&gt; D
</code></pre>
<p>Above example taken from <a href="https://github.com/google/googletest/blob/master/docs/gmock_cook_book.md">gmock reference</a></p>
<p>If you don't want to set any expectations about a function being called, you can use the <code>ON_CALL</code> macro instead of <code>EXPECT_CALL</code>. 
It works exactly the same expect <code>ON_CALL</code> simply defines the action a function takes without adding test expectations. 
<code>ON_CALL</code> should be preferred whenever you don't want to enforce call expectations (such as the number of times a function is called).</p>
<h2 id="misc"><a class="header" href="#misc">Misc</a></h2>
<p>We can use <code>ON_CALL</code> and <code>WillByDefault</code> to specify different actions for when different parameters to a function are used.</p>
<pre><code class="language-C++">using ::testing::_;
using ::testing::AnyNumber;
using ::testing::Gt;
using ::testing::Return;
...
  ON_CALL(foo, Sign(_))
      .WillByDefault(Return(-1));
  ON_CALL(foo, Sign(0))
      .WillByDefault(Return(0));
  ON_CALL(foo, Sign(Gt(0)))
      .WillByDefault(Return(1));

  EXPECT_CALL(foo, Sign(_))
      .Times(AnyNumber());

  foo.Sign(5);   // This should return 1.
  foo.Sign(-9);  // This should return -1.
  foo.Sign(0);   // This should return 0.
</code></pre>
<p>Google test provides a <a href="https://github.com/google/googletest/blob/master/docs/gmock_cheat_sheet.md">gmock cheat sheet</a>, <a href="https://github.com/google/googletest/blob/master/docs/gmock_cook_book.md">gmock cookbook</a>, and <a href="https://google.github.io/googletest/reference/mocking.html">gmock reference</a> along with other documentation. There's also the <a href="https://github.com/google/googletest/blob/master/docs/primer.md">gtest primer</a>, <a href="https://google.github.io/googletest/reference/testing.html">testing reference</a> and <a href="https://github.com/google/googletest/blob/master/docs/advanced.md">gtest advanced reference</a>.</p>
<h2 id="easy-on-the-mocking"><a class="header" href="#easy-on-the-mocking">Easy on the Mocking</a></h2>
<p>The key goal of mocking is to keep tests independent and fast. 
When unit testing, you don't need to mock every single other class or module that the UUT (unit under test) depends on. 
In fact, most dependencies probably don't require mocks. An example of a good mock is mocking a filesystem. 
Changes to the filesystem made by one test might affect the behavior of another test. 
The order that tests are run in must not matter (the order is indeterminate in gtest, but this is a good engineering practice). 
Likewise, the filesystem is much slower than memory, so using a mock could sufficiently improve run time for tests. 
Another good example is that during development of module A, you might find (or already know) that some behavior module A depends on could be factored out into a separate, public, module B. 
Mocking can allow you to test module A without an implementation of module B's interface.</p>
<p>As I mention before, <code>ON_CALL</code> should be preferred to <code>EXPECT_CALL</code>. 
This is because <code>EXPECT_CALL</code> adds constraints to how the function is called, which may be an implementation detail. 
Does the spec on the interface for <code>addProductToCart()</code> say that <code>doFoo()</code> is called 3 times after <code>makeFoo()</code> is called? If not, <code>ON_CALL</code> is probably a better choice than <code>EXPECT_CALL</code>. 
The death of testing is when the test suite makes it difficult to refactor or alter the production code in any way. Overly mocking can cause this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdb"><a class="header" href="#gdb">GDB</a></h1>
<p>GDB is the GNU Debugger for Linux. It allows us to use a command line interface to investigate the stack trace, set breakpoints, step through execution, and more. 
On Windows, Visual Studio comes with a debugger that is pretty self-explanatory to use.</p>
<p>In order to start debugging a program, we'll need to compile our program so that it includes the debugging symbol tables. 
To do this, we need to add the &quot;-g&quot; flag to the command line arguments of g++. In CMake, there are a few ways to do this. 
The first is to set the build type to <code>Debug</code> or <code>RelWithDebugInfo</code>. The latter produces an optimized release build except it also contains debug symbols. 
The former produces a debug build. Another option is to set C++ compiler flags. We'll discuss CMake more later.</p>
<pre><code class="language-CMake">set(CMAKE_BUILD_TYPE Debug) # Sets the build type to debug

set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -g&quot;) 
# adds the -g flag to the c++ compiler options
# applies to all build targets

add_compile_options(-g)
# adds the -g to all targets in the current directory
# and all subdirectories

target_compile_options(TargetName PRIVATE &quot;-g&quot;)
# sets the -g flag to the specific target
</code></pre>
<p>We can also do this via the CMake command line by adding the flag <code>-DCMAKE_BUILD_TYPE=Debug</code>.</p>
<p>Now our compiled binary can be run with the debugger. With <code>gdb</code> installed, run the command <code>gdb &lt;path to exe&gt;</code> to start debugging. You'll enter an interactive CLI that accepts commands.</p>
<p>Without doing anything else but running the program, the debugger will break execution whenever the program crashes or an exception is thrown out of the program. To run the program use the <code>r</code> or <code>run</code> command specify any command line arguments the program may need.</p>
<p>A backtrace can be displayed with <code>backtrace</code> or <code>bt</code>, and <code>q</code> quits gdb.</p>
<p>It may be helpful to log output to a file. To enable logging use <code>set logging on</code>. 
You can change the output file with <code>set logging file &lt;file&gt;</code>. 
By default, output is displayed to terminal as well as being logged. 
You can change this by turning on redirect, which, when enabled, only outputs to the log file. This can be turned on with <code>set logging redirect [on/off]</code>. 
Disable logging with <code>set logging off</code>. Everything printed to the terminal, will be saved in the log file.</p>
<p>Here are a list of some commands:</p>
<ul>
<li>
<p><code>b</code>/<code>break</code> <code>(&lt;class&gt;::&lt;member function&gt; | &lt;line number&gt; | &lt;file&gt;:&lt;line number&gt; | &lt;function name&gt; | +&lt;relative line num&gt;) [if &lt;expr&gt;]</code></p>
<ul>
<li><code>b 45</code> - breakpoint at line 45 of main file</li>
<li><code>b MyClass::doFoo</code> - breakpoint at start of <code>doFoo()</code> of class <code>MyClass</code></li>
<li><code>break main</code> - breakpoint at start of <code>main()</code></li>
<li><code>b +10</code> - breakpoint 10 lines down from current position</li>
<li><code>b source.cpp:23 if x == 2</code> - breaks line 23 in source.cpp if a variable x is 2</li>
</ul>
</li>
<li>
<p><code>info breakpoints</code> - get a list of breakpoints. Each one has a numeric id</p>
</li>
<li>
<p><code>delete &lt;breakpoint number&gt;</code></p>
</li>
<li>
<p><code>ignore &lt;breakpoint number&gt;</code></p>
</li>
<li>
<p><code>skip &lt;breakpoint number&gt;</code></p>
</li>
<li>
<p><code>step</code>/<code>s</code> <code>[lines]</code> - continue to next line of source code. Optional param amount of lines </p>
</li>
<li>
<p><code>next</code>/<code>n</code> <code>[lines]</code> - same as <code>step</code> but does not trace through (step into) functions</p>
</li>
<li>
<p><code>stepi</code>/<code>si</code> <code>[instructions]</code> - goes to next <em>machine instruction</em>. Option param amount of instructions. Similar to <code>step</code></p>
</li>
<li>
<p><code>nexti</code>/<code>ni</code> <code>[instructions]</code> - same as <code>next</code> but with machine instructions.</p>
</li>
<li>
<p><code>continue</code>/<code>c</code> - continues to next breakpoint or error</p>
</li>
<li>
<p><code>watch &lt;expr&gt;</code> - breaks when the value of <code>expr</code> changes</p>
<ul>
<li><code>watch str</code> - breaks every time the value of the variable <code>str</code> changes</li>
<li><code>watch str.size() &gt; 10</code></li>
</ul>
</li>
<li>
<p><code>condition &lt;breakpoint number&gt; &lt;expr&gt;</code> - makes the specified breakpoint conditional. The breakpoint will now only break when <code>expr</code> is true</p>
</li>
<li>
<p><code>info frame</code> - prints information about the current stack frame</p>
</li>
<li>
<p><code>u</code> - goes up one frame</p>
</li>
<li>
<p><code>d</code> - goes down one frame</p>
</li>
<li>
<p><code>frame &lt;n&gt;</code> - navigates to the nth frame. n = 1 is the parent frame with larger n going higher and higher up.</p>
</li>
<li>
<p><code>info locals</code> - prints values of local variables</p>
</li>
<li>
<p><code>info args</code> - displays information of arguments to current function</p>
</li>
<li>
<p><code>print</code>/<code>p</code> <code>[/&lt;format&gt;] &lt;variable&gt;</code> - displays the specified variable. <code>format</code> is an optional parameter to control the type the variable is displayed as. </p>
<ul>
<li><code>p /s name</code> - displays the variable <code>name</code> as a C string.</li>
<li><code>print x</code> - displays <code>x</code></li>
</ul>
</li>
<li>
<p><code>set &lt;variable&gt; = &lt;value&gt;</code> - sets a variable</p>
</li>
<li>
<p><code>call &lt;function&gt;</code> - executes the function</p>
<ul>
<li><code>call strlen(myStr)</code> - returns length of C string variable named <code>myStr</code></li>
<li><code>call malloc_stats()</code>, <code>call mallinfo()</code>, <code>call malloc_info(0, stdout)</code> - displays allocation and memory usage info to console</li>
</ul>
</li>
<li>
<p><code>display [/&lt;format&gt;] &lt;variable&gt;</code> - displays the value of <code>variable</code> after every step or pause. Optional format code to control how <code>variable</code> is displayed.</p>
<ul>
<li><code>undisplay &lt;variable&gt;</code></li>
</ul>
</li>
<li>
<p><code>x /&lt;count&gt;&lt;format&gt;&lt;unit&gt; &lt;address&gt;</code> - displays <code>count</code> amount of <code>unit</code> starting from <code>address</code> in the given format</p>
<ul>
<li>Units include:
<ul>
<li><code>b</code> - byte</li>
<li><code>h</code> - half word (2 bytes)</li>
<li><code>w</code> - word (4 bytes)</li>
<li><code>g</code> - &quot;giant&quot; or double word (8 bytes)</li>
</ul>
</li>
<li><code>x/12xb &lt;addr&gt;</code> - display 12 bytes in hex at <code>addr</code></li>
</ul>
</li>
</ul>
<p>The formats for commands like <code>print</code> and <code>x</code> include the following:</p>
<ul>
<li><code>s</code> - treat as C string</li>
<li><code>c</code> - print integer as char</li>
<li><code>d</code> - signed decimal integer</li>
<li><code>f</code> - floating point</li>
<li><code>o</code> - integer, print in octal</li>
<li><code>t</code> - integer, display in binary</li>
<li><code>u</code> - unsigned integer</li>
<li><code>x</code> - integer, display in hex</li>
</ul>
<p>More information can pretty easily be found online. Also check out the <a href="https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf">GDB cheat sheet</a>.</p>
<h1 id="gprof"><a class="header" href="#gprof">GProf</a></h1>
<p>GProf is the GNU profiler. To use the profiler we must compile <strong>and link</strong> with the &quot;-pg&quot; compiler flag. See above for how to do that in CMake. 
In CMake, setting link flags are very much like setting compile flags, for example:</p>
<pre><code>target_link_options(TargetName PRIVATE &quot;-pg&quot;)
</code></pre>
<p>From there we can simply run the program like normal. When execution is finished, a file called <code>gmon.out</code> will be generated in the build directory. 
Next, we can simply run the <code>gprof</code> tool on this executable which will display a lot of information. So you probably want to redirect the output to a log file.</p>
<pre><code>gprof [&lt;options&gt;] &lt;path to exe&gt; gmon.out [&gt; &lt;log file name&gt;]
</code></pre>
<p>Two important things to look out in the output is the <em>flat profile</em> and <em>call graph</em>. The flat profile provides a list of functions organized by time spent in each and looks something like this:</p>
<pre><code>Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 33.34      0.02     0.02     7208     0.00     0.00  open
 16.67      0.03     0.01      244     0.04     0.12  offtime
 16.67      0.04     0.01        8     1.25     1.25  memccpy
 16.67      0.05     0.01        7     1.43     1.43  write
 16.67      0.06     0.01                             mcount
  0.00      0.06     0.00      236     0.00     0.00  tzset
  0.00      0.06     0.00      192     0.00     0.00  tolower
  0.00      0.06     0.00       47     0.00     0.00  strlen
  0.00      0.06     0.00       45     0.00     0.00  strchr
  0.00      0.06     0.00        1     0.00    50.00  main
  0.00      0.06     0.00        1     0.00     0.00  memcpy
  0.00      0.06     0.00        1     0.00    10.11  print
  0.00      0.06     0.00        1     0.00     0.00  profil
  0.00      0.06     0.00        1     0.00    50.00  report
</code></pre>
<p><a href="https://ftp.gnu.org/old-gnu/Manuals/gprof-2.9.1/html_chapter/gprof_5.html#SEC11">Source</a></p>
<p>The cumulative seconds is the time spent in the current function and all functions above that once in the table. Self seconds is the time spent only in that function. 
Gprof works by taking samples at fixed intervals. The sampling interval is displayed before the flat profile. In this case samples are every <code>0.01</code> seconds. 
Functions that are not called, are not compiled, or take an insignificant amount of time may not appear in the profile. The function <code>mcount</code> is used internally to perform this timing analysis.</p>
<p>Next is the call graph which shows how much time was spent in a function and its children. The graph is divided into entries separated by horizontal bars and looks something like this:</p>
<pre><code>granularity: each sample hit covers 2 byte(s) for 20.00% of 0.05 seconds

index % time    self  children    called     name
                                                 &lt;spontaneous&gt;
[1]    100.0    0.00    0.05                 start [1]
                0.00    0.05       1/1           main [2]
                0.00    0.00       1/2           on_exit [28]
                0.00    0.00       1/1           exit [59]
-----------------------------------------------
                0.00    0.05       1/1           start [1]
[2]    100.0    0.00    0.05       1         main [2]
                0.00    0.05       1/1           report [3]
-----------------------------------------------
                0.00    0.05       1/1           main [2]
[3]    100.0    0.00    0.05       1         report [3]
                0.00    0.03       8/8           timelocal [6]
                0.00    0.01       1/1           print [9]
                0.00    0.01       9/9           fgets [12]
                0.00    0.00      12/34          strncmp &lt;cycle 1&gt; [40]
                0.00    0.00       8/8           lookup [20]
                0.00    0.00       1/1           fopen [21]
                0.00    0.00       8/8           chewtime [24]
                0.00    0.00       8/16          skipspace [44]
-----------------------------------------------
[4]     59.8    0.01        0.02       8+472     &lt;cycle 2 as a whole&gt;	[4]
                0.01        0.02     244+260         offtime &lt;cycle 2&gt; [7]
                0.00        0.00     236+1           tzset &lt;cycle 2&gt; [26]
-----------------------------------------------
</code></pre>
<p>The primary line is the line for the function that the entry is analyzing. 
This line has the name of the function not on an indent. The direct caller of the function being analyzed is also included in the same entry.</p>
<p>To display the call graph more nicely, we can use the python script <code>gprof2dot</code>. This can be installed via <code>pip</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valgrind"><a class="header" href="#valgrind">Valgrind</a></h1>
<p>Valgrind is a suite of profiling and performance tools that's more recent and more powerful than gprof. Besides
being able to effectively profile multithreaded code, valgrind also has tools for finding memory leaks and unitialized 
data, inconsistant lock ordering and other threading issues, and much more.</p>
<p>I'll show a few examples, but I'll refer you to the <a href="https://valgrind.org/docs/manual/manual.html">Valgrind User Manual</a> for more
information. The manual is pretty clear, and I haven't really used this enough to discuss much in detail.</p>
<p>To use it, we first have to compile whatever program we want to analyze with debugging symbols. 
Technically,  you don't <em>need</em> debugging symbols, but this just makes the output comprehensible.
For GCC, this would be compiling with the <code>-g</code> flag.
Unlike gprof, we don't need any specific compilation option or linking option.
Next, we can simply run the program by passing it to an argument of Valgrind.</p>
<p>The general command structure looks like this:</p>
<pre><code>valgrind --tool=&lt;tool-name&gt; [--&lt;tool flags&gt;] &lt;program name&gt; [program args]
</code></pre>
<p>When running a program with valgrind, you can expect the program to be <strong>significantly</strong> slower. Valgrind gives an estimate of <code>20x</code> to <code>30x</code> slower, but I wouldn't sweat it if it takes longer. Some tools are faster or slower than others.
It's also important to remember that Valgrind (or any analysis tool for that matter) cannot be perfect.
(Halting Problem, Rice's Theorem, bugs in Valgrind itself, etc.)</p>
<p>Valgrind will run our program with some extra information displayed on the console depending on the tool used.
For each line Valgrind displays, you will notice a <code>==&lt;number&gt;==</code> at the start of each line.
This number is the process id.</p>
<p>It may be helpful to save logs to a file, which can be done using the <code>--log-file=&lt;filename&gt;</code> flag. By default,
Valgrind logs its information to <code>stderr</code>, so the redirect both <code>stdout</code> and <code>stderr</code> to a file you can use the following:</p>
<pre><code>&lt;command&gt; &gt; allout.txt 2&gt;&amp;1
</code></pre>
<h3 id="memcheck"><a class="header" href="#memcheck">Memcheck</a></h3>
<p>Memcheck is the default tool for Valgrind, to when running memcheck you don't need the <code>--tool</code> flag.
Memcheak looks for invalid memory usage (reading/writing to invalid data, memory leaks, usage of unitialized data etc.)</p>
<p>If we run the program using the following command:</p>
<pre><code>valgrind --leak-check=full &lt;program&gt;
</code></pre>
<p>When Memcheck is finished, it will summarize any memory leaks it has found. The term &quot;lost&quot;
essentially means that memory is leaked. More specificly &quot;indirectly lost&quot; means that memory
is lost as a result of another memory leak (such as children nodes of a tree), &quot;still reachable&quot;
characterizes memory that is still accessible by globals or static variables when the program
exits. &quot;Possibly lost&quot; should be treated as a &quot;definetely lost&quot; is most cases. The distinction
is made because Valgrind can't tell if it's a memory leak or if you are doing something
clever with pointers (in most cases).</p>
<p>The <code>--leak-check=full</code> parameter will tell Valgrind to display detailed information for any memory
leaks it finds instead of just summarizing how many it finds.</p>
<p>The output of Memcheck is pretty self explanatory, and when using <code>--leak-check=full</code>, will display a stack trace for where
the memory leak occurs. By default, Memcheck can only tell us if uninitialized memory is used,
and not the cause of it. The argument <code>--track-origins=yes</code> enables tracing unitialized memory, but may slow down the runtime.</p>
<h3 id="callgrind"><a class="header" href="#callgrind">Callgrind</a></h3>
<p>Callgrind is a callgraph-based profiling tool. We can run it like so </p>
<pre><code>valgrind --tool=callgrind &lt;program&gt;
</code></pre>
<p>Callgrind will log its output to a file named <code>callgrind.out.&lt;pid&gt;</code> unless this is changed using the <code>--out-file</code> flag.</p>
<p>To view this data, you can use <code>kcachegrind</code> (<code>qcachegrind</code> on Windows) to display the callgraph and flat profile in a graphical format.
These tools provide you with GUIs that make looking at the data pretty easy. They do however only show the top 50 functions in a call graph.
If you need to see everything, <code>gprof2dot</code> works for the Callgrind output as well.</p>
<h3 id="helgrind-and-drd"><a class="header" href="#helgrind-and-drd">Helgrind and DRD</a></h3>
<p>Helgrind and DRD are both tools for thread error detection. They may detect different types of issues, so it may be worth it to use
both of these. The errors these tools detect are misuse of the <code>pthreads</code> API, data races, and potential deadlock. For us C++ programmers, we don't have to worry too about the first class of errors too much since most of <code>pthreads</code> will be abstracted from us by
the standard library or boost.</p>
<p>Similar to callgrind, you can use these with the flags <code>--tool=helgrind</code> and <code>--tool=drd</code>. Both of these tools work on implementations
that use <code>pthreads</code>.</p>
<p>Now it should be noted that Helgrind can generate a lot of false positives. This mostly resolves around the fact that Helgrind
doesn't seem to play nice non-pthread synchronization primitives such as atomics, or pthread condition variables. So if you use this, I might suggest to focus more on any issues it finds with locking order.</p>
<p>DRD seems to be slower than Helgrind, but supports more synchronization primitives.</p>
<p>Let's look at some example output from these tools. This one is a nice example from the <a href="https://valgrind.org/docs/manual/drd-manual.html">Valgrind DRD User Manual</a></p>
<pre><code>...
==9466== Thread 3:
==9466== Conflicting load by thread 3 at 0x006020b8 size 4
==9466==    at 0x400B6C: thread_func (rwlock_race.c:29)
==9466==    by 0x4C291DF: vg_thread_wrapper (drd_pthread_intercepts.c:186)
==9466==    by 0x4E3403F: start_thread (in /lib64/libpthread-2.8.so)
==9466==    by 0x53250CC: clone (in /lib64/libc-2.8.so)
==9466== Location 0x6020b8 is 0 bytes inside local var &quot;s_racy&quot;
==9466== declared at rwlock_race.c:18, in frame #0 of thread 3
==9466== Other segment start (thread 2)
==9466==    at 0x4C2847D: pthread_rwlock_rdlock* (drd_pthread_intercepts.c:813)
==9466==    by 0x400B6B: thread_func (rwlock_race.c:28)
==9466==    by 0x4C291DF: vg_thread_wrapper (drd_pthread_intercepts.c:186)
==9466==    by 0x4E3403F: start_thread (in /lib64/libpthread-2.8.so)
==9466==    by 0x53250CC: clone (in /lib64/libc-2.8.so)
==9466== Other segment end (thread 2)
==9466==    at 0x4C28B54: pthread_rwlock_unlock* (drd_pthread_intercepts.c:912)
==9466==    by 0x400B84: thread_func (rwlock_race.c:30)
==9466==    by 0x4C291DF: vg_thread_wrapper (drd_pthread_intercepts.c:186)
==9466==    by 0x4E3403F: start_thread (in /lib64/libpthread-2.8.so)
==9466==    by 0x53250CC: clone (in /lib64/libc-2.8.so)
...
</code></pre>
<p>What we're looking at here is the report of a race condition. Race conditions require at least two accesses to the same data,
the first access displayed is shown with a precise stacktrace, the subsequent ones are shown with approximate stack traces
in between &quot;segments&quot;. A segment in this sense is a sequence of reads and writes. </p>
<p>To read the approximate stacktraces, it helps to read the stack from bottom to top, and start searching where the stack traces begin
to differ. In this example, that would point us to <code>thread_func</code> in <code>rwlock_race.c</code> from lines <code>28</code> to <code>30</code>.</p>
<p>DRD numbers each thread; these numbers are, as far as I can tell, somewhat arbitrary and really only useful for differentiating
threads in the report.</p>
<p>A useful flag on DRD is the <code>--exlusive-threshold=&lt;time&gt;</code> and <code>--shared-threshold=&lt;time&gt;</code> arguments. These allow you to set threshold durations,
in milliseconds, for exclusive/unique/writer locks and shared/reader locks, respectively. If a lock is held for longer than these
set thresholds, DRD will display an error telling you where the lock was taken and where it was released.</p>
<h1 id="sanitizers"><a class="header" href="#sanitizers">Sanitizers</a></h1>
<p>Sanitizers work similarly to Valgrind, but often are more efficient due to the face that unlike valgrind, they are not a purely runtime
tool. Depending on the tool, they claim to have a roughly <code>2x</code> slowdown.</p>
<p>These tools come with Clang and GCC, and work by simply adding compilation <strong>and link</strong> flags to your program,
and then running the program normally.</p>
<p>When using the sanitizers, they reccomend using optimization level 1 (flag <code>-O1</code>, that's an &quot;oh&quot; not a 0) which will disable
some optimizations (such as inlining) that can make analysis more difficult.</p>
<p>Some sanitizers (such as Asan (address sanitizer), UBsan (undefined behavior sanitizer), and Lsan (leak sanitizer)) can be run together
while others like Tsan (thread sanitizer) need separate builds.</p>
<h3 id="address-and-memory-sanitizer"><a class="header" href="#address-and-memory-sanitizer">Address and Memory Sanitizer</a></h3>
<p>Address sanitizer is similar to Valgrind's Memcheck. It works by applying the flag <code>-fsantizie=address</code>. For C++,
they reccommend also using the argument <code>-fno-omit-frame-pointer</code>. It may also be helpful to disable
tail call elimination with <code>-fno-optimize-sibling-call</code>.</p>
<p>Asan can also detect problems with initialization order by setting the environmental variable <code>ASAN_OPTIONS</code> to <code>check_initialization_order=1</code>.</p>
<p>Memory sanitizer checks for unitialized reads. Use <code>-fsanitize=memory</code>.</p>
<h3 id="thread-sanitizer"><a class="header" href="#thread-sanitizer">Thread Sanitizer</a></h3>
<p>This is similar to Valgrind's Helgrind and DRD. We enable this one by applying the flag <code>-fsanitize=thread</code>.
Thread Sanitizer checks for data races, and I'd reccomend this one over Valgrind if that's what you're
interested in.</p>
<p>Let's look at an example output:</p>
<pre><code>WARNING: ThreadSanitizer: data race (pid=20495)
  Write of size 1 at 0x7b1000006959 by thread T10:
    #0 cmr::ASCIIMsgManager&lt;...&gt;::addMsgIdentifier(...) /.../msg_manager.h:158 (action_client_test+0x197ccd)
    #1 cmr::MsgManager::addMsgIdentifier(...) /.../msg_manager.h:35 (action_client_test+0x19402b)
    #2 cmr::msgFmt::ASCIIMsgFormatter::addMsgId(...) const /.../msg_formatter.cc:37 (action_client_test+0x19402b)
    #3 cmr::msgFmt::ASCIIMsgFormatter::nvi_formatReadMsg(...) const /.../msg_formatter.cc:47 (action_client_test+0x19402b)
    #4 ...
    #5 cmr::UartHal::readSensor&lt;double, void&gt;(...)::{lambda()#1}::operator()() const /.../uart_hal.h:201 (action_client_test+0x1a771f)
    ...
    #24 std::thread::_Invoker&lt;std::tuple&lt;std::function&lt;void ()&gt; &gt; &gt;::operator()() /usr/include/c++/9/thread:251 (action_client_test+0x1e7565)
    #25 std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;std::function&lt;void ()&gt; &gt; &gt; &gt;::_M_run() /usr/include/c++/9/thread:195 (action_client_test+0x1e7565)
    #26 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0xd44bf)

  Previous write of size 1 at 0x7b1000006959 by thread T9:
    #0 cmr::ASCIIMsgManager&lt;std::atomic&lt;unsigned char&gt;, void&gt;::addMsgIdentifier(...) (action_client_test+0x197ccd)
    #1 cmr::MsgManager::addMsgIdentifier(...) (action_client_test+0x19412a)
    #2 cmr::msgFmt::ASCIIMsgFormatter::addMsgId(...) (action_client_test+0x19412a)
    #3 cmr::msgFmt::ASCIIMsgFormatter::nvi_formatWriteMsg(...) (action_client_test+0x19412a)
    #4 ...
    #5 operator() /.../uart_hal.cc:151 (action_client_test+0x1a2cc7)
    #6 _M_invoke /usr/include/c++/9/bits/std_function.h:300 (action_client_test+0x1a2cc7)
    #7 std::function&lt;void ()&gt;::operator()() const /usr/include/c++/9/bits/std_function.h:688 (action_client_test+0x19c93c)
    #8 cmr::resultFromExceptions(std::function&lt;void ()&gt;) /.../uart_hal.cc:36 (action_client_test+0x19c93c)
    #9 cmr::UartHal::setMotor(...) /.../uart_hal.cc:156 (action_client_test+0x19cbbd)
    #10 cmr::UartHal::setMotorEffort(...) /.../uart_hal.cc:161 (action_client_test+0x19cce2)
    ...

  Location is heap block of size 64 at 0x7b1000006940 allocated by main thread:
    #0 operator new(unsigned long) &lt;null&gt; (libtsan.so.0+0x8e62e)
    ...
    #10 main /ws/src/Superproject/cmr_hal/test/messaging_thread_test.cpp:305 (action_client_test+0xb2f9c)

  Thread T10 (tid=20510, running) created by thread T6 at:
    #0 pthread_create &lt;null&gt; (libtsan.so.0+0x5fe84)
    #1 std::thread::_M_start_thread(...) &lt;null&gt; (libstdc++.so.6+0xd4765)
    ...

  Thread T9 (tid=20509, running) created by thread T6 at:
    #0 pthread_create &lt;null&gt; (libtsan.so.0+0x5fe84)
    #1 std::thread::_M_start_thread(...) &lt;null&gt; (libstdc++.so.6+0xd4765)
    ...

SUMMARY: ThreadSanitizer: data race /.../msg_manager.h:158 in 
cmr::ASCIIMsgManager&lt;std::atomic&lt;unsigned char&gt;, void&gt;::addMsgIdentifier(...)
</code></pre>
<p>I used <code>...</code> to cut out paths, function argument types, and parts of stacktraces to make this easier to read. 
The big thing to look at is the <code>SUMMARY</code> line Tsan gives you, which gives you the file and line number
of the data race.</p>
<p>Similar to DRD, it will give you the stacktrace of the access for each thread. However this tool will also give
you stacktraces for where the conflicting threads are created, and give you a memory location for the data
that it detected a data race for.</p>
<h3 id="undefined-behavior-sanitizer"><a class="header" href="#undefined-behavior-sanitizer">Undefined Behavior Sanitizer</a></h3>
<p>As the name implies, this one checks for undefined behavior. We can compile with the <code>-fsanitize=undefined</code> flag.
You might also want to use <code>-fsanitize=nullability</code> in conjunction.</p>
<h3 id="leak-sanitizer"><a class="header" href="#leak-sanitizer">Leak Sanitizer</a></h3>
<p>As the name implies, this one checks for memory leaks. To use this one, you guessed it, link with <code>-fsanitize=leak</code>.</p>
<hr />
<p>For more information on Sanitizers, check out <a href="https://clang.llvm.org/docs/index.html">clang's compiler documentation</a> and for more information on Valgrind, check out <a href="https://valgrind.org/">their website</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doxygen"><a class="header" href="#doxygen">Doxygen</a></h1>
<p>Doxygen is a popular tool to generate documentation from the comments we write in code. 
It can generate HTML, XML, LaTeX, and more. Doxygen recognizes a lot of commenting styles but probably the most popular are three slashes <code>///</code> 
and Javadocs style <code>/** */</code>. If using Javadocs, we'll probably want to set <code>JAVADOCS_AUTOBRIEF</code> to true in the configuration file so the first line (or until the first period) is 
recognized as a brief description. Otherwise, a brief description will require an explicit <code>@brief</code> tag.</p>
<p>Documentation comments typically go right before the thing they are documenting. We can put them right after however, if the first character of the comment is <code>&lt;</code>.</p>
<pre><code class="language-C++">/// An IO stream to a hardware port
class Port {
protected:
    std::optional&lt;std::string&gt; lastError; 
    ///&lt; The most recent error since errstr() was called.
public:
    virtual ~Port() = default;

    /**
    * Writes all of data to the port
    * Provides the basic guarantee
    * @throw IOException on failure
    */
    virtual void writeAll(const std::vector&lt;std::byte&gt; &amp; data) = 0;

    /**
    * Gets the last error and resets the error string
    * @return the most recent error since the last call to
    *   errstr or empty optional if there has been no error
    */
    std::optional&lt;std::string&gt; errstr() noexcept {
        const auto err = lastError;
        lastError.reset();
        return err;
    }

    /**
    * Reads at least the specified amount of bytes from the port
    * Call will block until specified amount of bytes are read
    * @param bytes the minimum amount of bytes to read
    * @return data read or empty vector if nothing read. Size will be at least `bytes`
    * @throw IOException on failure - Basic guarantee
    */
    virtual std::vector&lt;std::byte&gt; read(size_t bytes = 0) = 0;
};

</code></pre>
<p>I tend to use <code>///</code> for short or single line comments and Javadocs for longer ones. 
I also tend to omit things that I feel are unnecessary or repetitive such as an <code>@param</code> indicator for <code>data</code> in <code>writeAll()</code>. 
Based on this logic, <code>@param bytes</code> could probably be removed from the spec of <code>read()</code> however I personally would rather slightly verbose comments than slightly ambiguous.</p>
<p>Since we're looking at this code, I probably wouldn't have a <code>lastError</code> member as we can get this information to the caller in our <code>IOException</code>. 
Plus, the comment for <code>lastError</code> is slightly repetitive but this was really more for examples than anything.</p>
<p>Doxygen supports markdown in their comments. They also have a large range of special commands denoted with either a <code>\</code> or <code>@</code> and then the command name.</p>
<p>One such category of these commands are structural commands which allow you to document something separate from its definition. 
The syntax would be to put the structural command on the first line of the file followed by the name of the thing you are commenting. Structural commands include:</p>
<ul>
<li><code>\file</code> - comment for file</li>
<li><code>\def</code> - document a <code>#define</code></li>
<li><code>\var</code> - variable</li>
<li><code>\fn</code> - function</li>
<li><code>\struct</code></li>
<li><code>\namespace</code></li>
<li><code>\union</code></li>
<li><code>\enum</code></li>
</ul>
<pre><code class="language-C++">/** \file source.cpp
* Doxygen testing
* Detailed Desc
*/

/// \def MAX(a, b)
/// max value of `a` and `b`

/// \namespace Utils
/// Contains utility functions



#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))

namespace Utils {

}
</code></pre>
<p>Doxygen allows you to group functions under the same comment with member grouping. 
A group is opened with <code>@{</code> and closed with <code>@}</code>. This allows you to use one comment for similar functions such as overloads. 
Groups can also be named using <code>@name</code> (or <code>\name</code>) before the opening bracket. The following example is taken from Doxygen documentation.</p>
<pre><code class="language-C++">/** A class. Details */
class Memgrp_Test
{
  public:
    ///@{
    /** Same documentation for both members. Details */
    void func1InGroup1();
    void func2InGroup1();
    ///@}
 
    /** Function without group. Details. */
    void ungroupedFunction();
    void func1InGroup2();
  protected:
    void func2InGroup2();
};

/** @name Group2
 *  Description of group 2. 
 */
///@{
/** Function 2 in group 2. Details. */
void Memgrp_Test::func2InGroup2() {}
/** Function 1 in group 2. Details. */
void Memgrp_Test::func1InGroup2() {}
///@}
 
</code></pre>
<p>Doxygen also supports module grouping which puts group members onto separate pages. 
To do this, first you must create a group by using <code>\defgroup</code> followed by the group label and then a description if desired. 
Next, we can add definitions to that group by putting <code>\ingroup &lt;group label&gt;</code> in the documentation comment of that member. 
To avoid repeating this command, you can also put <code>\addtogroup &lt;label&gt;</code> before the opening member group brace (<code>@{</code>) to add everything within that member group to the module group. 
Finally, you can embed links to another group using the <code>\ref &lt;label name&gt; [&quot;&lt;link text&gt;&quot;]</code> command and specifying an optional string to use as the hyperlink in the comment.</p>
<pre><code class="language-C++">/** @defgroup Group1
*  Basic Math functions
* @{
*/

int add(int, int);
int sub(int, int);
///@}

/// \ingroup Group1
int div(int, int);

/// \addtogroup Group1
/// @{
int mul(int, int);
int pow(int, int);
/// @}

/// \ref Group1 &quot;Click Me&quot;
void foo();
</code></pre>
<p>You can use Latex formulas in comments by enclosing them within <code>\f[</code> and <code>\f]</code>. This only works for HTML, Latex, and RTF output.</p>
<h2 id="linking"><a class="header" href="#linking">Linking</a></h2>
<p>Doxygen automatically links to other classes and files when we include them in the comment. 
All words with a dot that isn't the last character are considered to be file names, and if such a file was input to the generator, a link to that file is automatically generated. 
Doxygen will automatically link to classes if the class names contains at least one non-lower-case character (uppercase, underscores, etc.). 
If a class contains only lowercase characters, you can still link to it with <code>\ref</code>.</p>
<p>Functions are automatically linked when it encounters patterns such as the following:</p>
<ul>
<li><code>&lt;function name&gt;()</code> or <code>&lt;function name&gt;(&lt;args&gt;)</code></li>
<li><code>::&lt;function name&gt;</code></li>
<li><code>&lt;class name&gt;::&lt;function name&gt;[([&lt;args&gt;])] [&lt;modifiers&gt;]</code>
<ul>
<li>Examples:
<ul>
<li><code>MyClass::myFunc</code></li>
<li><code>MyClass::doFoo(int, int) const</code></li>
<li><code>MyClass::doIt(int)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Arguments and modifiers are required if there are overloads of the same function. Furthermore, just like all <code>@</code> can be replaced with <code>\</code> and vice versa in commands, so too can we replace <code>::</code> with <code>#</code>.</p>
<p>Doxygen also supports the <code>a</code> HTML tag for links as well (<code>&lt;a href=&quot;https://en.wikipedia.org/wiki/Main_Page&quot;&gt;Click Me&lt;/a&gt;</code>). 
In comments, we can use <code>\sa</code> or <code>\see</code> to list any references, although this section isn't necessary. This section creates a separate paragraph in the output whereas just using automatic link generation does not.</p>
<h2 id="other-useful-commands"><a class="header" href="#other-useful-commands">Other useful commands:</a></h2>
<ul>
<li><code>\todo {desc of todo}</code></li>
<li><code>\warning {desc of warning}</code></li>
<li><code>\bug {desc of bug}</code></li>
<li><code>\emoji &lt;emoji name&gt;</code></li>
<li><code>\image &lt;format&gt; &lt;file&gt; [&lt;caption&gt;] [&lt;dimension&gt; = &lt;size&gt;]</code>
<ul>
<li><code>format</code> indicates the output format in which the image should be embedded: <code>html</code>, <code>rtf</code>, <code>latex</code>, or <code>docbook</code>.</li>
<li><code>dimension</code> is used to specify either the width or height of the image</li>
<li><code>\image html myImg.jpg</code></li>
</ul>
</li>
<li><code>\internal</code> and <code>\endinternal</code>
<ul>
<li>Comments for internal use only</li>
</ul>
</li>
<li><code>\page &lt;name&gt; &lt;page tile&gt;</code>
<ul>
<li>Indicates the comment belongs on a separate page and is separate from documentation of a method or class</li>
<li>In a comment block that is a page comment, we can create sections with:
<ul>
<li><code>\section &lt;name&gt; &lt;section title&gt;</code></li>
<li><code>\subsection &lt;name&gt; &lt;subsec title&gt;</code></li>
<li><code>\subsubsection &lt;name&gt; &lt;subsubsec title&gt;</code></li>
<li><code>\paragraph &lt;name&gt;</code></li>
<li><code>\subpage &lt;name&gt;</code> - indicates that page <code>name</code> is a child of the current page comment block</li>
<li><code>\tableofcontents</code> - creates a TOC for the current page and all sections</li>
</ul>
</li>
</ul>
<pre><code>From Doxygen documentation:


/*! \page page1 A documentation page
\tableofcontents
Leading text.
\section sec An example section
This page contains the subsections \ref subsection1 and \ref subsection2.
For more info see page \ref page2.
\subsection subsection1 The first subsection
Text.
\subsection subsection2 The second subsection
More text.
*/

/*! \page page2 Another page
Even more info.
*/
</code></pre>
</li>
<li><code>\mainpage &lt;name&gt; &lt;title&gt;</code>
<ul>
<li>Same idea as <code>\page</code> except this page is the main page. For example, it would become the <code>index.html</code> page in html output.</li>
</ul>
</li>
<li><code>\anchor &lt;name&gt;</code>
<ul>
<li>Creates a point that can be referenced with <code>\ref name</code></li>
</ul>
</li>
<li><code>\pre {desc}</code> - starts a paragraph for preconditions</li>
<li><code>\post {desc}</code> - starts a paragraph for postconditions</li>
<li><code>\test {desc}</code> - starts a paragraph for test cases or examples</li>
<li><code>\invariant {desc}</code> - starts a paragraph for invariants</li>
<li><code>\implements &lt;name&gt;</code> - indicates a subtyping relationship. Not necessary when using OOP inheritance</li>
</ul>
<h2 id="config"><a class="header" href="#config">Config</a></h2>
<p>With the code documented, we can generate the config file with the command <code>doxygen -g [config-file-name]</code>. This command can be done in the root directory of your project. 
This will generate a template config file, which, for the most part, is pretty good. 
A few things I do like to change is to set <code>SEARCHING</code> to <code>YES</code> and <code>SERVER_BASED_SEARCH</code> to <code>NO</code>. 
This will allow client-side searching in the generated output. For HTML, this is a local javascript search engine. 
I also set <code>JAVADOCS_AUTOBRIEF</code> to <code>YES</code> so that the first line of Javadocs documentation is the brief without having to specify <code>\breif</code>. 
You probably also want to set <code>RECURSIVE</code> to <code>YES</code> so that it will recursively go through the input directory looking for files that match supported file patterns. 
These patterns can be modified by changing the <code>FILE_PATTERNS</code> setting and the <code>EXCLUDE_PATTERNS</code> setting. You can also add files to the <code>EXCLUDE</code> setting to exclude certain files or directories.</p>
<p>We can control where and how doxygen will generate the output with the <code>OUTPUT_DIRECTORY</code>, <code>HTML_OUTPUT</code>, <code>LATEX_OUTPUT</code>, <code>RTF_OUTPUT</code>, <code>XML_OUTPUT</code>, <code>DOCBOOK_OUTPUT</code>, and <code>MAN_OUTPUT</code> tags. 
By default, the output directory is the same directory as the doxyfile (doxygen config file).</p>
<p>Finally, to generate our documentation, run <code>doxygen &lt;config file name&gt;</code>. The config file name can be omitted if it's called <code>Doxyfile</code> and you are running the command in the same directory as this file.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>You can download doxygen pre-compiled <a href="https://www.doxygen.nl/download.html">here</a>. 
Various linux distros also have doxygen downloadable through their package manager (I know Ubuntu does). 
You may need to install GraphViz (what Doxygen uses to generate inheritance graphs) separately <a href="https://graphviz.org/download/">here</a> or through your package manager. 
For Windows, you should add <code>dot</code> to your path system variable via the GraphViz installer.</p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://cliutils.gitlab.io/modern-cmake/">Not written by me, feel free to peruse</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-analysis"><a class="header" href="#static-analysis">Static Analysis</a></h1>
<p>Static analysis tools look at the source code and warn you of any possible errors. Some static analysis tools also warns about code
that doesn't adhere to certain guidelines such as the core guidelines.</p>
<p><code>cppcheck</code> is a popular static analysis tool. It focuses on issues that might cause bugs, however it also 
has extensions to enforce some coding style checks.</p>
<p>Unix users can simply download it from your package manager. It has a command line and GUI interface (<code>cppcheck-gui</code>).
Source code and Windows installer are available <a href="http://cppcheck.sourceforge.net/">here</a>.
On Windows, make sure to add <code>C:/ProgramFiles/CppCheck</code> (or whatever its download location is), to your PATH
so that you can use the <code>cppcheck</code> in the command line.</p>
<p>I would suggest the cppcheck GUI as it's very easy to use. Visual Studio
also has a cppcheck plugin, however it seems to only work for Visual Studio projects (not CMake).</p>
<p>Some helpful command line arguments:</p>
<ul>
<li><code>-I &lt;include directory&gt;</code> - search through the following include directories</li>
<li><code>--library=&lt;lib&gt;</code> - uses information about an external library such as <code>googletest</code> or <code>openssl</code></li>
<li><code>--addon=&lt;addon&gt;</code> - enable an addon such as <code>cert</code> which enables checks for CERT coding guidelines</li>
<li><code>--enable=&lt;check&gt;</code> - enables checks with the given name, such as <code>all</code>, which enables all checks</li>
<li><code>--platform=&lt;type&gt;</code> - sets the platform type (such as <code>unix64</code>, <code>win64</code>, <code>avr8</code>, etc.)</li>
<li><code>--std=&lt;std&gt;</code> - sets the standard version (ex. <code>c11</code>, <code>c89</code>, <code>c++11</code>, <code>c++17</code>, <code>c++03</code>). The current default is <code>c++20</code>.</li>
<li><code>--output-file=&lt;file&gt;</code> - writes results to an output file instead of <code>stderr</code></li>
<li><code>--cppcheck-build-dir=&lt;dir&gt;</code> - specifies the build directory. These speeds up repeated analysis times by only checking files that changed.</li>
<li><code>-i &lt;dir&gt;</code> - exclude a directory or file</li>
<li><code>--max-ctu-depth=&lt;N&gt;</code> - sets the maximum analysis depth. Higher values are slower but can catch more errors. The default is 2.</li>
<li><code>--project=&lt;file&gt;</code> - specify the project file to use. This file can be a Visual studio <code>.sln</code>, it can be a <code>compile_commands.json</code>, or it can be a <code>.cppcheck</code> xml file which stores the options for checking a given directory. These are generated by the cppcheck gui, but can also be written manually.</li>
</ul>
<p>For the following file structure:</p>
<pre><code>Project
|
|___include
|   |
|
|___src
|   |
|
|___test
|   |
|
</code></pre>
<p>we can run <code>cppcheck</code> with the command</p>
<pre><code>cppcheck -I Project/include/ Project/src/ Project/test/ --library=googletest --std=c++17
</code></pre>
<p>Another thing to note is that CMAKE can generate a cppcheck project file for us by enabling <code>CMAKE_EXPORT_COMPILE_COMMANDS</code>.
This can be done with <code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code>. This outputs a <code>compile_commands.json</code> file which we can specify
to cppcheck to use via <code>--project</code>. Specifically, what this does it it creates a compilation database which stores
information such as the compiler options used, source files, and include directories. Using a compiltation database makes
satic analysis tools more effective by providing them more information to work with.</p>
<h3 id="clang-tidy"><a class="header" href="#clang-tidy">Clang-tidy</a></h3>
<p><code>clang-tidy</code> is another static analysis tool that focuses more on stylistic checks than <code>cppcheck</code>. It is only available for Unix,
however on Windows you can use the the Code Analysis tools built into Visual Studio which are very good. This tool
incorporates some of the CPP Core Guidelines into their checks.</p>
<p>We can use it like so:</p>
<pre><code>clang-tidy -header-filter=.* -checks=* src/* include/*
</code></pre>
<p>The <code>-header-filter</code> argument is used to filter which header files the tool will look at. In this example, we have it analyze
all the headers. The <code>-checks</code> argument is passed a pattern to filter which checks to enable, here we enable all checks.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>For Windows, Visual Studio (not VSCode) has code analysis under the <code>Analyze</code> tab. Microsoft has further information and documentation
about this <a href="https://docs.microsoft.com/en-us/cpp/code-quality/code-analysis-for-c-cpp-overview?view=msvc-170">online</a>. The VS code analysis is quite good and incorportates the CPP Core Guidelines. You can also use it by using the <code>/analyze</code> flag on MSVC compiler.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project"><a class="header" href="#project">Project</a></h1>
<p>To put all of this together, we're going to make an HTTP client and server utility. The program will be able to host web servers and connect to others as well. 
It will be a command line program that accepts the following commands:</p>
<ul>
<li><code>-serve &lt;directory&gt;</code> - create a server with the specified root directory</li>
<li><code>-get &lt;url&gt;</code> - GET request</li>
<li><code>-post &lt;url&gt;</code> - POST request</li>
<li><code>-port &lt;port&gt;</code> - set the port number on the server or request
<ul>
<li>Overrides any port specified in the URL for a request</li>
</ul>
</li>
<li><code>--&lt;header&gt; &lt;value&gt;</code> - set a HTTP header in a request</li>
<li><code>-content [-f] &lt;text&gt;</code> - specifies the content in a request or server. An optional <code>-f</code> command may follow indicating that the content is to be read from the specified file. If the content contains spaces, it must be enclosed with quotes. If content is specified for a server, this essentially specifies the <code>index.html</code>.</li>
<li><code>-ssl [-only] &lt;certificate&gt;</code> - makes the server use SSL using the specified certificate file. If the <code>-only</code> flag is set the server rejects plaintext</li>
<li><code>-o &lt;file&gt;</code> - stores the result of a request into the specified file</li>
<li>If no arguments are passed, or invalid/incorrect arguments are used, a help message containing the above information should be shown.</li>
</ul>
<p>The program should be cross-compatible on Windows and Unix systems. For windows, you will have to link with <code>Ws2_32.lib</code> and most of the networking stuff will be in the <code>WinSock2.h</code> header. You may also need <code>WS2tcpip.h</code> (and others). For Unix, you may want to look at <code>sys/socket.h, sys/types.h, netinet/in.h, sys/select.h, fcntl.h, arpa/inet.h, sys/ioctl.h, unistd.h, netdb.h</code>. The socket API for both libraries are very similar, but there are a few slight differences: (these are not the only ones)</p>
<div class="table-wrapper"><table><thead><tr><th>Windows</th><th>Unix</th></tr></thead><tbody>
<tr><td><code>ioctlsocket(socket, long cmd, u_long* arg)</code></td><td><code>ioctl(int fd, long cmd, ...) (sort of equal but not quite)</code></td></tr>
<tr><td><code>closesocket(socket)</code></td><td><code>shutdown(sock, SHUT_RDWR); close(sock)</code> (the <code>shutdown()</code> isn't necessary)</td></tr>
<tr><td><code>WSAGetLastError()</code></td><td><code>errno</code></td></tr>
</tbody></table>
</div>
<p>Winsock requires manual initialization with <code>WSAStartup()</code> and <code>WSACleanup()</code>.</p>
<p>Start with whatever OS you natively have, then try to support the other afterwards. This is a good case for extracting the OS specific code into a policy which can be passed to the socket classes as a template argument.</p>
<p>Since both of these APIs are C APIs, most of their functions return error codes. It's important to make sure these errors are handled.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p><a href="https://github.com/stephenverderame/CppBookProject">Starter code available here</a>.
You will also need to install OpenSSL.
For windows, you can download pre-compiled binaries via an installer <a href="https://slproweb.com/products/Win32OpenSSL.html">here</a>.
OpenSSL also have a list of some other recommended third parties for getting the pre-compiled binaries <a href="https://wiki.openssl.org/index.php/Binaries">here</a>.</p>
<p>For Unix users, you can simply install <code>libssl-dev</code> and <code>openssl</code> from your package manager.
You will also need to make sure you have CMake and Doxygen installed. Ubuntu users can simply install <code>cmake</code> and <code>doxygen</code> from <code>apt</code>
(other distros might have the binaries available from the package manager, otherwise go the the link),
and Windows users can find installations for <a href="https://cmake.org/download/">cmake here</a> and
<a href="https://www.doxygen.nl/download.html">doxygen here</a>.
You may need to install GraphViz (what Doxygen uses to generate inheritance graphs)
separately <a href="https://graphviz.org/download/">here</a>. For Windows, you should add <code>dot</code> to your path system variable via the installer.</p>
<p>The starter code has the following architecture. Black boxes indicate already provided modules. The double angled brackets indicates an interface,
an open arrow indicates a subtyping relationship, and a closed arrow indicates a dependency. Boxes with dotted lines indicates
unimplemented modules and only show <strong>a possible</strong> implementation.
You may find that this possible architecture poses problems (I just drew it up quickly).
Furthermore, in the spirit of YAGNI (&quot;you ain't gonna need it&quot;), you may find some things (such as an abstract server and client)
unnecessary.</p>
<p><img src="res/CppBookProjectSetup.png" alt="Image of Possible Architecture" /></p>
<p>The starter code contains a <code>Networking.h</code> file that has os dependent includes. Ideally, you should minimize dependencies of every module, thus
this file should really only be included in source files or header files that do not need to be directly included by the client.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li>Gain experience with GTest, GMock, and CMake</li>
<li>Practice with static and dynamic polymorphism in C++ and programming to an interface</li>
<li>Practice designing template function and classes</li>
<li>Use C++ Idioms, Clean Architecture and Design Patterns</li>
<li>Familiarize yourself with the standard library</li>
<li>Learn about socket programming</li>
<li>Experience with Doxygen</li>
</ul>
<h3 id="what-youll-probably-need-to-know"><a class="header" href="#what-youll-probably-need-to-know">What you'll (probably) need to know</a></h3>
<ul>
<li>Section 2 (Basics to Basic Containers)</li>
<li>Template Basics Chapter (at least to specialization)</li>
<li>STL Functional Programming Chapter</li>
<li>Section 4 (Tools and Project)</li>
</ul>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<ul>
<li>Implement the Socket Class
<ul>
<li>This class will adhere to the RemotePort concept (see <code>Port.h</code>)</li>
<li>It will take a policy class that handles code changes depending on the OS</li>
<li>Test your implementation in <code>SocketTest.cpp</code></li>
<li>Use <code>SSLSocket</code> for guidance</li>
<li>For Windows: create a RAII class for initialization and cleanup of Winsock. You might want to make this a singleton</li>
</ul>
</li>
<li>Implement Exception class(es)
<ul>
<li>I crudely throw integers just to show which function gets the error code you'd want to look at, this isn't that helpful for displaying error messages or catching exceptions</li>
<li>Implement an exception class or exception hierarchy </li>
</ul>
</li>
<li>Implement the HTTP request and response frames
<ul>
<li>User should be able to choose HTTP version (parameter to <code>compose</code> method or pass to constructors?)</li>
</ul>
</li>
<li>Implement the HTTP client
<ul>
<li>Should take ownership of a <code>Port</code> -&gt; reads and writes requests on this port</li>
<li>Be able to send request Http Frames and receive response frames</li>
<li>User should not have to do any string formatting (except for any content encoding)</li>
</ul>
</li>
<li>Implement HTTP content and transfer encodings:
<ul>
<li>Need to support chunked transfer encoding, and url type data </li>
<li>Design Ideas:
<ul>
<li>HTTP writer decorators:
<ul>
<li>A class that would subtype some kind of HTTP interface and be composed of an implementation of that interface</li>
<li>A high level <code>set_content</code> or <code>write</code> (member or overrided from interface) function would then set the content of the underlying HTTP writer following the specified format and all relevant headers</li>
</ul>
</li>
<li>Transaction Scripts:
<ul>
<li>Non-member helper functions set the writer's content and relevant headers following the specified format</li>
</ul>
</li>
<li>Encoding strategy:
<ul>
<li>A callable object or implementation of some kind of strategy interface is passed to a <code>write</code> function</li>
</ul>
</li>
</ul>
</li>
<li>See <code>ChunkedTest</code> and <code>QueryTest</code></li>
</ul>
</li>
<li>Implement the HTTP server
<ul>
<li>Should take ownership of a <code>Port</code> -&gt; reads and writes requests on this port</li>
<li>Root directory (where all the paths in the request are relative to) should be customizable</li>
<li>Handles <code>GET</code> and <code>POST</code> requests</li>
<li>Supports URL encoding</li>
<li>See <code>ChunkedTest</code> and <code>QueryTest</code></li>
</ul>
</li>
<li>Implement the command line argument marshallers
<ul>
<li>Recognize command line arguments</li>
<li>The arguments can be specified in any order</li>
</ul>
</li>
<li><del>Feel free to</del> add your own tests and expand upon the existing ones</li>
<li>Tie it all together:
<ul>
<li>Create a website with a C++ backend:
<ul>
<li>More than 1 page</li>
<li>Something that accepts user input</li>
<li>Bonus:
<ul>
<li>CRUD (create, read, update, delete) operations on some &quot;database&quot;</li>
<li>Fetching images (or some other non-plaintext data) from the site</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Use Doxygen to generate documentation for your project
<ul>
<li>Comment your code in a Doxygen recognized format</li>
</ul>
</li>
<li>(Optional) Implement <code>FdSet</code>
<ul>
<li>Not really necessary because HTTP is a stateless connection protocol</li>
<li>But if you needed to keep track of active connections this would be vital</li>
</ul>
</li>
<li>(Optional) Add IPv6 Support to <code>Address</code>
<ul>
<li>Make Address a template accepting a policy which controls:
<ul>
<li>type of the <code>addrData</code> member. (<code>sockaddr_in</code> vs <code>sockaddr_in6</code>)</li>
<li>family <code>AF_INET</code> vs <code>AF_INET6</code></li>
<li>the <code>is_ip</code> member function</li>
</ul>
</li>
<li>OR use runtime polymorphism and a factory function so that the correct Address class can be chosen at runtime based on the IP address passed to the factory function</li>
</ul>
</li>
<li>(Optional) Add JSON support
<ul>
<li>JSON object and array types which can be serialized from and into JSON text</li>
<li>Support for sending and receiving JSON data in the HTTP client and server</li>
</ul>
</li>
</ul>
<h2 id="possibly-useful"><a class="header" href="#possibly-useful">Possibly Useful</a></h2>
<ul>
<li><a href="https://github.com/stephenverderame/webchat">Similar project I developed a few years ago</a>
<ul>
<li>Neither implementation is the best designed, however WebLib2 is better</li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">HTTP Reference on MSDN</a></li>
<li><a href="https://en.cppreference.com/w/cpp/regex">C++ Regex Library</a></li>
<li><a href="https://en.cppreference.com/w/cpp/filesystem">C++ Filesystem Lib</a></li>
<li><a href="https://en.cppreference.com/w/cpp/io">C++ Streams Lib</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/winsock/getting-started-with-winsock">Microsoft Docs for Winsock</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/socket.2.html">Man Pages for POSIX Functions</a></li>
</ul>
<h2 id="other-notes-1"><a class="header" href="#other-notes-1">Other Notes</a></h2>
<p>You can use preprocessor conditions around the definition of <code>WIN32</code> to conditionally enable code depending on if using Windows or Unix. 
<code>WIN32</code> is a macro defined by the compiler when compiling on Windows (even Win64).
In the CMake, I also define <code>WINDOWS</code> when the platform is Windows and <code>UNIX</code> when it is not.</p>
<pre><code class="language-C++">#ifdef WIN32
// windows only code

// ifdef -&gt; &quot;if defined&quot;
// if the macro WIN32 is defined, include this code
#else
// non-windows code
#endif
</code></pre>
<p>Feel free to change the implementation or design of anything.
Although there is a comment saying not to, you may change the Port interface so long as you make sure to have tests.</p>
<p>The current project structure is as follows:</p>
<pre><code>&lt;Project Directory&gt;
|   CMakeLists.txt
|---HttpProject
|   |   CMakeLists.txt
|   |---include
|   |---src
|   |---test
|   |   |   CMakeLists.txt
|   |   |---data
|   |
|---external
|---out
|
</code></pre>
<p>To connect to a HTTP server running on your machine, you can simply type <code>localhost</code> or <code>127.0.0.1</code> into the address bar of your browser.
If you use a port other than <code>80</code> for HTTP and <code>443</code> for HTTPS, then the port must be specified by a colon and port number following the address.
Ex: <code>localhost:3000</code></p>
<p>Other devices on the same network as you can connect via your LAN address which is listed when you run the command <code>ipconfig</code> on Windows or <code>ifconfig</code> on Unix.</p>
<hr />
<blockquote>
<p>&quot;Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program.&quot;</p>
<p>- Linus Torvalds</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-engineering-tips"><a class="header" href="#software-engineering-tips">Software Engineering Tips</a></h1>
<p>I'm going to talk about a few things that I thought helped me become a better software engineer.
I'll hit a few points briefly, but most of this comes from <em>The Pragmatic Programmer</em> and <em>Clean Architecture</em>.</p>
<p>First let's discuss what I mean when I say module and component.
A module is often realized by a class in OOP languages.
You can think of it as a single unit of <u>independent</u> work.
The module includes everything it needs to be interchangeable and perform its desired functionality.
For example, I would consider the class <code>std::vector&lt;T&gt;</code> a module.
However, despite being their own class, I would consider the nested classes <code>std::vector&lt;T&gt;::iterator</code>
and <code>std::vector&lt;T&gt;::const_iterator</code> also to be part of the <code>std::vector</code> module.</p>
<p>A component, as Uncle Bob uses the term,
is an independently deployable unit of work one developer or developer team is responsible for.
A component would be like a library or compiled executable, such as a DLL, static library, JAR file,
Nuget package, ROS node, or EXE file. Ideally, developer teams can release updates to their components,
and other teams that depend on the components can choose when to upgrade to the newer version.
Components are independently compiled and linked, changes in one component have no immediate effect
on other components.</p>
<h3 id="dry-and-etc"><a class="header" href="#dry-and-etc">DRY and ETC</a></h3>
<p>From the Pragmatic Programmer.</p>
<p>This is probably the crux of good software engineering. Don't repeat yourself, and write code that's easy to change.
Unless you're refactoring code, every time you copy and paste something, ask yourself if there's a better way to do whatever it is you're doing.
Any bug in the copied code leads to bugs everywhere you paste that code. Furthermore, making a change to pasted code
requires making a change to all other copies. Not only should you not repeat yourself in code, but you shouldn't
repeat yourself in comments either.</p>
<p>We also want to strive to make our code easy to change. Refactoring should be relatively painless. We can't see the future, so
let's avoid casting any decision in stone. In fact, delay making decisions that constrains the code until as late as possible.
Can you develop almost an entire application without deciding what UI framework to use, or even if you want to develop a desktop or web app?</p>
<h3 id="gardening-not-construction"><a class="header" href="#gardening-not-construction">Gardening, not Construction</a></h3>
<p>Often time developing a program is given the analogy of construction, but Uncle Bob (I think) points out that gardening is a better analogy.
When you build a house, you plan it out in detail ahead of time, execute that plan, and then kind of move on. The house might need maintenance here and there every
so often, but often nothing extensive. Gardening is something that the gardener never walks away from. There's weeding, fertilizing, watering,
and probably a bunch of other stuff I don't know about since I'm not a gardener. Refactoring isn't like ripping apart the foundation,
and rebuilding a house, it should be like weeding, done continually as you go along. Even if you're not unit testing a module or function, still
think &quot;Red&quot;-&quot;Green&quot;-&quot;Refactor&quot;.</p>
<h3 id="small-functions-and-the-art-of-naming"><a class="header" href="#small-functions-and-the-art-of-naming">Small Functions and the Art of Naming</a></h3>
<p>Small functions essentially allows us to name sections of code. Names for modules and functions should be short, and describe more or
less everything that it's doing. Use names like comments, they can help us understand what's going on in the code. Most importantly
however, don't make a liar out of the code. If the function of something changes to no longer match its name, change the name.</p>
<h3 id="srp"><a class="header" href="#srp">SRP</a></h3>
<p>Single Responsibility Principle</p>
<p>A module should have one responsibility, what does that mean, well it means one and only one reason to change.
It should be responsible for one actor, or stakeholder. Consider an Employee module with the methods
<code>calculatePay()</code>, <code>reportHours()</code>, and <code>saveVPNUsage()</code>. <code>calculatePay()</code> might be handled by Accounting,
<code>reportHours()</code> by HR, and <code>saveVPNUsage()</code> by IT. If HR decides to change how it manages clocking in and out,
accounting's <code>calculatePay</code> should not be affected.</p>
<p>Other things that might indicate an SRP violation include merge conflicts and the &quot;Monday Morning Syndrome&quot;.
The latter is when you come back to code that was working fine the last time you touched it, but is now
broken since someone else made some other change. The name comes from the idea that you come back Monday morning
to broken code that was working when you left for the weekend Friday afternoon.</p>
<h3 id="ocp"><a class="header" href="#ocp">OCP</a></h3>
<p>Open Close Principle</p>
<p>A module should be open for extension but closed for modification. Ideally, a module's behavior can be extended to and changed
without modifying the actual module. In OOP, this often looks like inheritance and subtyping, however another form of this is to
have the module take callable objects as input.</p>
<p>Imagine that you display negative numbers in an online spreadsheet in red. Now someone wants to print the spreadsheet in black and white.
How much code would change to do something else, like display negative numbers in bold-face? Ideally, no code will need to change,
and you just need to add code.</p>
<p>We can create a class hierarchy based on the notion of &quot;level&quot;. The highest level modules, are the most protected from change.
A module of a higher level is normally a module that is further away from the inputs and outputs of the program, normally a
more abstract module, and normally a module that contains &quot;business logic&quot;. Business logic can be seen as the crux of what your application does.
If module <code>A</code> should be protected from change from module <code>B</code>, then <code>B</code> should depend on <code>A</code>.</p>
<h3 id="lsp"><a class="header" href="#lsp">LSP</a></h3>
<p>Liskov Substitution Principle</p>
<p>Everything should be substitutable like interchangeable parts. This roughly boils down to programming to an interface, and not an implementation.
What this means is that a client should control an implementation through an abstract interface. Furthermore, the client should not know or care what
the actual concrete implementation that they are using is.</p>
<h3 id="isp"><a class="header" href="#isp">ISP</a></h3>
<p>Interface Segregation Principle</p>
<p>Don't depend on things you don't need. In C++, we can PIMPL compiler firewalls and forward declarations.
Let's take the following <code>foo.h</code>as an example:</p>
<pre><code class="language-C++">#include &quot;Bar.h&quot;
#include &quot;Person.h&quot;
#include &quot;Fizz.h&quot;
class Foo {
    Fizz fizz;
    Bar bar;
    Namespace::Person person;
public:
    Namespace::Person fooPerson(const Bar &amp; bar);
    
};
</code></pre>
<p>A person who just wants to use <code>Foo</code> also depends on <code>Fizz</code>, <code>Person</code>, and <code>Bar</code>. If one of these modules
has a change to their interface, the client's code will have to be recompiled even though they only use
<code>Foo</code>!</p>
<p>We can change this to the following:</p>
<pre><code class="language-C++">#include &lt;memory&gt;
namespace Namespace { class Person; }
class Bar;

class Foo {
    struct Impl;
    std::shared_ptr&lt;Impl&gt; pimpl;
public:
    Foo();
    ~Foo();
    class Namespace::Person fooPerson(const class Bar &amp; bar);
};
</code></pre>
<p>Now the client of <code>Foo</code> is doesn't depend on Foo's dependencies.</p>
<p>Furthermore, consider a module with three operations. If a client only wants to use one of these three,
then they'll have to depend on the entire module. So a client will be affected by changes to operations
it doesn't even use!</p>
<p>The parts that make up a module should be inseparable. This also ties into SRP.</p>
<h3 id="dip"><a class="header" href="#dip">DIP</a></h3>
<p>Dependency Inversion Principle</p>
<p>The flow of control in a program should go opposite the dependencies in the program. This inversion is achieved by
interfaces. Consider this simple and generic application architecture:</p>
<p><img src="./res/SimpleMVC.png" alt="MVC Dependency Diagram" /></p>
<p>Notice that the flow of control begins at the View, goes to the Controller, and ends at the Model. Then it returns from the Model, through the Controller,
and back to the View. However, the dependencies go from the Controller to the View and Model. Because the Controller depends on the View and Model,
it is protected from changes in these modules. The idea is to make external logic a plugin, and easily changeable. In this example,
the controller would be the highest level, because it is furthest from inputs and outputs, and would contain the &quot;business logic&quot;.
Business logic includes your IPs (intellectual property), and generally embody the &quot;point&quot;/&quot;purpose&quot; of the application.
We want our business logic to be protected from changes in the view and data model. Thus, it should depend on these things and not the other way around.
In C++, a main function for this application might look something like this:</p>
<pre><code class="language-C++">int main() {
    View v = makeView(/*...*/); 
    // factory function so we don't know what implementation is used
    Model m = makeModel(/*...*/);
    Controller controller(v, m);
    // ...
}
</code></pre>
<p>Uncle Bob says that <strong>nothing concrete</strong> should be depended on. That means that a client should always use the name of the interface and
a client should never <code>#include</code> the header of a concrete implementation.</p>
<h3 id="no-broken-windows"><a class="header" href="#no-broken-windows">No Broken Windows</a></h3>
<p>They say a building with broken windows leads to a sense of abandonment and lack of care in the inhabitants. The same mentality applies to code.
We should never think &quot;eh, that's fine, the rest of the code is a mess anyway&quot;. Refactor as you go and whenever you make a change,
strive to leave the code just a little cleaner than how you found it. It doesn't have to be big, maybe just a single variable name change or splitting
up one large function into two smaller ones. At the very least, comment the bad code with a <code>TODO</code>, but make sure you actually get back to it.</p>
<h3 id="stability"><a class="header" href="#stability">Stability</a></h3>
<p>Stability is a module or component's effort required to make a change. Think of it like inertia. The more things depend on a module,
the harder it is to change, and the more stable it is. A component should depend only on more stable components. Roughly speaking, 
abstractions and interfaces should be the most stable so that its stability doesn't inhibit modifications.
Concrete classes should be the least stable, so they can change easily. This goes back to the advice of DIP: nothing concrete should be depended upon.</p>
<h3 id="humble-object-and-testing-to-an-interface"><a class="header" href="#humble-object-and-testing-to-an-interface">Humble Object and Testing to an Interface</a></h3>
<p>Uncle Bob's Humble Object design pattern is when you use ability to test as a criteria for separating different parts of a module or component.
The idea is to split a module, into two smaller modules; one is easy to test, and one is hard to. This relates to the idea of testing to an interface
and not an implementation. An implementation may have tons of helper functions, since they are not exposed to the interface, they shouldn't be directly tested
to keep the test code as easy to change as production.</p>
<h3 id="engineering-daybook"><a class="header" href="#engineering-daybook">Engineering Daybook</a></h3>
<p>From Pragmatic Programmer</p>
<p>Maybe you aren't as forgetful as I am, but I have found that it's pretty easy to forget the details of what I was working on last week.
Moreover, I have found it's quite annoying to be 5 levels deep in the debugger only to be interrupted and forget where I was.
An engineering &quot;day&quot;-book is a way to help with this. Now I admittedly suck at the whole &quot;day&quot; part of daybook as I'm on the same one 
as when I started a year ago, but the idea is to write down notes, reminders, etc. every day. You can use it for keeping track of where
you are in your debugging, scrap paper for calculations, or just rubber ducking. Rubber ducking is explaining, in detail, what your code that
you're debugging does as the mere act of explaining it to someone (or something) that has never seen it before can help you find
things you missed.</p>
<h3 id="boundaries"><a class="header" href="#boundaries">Boundaries</a></h3>
<p>We can decouple code simply by having separate functions. Later we may find that we need separate modules or separate components.
We can create stronger boundaries by creating different deployment components, separating code to run on independent threads, independent processes, 
or even independent services connected remotely. Stronger boundaries strengthens decoupling but increases the cost of crossing the boundary.</p>
<h3 id="defensive-programming"><a class="header" href="#defensive-programming">Defensive Programming</a></h3>
<p>Always be on the look out for &quot;impossible&quot; program states. Act like there is a little gremlin in your code that's trying to mess you up.
For example, maybe in a switch block the default case should never be executed. Instead of just leaving it out, knowing the default
case should never be chosen, make the default case throw an exception.</p>
<p>Make your interfaces really easy to use and hard to mess up. Finally, document everything you are assuming. It might be hard to notice things
you are subconsciously assuming, but whenever you can see an assumption made in your code, document it. For example,
if you use any of the C string functions on a <code>const char *</code>, you are assuming that <code>const char *</code> is a C string, which
ends in the null terminator.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-patterns-quickly"><a class="header" href="#design-patterns-quickly">Design Patterns (Quickly)</a></h1>
<p>Most of these come from Gang of Four's <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.
I will pretty much exclusively talk about OOP implementations here, but <em>Modern C++ Design</em> does a great
job going over some GoF patterns using a generic programming paradigm.</p>
<p>Feel free to do some more searching online; I'm not kidding when I put &quot;quickly&quot; in the title.</p>
<h3 id="factory-method"><a class="header" href="#factory-method">Factory Method</a></h3>
<p>In its simplest form, a factory method provides indirection between creation of an object and its usage.
Construction of an object cannot be done polymorphically. So if a client were to directly construct
an object, it would have to know about the concrete implementation since you cannot create an instance of
an interface.</p>
<pre><code class="language-C++">std::unique_ptr&lt;Client&gt; makeClient() {
    return std::make_unique&lt;HttpClient&gt;();
}
</code></pre>
<p>Instead of the client directly constructing an <code>HttpClient</code>, it just knows its using some client
by calling <code>makeClient()</code>. What if we made a new HttpClient implementation called  <code>HttpClient2</code>
which has support for Http 2, and deprecated the old <code>HttpClient</code>? Well, with the factory method, our client
would not care or know about this change. Since they only get a client from the <code>makeClient()</code>
function, they don't have to change a single line of their code!</p>
<p>We can expand on the factory function by passing it arguments to control what
concrete implementation it creates and how it creates it.</p>
<pre><code class="language-C++">enum class Clients {
    Http1,
    Http2,
    Websocket,
}
std::unique_ptr&lt;Client&gt; makeClient(Clients clientType) {
    switch (clientType) {
        case Clients::Http1:
            return std::make_unique&lt;HttpClient&gt;();
        case Clients::Http2:
            return std::make_unique&lt;HttpClient2&gt;();
        case Clients::Websocket:
            return std::make_unique&lt;WsClient&gt;();
        default:
            throw std::invalid_argument(&quot;Unknown client type&quot;);
    }
}
</code></pre>
<p>Typically, a factory method would be implemented in a source file so that the client would not depend
upon the headers for the concrete implementations.</p>
<h3 id="abstract-factory"><a class="header" href="#abstract-factory">Abstract Factory</a></h3>
<p>An abstract factory is similar to a factory method. But, in this case we create a hierarchy of factory objects.
Each factory object contains a virtual factory method. This allows us to polymorphically
pass a factory to a function or constructor, and let the receiving object handle the construction.</p>
<pre><code class="language-C++">struct ClientFactory {
    virtual ~ClientFactory() = default;
    virtual std::unique_ptr&lt;Client&gt; operator()() const = 0;
};

struct HttpClientFactory : public ClientFactory {
    std::unique_ptr&lt;Client&gt; operator()() const override {
        return std::make_unique&lt;HttpClient&gt;();
    }
};

struct Http2ClientFactory : public ClientFactory {
    std::unique_ptr&lt;Client&gt; operator()() const override {
        return std::make_unique&lt;HttpClient2&gt;();
    }
};

struct WebsocketClientFactory : public ClientFactory {
    std::unique_ptr&lt;Client&gt; operator()() const override {
        return std::make_unique&lt;WsClient&gt;();
    }
};

void foo(const ClientFactory &amp; maker) {
    auto client = maker();
    // ...
}
</code></pre>
<p>Typically, the implementation of the factory method would be in a source file.</p>
<p>A generic programming approach to this could be to simply pass a factory function as a callable object
instead of creating a class hierarchy. The downside with this is that a user could pass any
callable object with the correct signature, there is no guarantee that it's an actual factory function.</p>
<h3 id="facade"><a class="header" href="#facade">Facade</a></h3>
<p>Imagine that you're creating a computer vision algorithm to get text from an image. You might decide that your approach will be to
first filter the image, then apply the Hough Transform to detect lines in the image, pick out characters using those lines,
and finally use a neural network to recognize the character. To promote code reuse and decoupling, you decide to separate each step into
its own class to allow users to use each operation on its own and avoid possible issues where changes in one module affect another, unrelated module.</p>
<p>Now however, the user must manually execute each step on their own. We can create a Facade that provides a simplified interface.
The goal of a facade is to allow us to create modules with narrow scope, without sacrificing the simplicity of having a giant module with
an end-to-end interface.</p>
<pre><code class="language-C++">class HoughTransform {
    // ..
};

class ImageFilter {
    // ...
};

class NeuralNetwork {
    // ...
}; 

struct OCRFacade {
    std::string textFromImage(const cv::Mat&amp; img) const {
        // ...
        // Put all the individual modules together
    }
};
</code></pre>
<p>A facade doesn't need to simplify usage of multiple modules, it can just be used to simplify a single module's interface as well.</p>
<h3 id="decorator"><a class="header" href="#decorator">Decorator</a></h3>
<p>A decorator adds functionality to a polymorphic object by wrapping itself around the object. The decorator itself also implements the same
interface as the object it wrapped. To a client, they have no idea if an object is decorated or not since they would interact with the concrete class
and decorated class through the same abstraction.</p>
<pre><code class="language-C++">class Port {
public:
    virtul ~Port() = default;
    virtual void write(const std::vector&lt;char&gt; &amp; data)  = 0;
    virtual std::vector&lt;char&gt; read() = 0;
};

class GzipDecorator : public Port {
    std::unique_ptr&lt;Port&gt; port
public:
    explicit GzipDecorator(std::unique_ptr&lt;Port&gt; &amp;&amp; port) : port(std::move(port)) {}

    void write(const std::vector&lt;char&gt; &amp; data) {
        auto newData = gzipCompress(data);
        port-&gt;write(newData);
    }

    std::vector&lt;char&gt; read() {
        auto data = port-&gt;read();
        return gzipDecompress(data);
    }    

};
</code></pre>
<p>If you used Java, you may be familiar with the <code>BufferedWriter</code> class.
That is a decorator that adds a buffer to a Writer.
It is also a writer itself.</p>
<p>Decorators can be used with factories, so the client doesn't have to know
how the abstraction is decorated.</p>
<h3 id="composite--flyweight"><a class="header" href="#composite--flyweight">Composite + Flyweight</a></h3>
<p>A composite is like a decorator, but instead of adding more functionality, it adds more objects.</p>
<p>Consider you are developing a game and have a class <code>GameObject</code> which handles rendering,
and collision with objects in the game. This game might have multiple levels which you handle in the 
<code>Level</code> class. Now a level, is essentially a giant game object. It must be rendered, and colliding with a level
would essentially mean colliding with a <code>GameObject</code> in that level. Thus, <code>Level</code> can be a composite of <code>GameObjects</code>
and implement the same interface as <code>GameObject</code>.</p>
<p>Let's go back to our <code>GameObject</code>. Let's say each one has its own 3D model. Now what if want to have a bunch of the same type of object
(say the same type of House) in the game? Well, naively, we can construct multiple instances of <code>GameObject</code>, but then we'd get multiple copies
of the 3D model even though all the houses have the same one. This is where Flyweight comes in. Instead of having one instance of the class per game object,
we can have one instance of <code>GameObject</code> for each type of game object. The <code>GameObject</code> class can keep track of all the locations it should be,
and simply render itself and do collision detection on itself multiple times when those methods are called.</p>
<h3 id="observer--mediator"><a class="header" href="#observer--mediator">Observer + Mediator</a></h3>
<p>Consider you have a UI class that needs to notify the program logic of events on the UI.
You could have the UI directly call methods in different classes that need to be notified of events,
but what if you create a new module that needs to listen for UI events? With the current approach,
the UI will need to be changed.</p>
<p>Instead, let's call the UI a Subject, and the modules that need to notified of changes in the Subject, Observers.</p>
<pre><code class="language-C++">class Observer {
public:
    virtual ~Observer() = default;
    virtual void notify(const Event &amp; e) = 0;
};

class Subject {
    std::vector&lt;std::reference_wrapper&lt;Observer&gt;&gt; observers;
public:
    virtual ~Subject() = default;
    
    /// Requires `o` outlive this subject
    void add_listener(Observer &amp; o) {
        observers.emplace_back(std::ref(o));
    }

protected:
    void notify_all(const Event &amp; e) {
        for(auto o : observers) {
            o.get().notify(e);
        }
    }
};

class UI : public Subject {}
class Listerner1 : public Observer {}
class Listernr2 : public Observer {}

UI ui;
Listener1 one;
Listener2 two;
ui.add_listener(one);
ui.add_listener(two);
</code></pre>
<p>The <code>Event</code> object is simply an object to encapsulate information about what event was raised.
We can expand on this structure by providing a two-way channel so that an Observer could tell the Subject when it's being deleted so
that an Observer need not outlive the subject.</p>
<p>The Mediator pattern is a special case of the Observer patten when a Subject ony supports one observer listening for events. This observer
is called the mediator.</p>
<p>An expansion on this structure is publisher/subscriber architecture. In this architecture, the subject would be the publisher,
and observers would be the subscribers. Publisher/subscriber architecture typically allows multiple publishers.
Events are typically published on a message channel, which is an intermediary module, process, or program that sends the messages
to the subscribers. Publisher/subscriber architecture is basically the Observer pattern but along a stronger boundary.
While Observer is typically implemented to have different modules communicate, publisher/subscriber architecture typically
facilitates communication of components that are different processes, threads, programs, or even on different machines.</p>
<h3 id="command"><a class="header" href="#command">Command</a></h3>
<p>The command pattern is basically a callable object. In our previous Observer example, we had an <code>Event</code> object which encapsulated information
about the event raised. Let's say that, instead of passing state, we passed instructions (code) on the action to perform. This is basically the
Command pattern.</p>
<h3 id="state"><a class="header" href="#state">State</a></h3>
<p>State is a pattern to help implement FSM (finite state machines) by encapsulating each FSM node with an object.
Each FSM state object would implement an abstract state interface. Behavior is then controlled by the FSM
delegating actions to the abstract state interface. The concrete class receiving these delegated function calls
changes depending on the current state of the FSM. State transitions in the FSM would be implemented by changing the concrete
state implementation behind the interface.</p>
<p>Take a Window class for example. A window can be open, minimized, maximized, and closed.
Depending on the current window state, behavior of the minimize, maximize, and close buttons changes.
Each of these three can be a concrete window state class.
The state class will handle behavior of the operations, as well as state transitions to other states.</p>
<pre><code class="language-C++">class Window {
    class WindowState {
    public:
        virtual ~WindowState() = default;
        virtual void maximize() = 0;
        virtual void minimize() = 0;
        virtual void close() = 0;
    protected:
        Window * context;

        explicit WindowState(Window * wind) : context(wind) {}

        void transition(std::unique_ptr&lt;WindowState&gt; &amp;&amp; newState) {
            context-&gt;state = std::move(newState);
        }
    };
    
    std::unique_ptr&lt;WindowState&gt; state;
    
public:
    Window() {
        state = std::make_unique&lt;MaxWindowState&gt;(this);
    }

    void maximize() {
        state-&gt;maximize();
    } 

    void minimize() {
        state-&gt;minimize();
    } 

    void close() {
        state-&gt;close();
    } 
};

class MaxWindowState : public WindowState {
public:
    explicit MaxWindowState(Window * ctx) : WindowState(ctx) {}

    void maximize() override {}
    void minimize() override {
        context-&gt;// minimize
        transition(std::make_unique&lt;MinWindowState&gt;(context));
    }
    void close() override {
        // ...
        transition(std::make_unique&lt;CloseWindowState&gt;(context));
    }
};

class MinWindowState : public WindowState {
  public:
      explicit MinWindowState(Window * ctx) : WindowState(ctx) {}
  
      void maximize() override {
          // ...
          transition(std::make_unique&lt;MaxWindowState&gt;(context));
      }
      void minimize() override {}
      void close() override {}
  };

class CloseWindowState : public WindowState {
public:
    explicit CloseWindowState(Window * ctx) : WindowState(ctx) {}

    void maximize() override {}
    void minimize() override {}
    void close() override {}
};
</code></pre>
<p>A naive approach to implementing a state machine could be to use an <code>enum</code> to represent the current state,
and use switch statements to control behavior based on the current state. This can work, however if, like above,
the state transition depends on both the input and current state, then we'd have nested switch statements in every
method! Not only is that a lot of code duplication, it's super ugly and takes a lot of space.</p>
<h3 id="visitor"><a class="header" href="#visitor">Visitor</a></h3>
<p>The goal of a visitor is to cut down on switches when behavior depends on 2 or more factors.
When applying the visitor pattern, we typically have two hierarchies: a hierarchy of nodes and visitors.
A node accepts a visitor. Using these two hierarchies, we can have unique behavior for each node-visitor combination.</p>
<p>Consider we have three credit card classes, normal, business, and gold. Now also consider we have three
types of purchases: services, consumer goods, and capital goods. We want each credit card and purchase
type combination to have different discounts. Let's use the Visitor pattern to do this in an OOP way
that avoids nested switches or nested if sequences.</p>
<pre><code class="language-C++">// Node heirarchy
class CreditCard {
public:
    ~CreditCard() = default;
    
    // visitor accept function
    virtual double getPurchaseDiscount(const PurchaseType &amp; p, int amount) = 0;
};

class RegularCard : public CreditCard {
public:
    double getPurchaseDiscount(const PurchaseType &amp; p, int amount) override {
        return p.visitRegular(this, amount);
    };
};

class BusinessCard : public CreditCard {
public:
    double getPurchaseDiscount(const PurchaseType &amp; p, int amount) override {
        return p.visitBusiness(this, amount);
    };
};

class GoldCard : public CreditCard {
public:
    double getPurchaseDiscount(const PurchaseType &amp; p, int amount) override {
        return p.visitGold(this, amount);
    };
};


// Visitor heirarchy
class PurchaseType {
public:
  virtual ~PurhcaseType() = default;

  virtual double visitRegular(RegularCard * card, int amount) = 0;
  virtual double visitBusiness(BusinessCard * card, int amount) = 0;
  virtual double visitGold(GoldCard * card, int amount) = 0;
};

class ServicePurhace : public PurchaseType {
public:

  double visitRegular(RegularCard * card, int amount) override {
        return 0;
  }

  double visitBusiness(BusinessCard * card, int amount) override {
        return std::min(amount * 0.001, 0.25);
  }

  double visitGold(GoldCard * card, int amount) override {
        return 0.08;
  }
};

class ConsumerPurhace : public PurchaseType {
public:

  double visitRegular(RegularCard * card, int amount) override {
        return 0.001;
  }

  double visitBusiness(BusinessCard * card, int amount) override {
        return 0;
  }

  double visitGold(GoldCard * card, int amount) override {
        return 0.15;
  }
};

class CapitalPurhace : public PurchaseType {
public:

  double visitRegular(RegularCard * card, int amount) override {
        return 0;
  }

  double visitBusiness(BusinessCard * card, int amount) override {
        return std::min(amount * 0.001, 0.8);
  }

  double visitGold(GoldCard * card, int amount) override {
        return 0.05;
  }
};
    
</code></pre>
<p>A concrete visitor visits a concrete node. The concrete node calls the corresponding visitor method.
The visitor method then performs the computation. This computation can depend on both the Visitor's type,
and the Node's type.</p>
<h3 id="iterator"><a class="header" href="#iterator">Iterator</a></h3>
<p>Already discussed</p>
<h3 id="template-method"><a class="header" href="#template-method">Template Method</a></h3>
<p>Let's say we had a complicated algorithm that spanned multiple steps like in our computer vision example.
As a reminder, we filtered the image, applied a Hough Transform, then used a neural network.
What if we wanted to run this algorithm on an embedded device, and change our algorithm to 
take less memory?</p>
<p>We can make this algorithm a template method, and make each step of the algorithm a virtual function so
subclasses can customize the behavior.</p>
<pre><code class="language-C++">class OCR {
    virtual cv::Mat filter(const cv::Mat &amp; img) = 0;
    virtual std::vector&lt;Lines&gt; findLines(const cv::Mat &amp; img) = 0;
    virtual std::string ocrStep(std::vector&lt;cv::Mat&gt; characterImages) = 0;
public:
    virtual ~OCR() = default;

    // this is the template method
    std::string operator()(const cv::Mat &amp; img) {
        const auto filtered = filter(img);
        const auto lines = findLines(filtered);
        // ...
        // compute line intersections
        return ocrStep(intersectionImages);
    }
};
</code></pre>
<p>Subclasses can now customize the function. This function is known
as a template method. The parts of the algorithm that don't change are kept in a base class
and hooks for customization are provided to subclasses.
This pattern basically applies the Open-Close Principle
to customize a computation. In C++, it's also quite similar to the NVI idiom.</p>
<h3 id="strategy"><a class="header" href="#strategy">Strategy</a></h3>
<p>Strategy is similar to template method, however instead of subclasses overriding customization hooks,
they can override the entire algorithm itself.</p>
<pre><code class="language-C++">class OCR {
public:
    virtual ~OCR() = default;
    virtual std::string operator()(const cv::Mat &amp; img) = 0;
};
</code></pre>
<p>In a way, abstract factory is to the factory function in the same way that strategy is to the template method.</p>
<h3 id="prototype"><a class="header" href="#prototype">Prototype</a></h3>
<p>Said simply: this pattern is to create a class hierarchy that has a polymorphic <code>clone()</code> function
to create a new instance of an object from another.</p>
<h3 id="singleton"><a class="header" href="#singleton">Singleton</a></h3>
<p>A singleton prevents multiple instances of itself from being created. This can be used in situations
where it doesn't make sense to have multiple instances of a module such as a <code>Logger</code> class. It does this
by making its constructor private, and only allowing access to the instance via a static method.
Singleton's can also have lazy initialization.
That means they don't create an instance until it's actually used during execution of the static <code>get</code> method.</p>
<p>This pattern must be used carefully. While a Singleton is slightly better than globals, the Singleton
itself is still a global object of sorts.</p>
<p>In C++, the order of initialization and de-initialized between global and static data is undefined.
Therefore, if we use Singleton <code>A</code> in the destructor of singleton <code>B</code>, it's possible that when <code>B</code> is destroyed,
the static data of <code>A</code> has already been deleted leaving us with undefined behavior. </p>
<p>Here's a simple example (that does not deal with the aforementioned dead reference problem)</p>
<pre><code class="language-C++">class LoggerSingleton {
    LoggerSingleton() = default; // private constructor
public:
    static const LoggerSingleton &amp; get() {
        static LoggerSingleton singleton; // only created once in first call to get
        return singleton;
    }

    void log(std::string_view str) {
        // ...
    }

};

LoggerSingleton::get().log(&quot;Algorithm started!&quot;);
</code></pre>
<p>A singleton can also use smart pointers too.</p>
<pre><code class="language-C++">class LoggerSingleton {
    LoggerSingleton() = default; // private constructor

    static std::unique_ptr&lt;LoggerSingleton&gt; logger;
public:
    static const LoggerSingleton &amp; get() {
        if (!logger) {
            logger = std::unique_ptr(new LoggerSingleton());
            // cannot use make_unique because
            // the constructor is private
        }
        return *logger.get();
    }

    void log(std::string_view str) {
        // ...
    }

};

LoggerSingleton::get().log(&quot;Algorithm started!&quot;);
</code></pre>
<h3 id="chain-of-responsibility"><a class="header" href="#chain-of-responsibility">Chain of Responsibility</a></h3>
<p>Imagine that you have a problem with your pay, and think that there a mistake being made. Your first move might be to talk to your manager.
Your manager understands your point, but can't do anything himself, so he talks to his HR contact. Your manager's HR rep finds that there is a policy
in place that overlooked a corner case that you so happen to be a part of. So the HR rep talks to their manager to see if this policy can be changed.
The HR rep's manager can't change it, but asks their manager to see if they can change it. We continue this process until
we get to the CEO or an HR Executive who is able to change the policy. This is basically a chain of responsibility.</p>
<p>We can raise an event in one module, and keep passing the event along until we get to a module that can handle it.</p>
<p>Let's say we click a <code>New Page</code> button. The button itself can't create a new page, so it passes the event to the toolbar.
The toolbar can't create one, so it passes the event to the widget it is a part of. The widget also can't create one, so it passes
the same event to the window. Now the window, creates a new page.</p>
<h3 id="repository"><a class="header" href="#repository">Repository</a></h3>
<p>This is a pattern for abstracting data access. Truthfully, I think using the term &quot;Repository Design Pattern&quot; just makes us sound smart,
but in reality this pattern boils down to the good old adage: &quot;program to an interface, not an implementation.&quot;</p>
<p>Instead of using a database directly, the repository abstracts the data behind an interface. This allows us to have different implementations
of the repository. This is especially important for testing. Abstracting data access being a repository allows us to have a mock database implementation.</p>
<p>Uncle Bob refers to this as a Gateway.</p>
<pre><code class="language-C++">class DataRepository {
public:
    virtual ~DataRepository() = default;
    virtual void save(std::string key, std::string value) = 0;
    virtual std::optional&lt;std::string&gt; read(std::string_view key) = 0;
};

class SQLiteRepo : public DataRepository {};
class MockRepo : public DataRepository {};
class RemoteSQLRepo : public DataRepository {};
</code></pre>
<p>The repository now forces us to separate business logic from data access logic. Code that needs a database
doesn't know or care what kind of database it's using. This allows us to change databases,
mock databases, and more without changing a single line of existing code.</p>
<p>This pattern is from Martin Fowler's <em>Patterns of Enterprise Application Architecture</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>We've actually seen macros and the preprocess in action before, but there's actually quite a lot that it can do. But first, let's do a brief overview of the compilation process.</p>
<p><code>constexpr</code> variables and functions should be preferred to macros. But sometimes macros can come in handy for preventing
code duplication in ways no C++ language feature can.</p>
<h3 id="the-compilation-process"><a class="header" href="#the-compilation-process">The Compilation Process</a></h3>
<ol>
<li>
<p><u>Preprocessing</u></p>
<p>The first step in the compilation process is preprocessing. I've alluded to this before, but what happens is the preprocessor,
goes through each source file. It's main functions are to expand out <code>#include</code> and <code>#define</code> directives
and handles include guards. The preprocessor doesn't actually know or care about C++ syntax: it operates on the literal text of your source code. 
The preprocessor is the program that takes header and code files, and basically spits out a bunch of code files.</p>
</li>
<li>
<p><u>Compilation</u></p>
<p>Next is the actual compilation. Each source file is compiled independently as a separate compilation unit. 
The output of the compiler are a <code>.obj</code> files or object files. If a compilation unit uses externally defined symbols 
(functions, variables, etc that are defined in another compilation unit), the compiler will simply assume all of them are
valid. The compiler can be broken up into many steps that really aren't important for us to know about.
However one thing it does is that, when enabled, it optimizes our code. The compiler can do some really cool things
such as precomputing literal expressions, reordering the machine instructions to promote as much parallelism as possible
in the CPU pipeline, inline functions, unroll loops, and so much more I have yet to learn about.</p>
</li>
<li>
<p><u>Linking</u></p>
<p>Finally, the linker links together all the object files into a library or executable. The linker is what resolves the
external symbols in each object file.</p>
</li>
</ol>
<p>All of these 3 steps are handled by three completely different programs. This allows us to swap any of them without regard for the others. Each step in the compilation process doesn't know or care about how the other steps are being caried out.</p>
<h3 id="macros-1"><a class="header" href="#macros-1">Macros</a></h3>
<p>A macro is defined using the <code>#define</code> directive. 
When the preprocessor sees a <code>#define</code> directive, it will then replace all subsequent usages of the macro with the <strong>text</strong> that the macro has been defined to be.
Remember that the preprocessor happens before compilation, so at this point all of the source code is just that, source code.
We typically use <code>ALL_CAPS_WITH_UNDERSCORES</code> to define macros so that they stand out in code and make us wary of their dangers.</p>
<pre><code class="language-C++">#define MY_NUM 10
#define HIS_NUM 2 + 5

const auto my_var = std::pow(MY_NUM, 4);
// compiler sees: std::pow(10, 4)

const auto the_num = MY_NUM * HIS_NUM;
// compiler sees: 10 * 2 + 5
</code></pre>
<p>Macros are not stored anywhere. They incur no cost of allocating data.</p>
<p>Notice <code>the_num</code> takes on a value of <code>25</code>, not <code>70</code> which would be the value if <code>MY_NUM</code> and <code>HIS_NUM</code> were constants or variables.
This is because, the text of <code>MY_NUM</code> and <code>HIS_NUM</code> are inserted into the code, no computations are done.
The preprocessor has no idea what <code>2 + 5</code> even means.
Therefore, it's common to surround macro definitions in parenthesis to ensure they interpretted as a single value (assuming that is the intention).</p>
<p>Another downside of macros is that during debugging, you don't get to see the name of the macro when it is used. The debugger sees what the compiler sees: magic constants.</p>
<p>We can use macros inside other macros. During macro expansion, the result of an expansion is then rescanned and the preprocessor will expand any macros used inside the definition of another macro.</p>
<pre><code class="language-C++">#define A 1
#define B A + A + 5
#define C B * B

const auto f = C;
// compiler sees: 1 + 1 + 5 * 1 + 1 + 5
</code></pre>
<p>Macros can take input parameters, which make them look and sort of act like functions. The parameters to a function macro are macros themselves and are expanded just like any other macro.</p>
<pre><code class="language-C++">#define ADD(X, Y) (X + Y)

const auto b = ADD(100, 300);
//compiler sees (100 + 300)

const auto c = ADD(10, 2) * ADD(2, 4);
// use of parenthesis in the ADD macro so that this eventually becomes 54
// as if this were a function
</code></pre>
<p>Now what about this:</p>
<pre><code class="language-C++">#define MUL(X, Y) (X * Y)

MUL(10 + 2, 2)
</code></pre>
<p>As you might have guessed, this produces the text <code>(10 + 2 * 2)</code> and not <code>12 * 2</code>.
To prevent this, it's also common to put parenthesis around macro parameters too.</p>
<p>If a macro needs to be multiple lines, we can add a backslash at the end of the line and continue to the next line.</p>
<pre><code class="language-C++">#define pow(BASE, EXP, RES) {\
    int exp = EXP;\
    RES = 1;\
    while(exp-- &gt; 0) {\
        RES = RES * (BASE);\
    }\
}

auto num = 1;
pow(10, 4, num);
/* Expands to:

{
    int exp = 4;
    num = 1;
    while(exp-- &gt; 0) {
        num = num * (10);
    }
}

*/

</code></pre>
<p>Now let's talk about times when we might actually find the macro useful. Used inside a macro &quot;function&quot;,
<code>#</code> will stringify an argument (ie. turn it into a string), no matter what is is. <code>##</code> will concatenate two tokens into another token.</p>
<pre><code class="language-C++">#define LOG(VAR) std::cout &lt;&lt; #VAR &lt;&lt; &quot;is: &quot; &lt;&lt; (VAR) &lt;&lt; std::endl

LOG(hello);
// prints to the console &quot;hello is: &quot; followed by the value of the variable hello

#define LASSERT(ASSERT_TYPE, X, Y, MSG)\
    ASSERT_##ASSERT_TYPE(X, Y) &lt;&lt; (MSG)

LASSERT(EQ, 5, 4, &quot;Assert test&quot;);
// expands to:
// ASSERT_EQ(5, 4) &lt;&lt; &quot;Assert test&quot;
// where ASSERT_EQ is another macro
</code></pre>
<p>Arguments are substituted, then expanded, then we finally rescan for any other macros.</p>
<p>Consider the following:</p>
<pre><code class="language-C++">#define STRFY(X) #X
#define CONCAT(X, Y) X##Y
#define STRFY2(X) STRFY(X)

STRFY(CONCAT(1, 2));
/*
1. Substitude: 
    #CONCAT(1, 2)
    &quot;CONCAT(1, 2)&quot;
2. Expand: Nothing to expand
3. Rescan: Nothing to rescan



&quot;CONCAT(1, 2)&quot;
*/

STRFY2(CONCAT(1, 2));
/*
1. Substitude:
    STRFY(CONCAT(1, 2))
2. Expand:
    STRFY(1##2)
    STRFY(12)
3. Rescan:
    3a. Substitude:
        #12
        &quot;12&quot;
    3b. Expand: nothing to expand
    3c. Rescan: nothing to rescan


&quot;12&quot;
*/
</code></pre>
<p>So we see that operating on the result of a macro requires indirection, because an expansion is rescanned for further macros
<em>last</em>. This is basically oppposite programming languages which evaluate their arguments <em>first</em>.</p>
<p>Macros can also take a variable amount of arguments. These are known as variadic macros. Arguments are separated with commas, and these arguments are &quot;stored&quot; in the macro <code>__VA_ARGS__</code> which expands to the literal comma separated list of arguments that were passed into the function.</p>
<pre><code class="language-C++">#define IVEC(...) std::vector&lt;int&gt;{__VA_ARGS__}

IVEC(20.3, myNum, foo(bar));
//expands to:
// std::vector&lt;int&gt;{20.3, myNum, foo(bar)}
</code></pre>
<p>Combining this with modern variadic templates can produce pretty powerful stuff. Here's an example of a macro that logs a series
of arguments, and tells us the variable name as well as the value of the variable.</p>
<pre><code class="language-C++">/**
 * Prints out names[idx] along with f
 * Then recurses by calling log_var_helper and incrementing idx
 * Basically, this unpacks the parameter pack and matches each argument with each
 * member in the names vector
 */
template&lt;int idx, typename First, typename ...Args&gt;
void log_var_helper(const std::vector&lt;std::string&gt;&amp; names, First&amp;&amp; f, Args&amp;&amp;... args) {
	std::cout &lt;&lt; names[idx] &lt;&lt; &quot;: &quot; &lt;&lt; std::forward&lt;First&gt;(f) &lt;&lt; &quot;\n&quot;;
	if constexpr (sizeof...(Args) &gt; 0)
		log_var_helper&lt;idx + 1&gt;(names, std::forward&lt;Args&gt;(args)...);
}

/**
 * Requires names be a comma separated string, with the same amount
 * of elements as arguments passed
 */ 
template&lt;typename ...Args&gt;
void log_vars(const char* names, Args&amp;&amp;... args) {
	std::vector&lt;std::string&gt; var_names;
	std::stringstream ss(names);
	std::string name;
	while (std::getline(ss, name, ',')) {
		var_names.emplace_back(name.substr(name.find_first_not_of(' ')));
        //split string using the comma as a delimiter
        //  trimming away space in the beginning since the stringified arguments contain space
	}
	log_var_helper&lt;0&gt;(var_names, std::forward&lt;Args&gt;(args)...);

}

#define STRFY(X) #X
#define LOG(...) log_vars(#__VA_ARGS__, __VA_ARGS__)
// could also use STRFY(__VA_ARGS__) as first parameter

int hello = 0;
int goodbye = 10;
auto str = &quot;My name&quot;;
std::string b = &quot;Sir&quot;;
char f = 'f';
LOG(hello, goodbye, str, b, f, 10 + 2);

/* Prints

hello: 0
goodbye: 10
str: My name
b: Sir
f: f
10 + 2: 12
*/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-resources"><a class="header" href="#other-resources">Other Resources</a></h1>
<ul>
<li><a href="https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">Stack Overflow's C++ Book List</a></li>
</ul>
<h3 id="basics-1"><a class="header" href="#basics-1">Basics</a></h3>
<ul>
<li>A Tour of C++ by Bjarne Stroustrup</li>
</ul>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<ul>
<li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C++ Core Guidelines by Herb Sutter and Bjarne Stroustrup</a></li>
<li><a href="https://www.fluentcpp.com/">Fluent C++</a></li>
<li><a href="https://herbsutter.com/gotw/">Herb Sutter's GOTW</a></li>
<li>Effective C++, More Effective C++, and Effective Modern C++ by Scott Meyers</li>
</ul>
<h3 id="intermediate"><a class="header" href="#intermediate">Intermediate</a></h3>
<ul>
<li>Exceptional C++ by Herb Sutter</li>
<li>C++ Coding Standards</li>
</ul>
<h3 id="swe"><a class="header" href="#swe">SWE</a></h3>
<p>I'll be honest, I think these four were life-changers for me.
Part of that could be <em>when</em> I read them, but I still would highly encourage you to take a look at them when you get a chance.</p>
<ul>
<li>Gang of Four Design Patterns</li>
<li>Pragmatic Programmer</li>
<li>Clean Code</li>
<li>Clean Architecture</li>
<li>Kent Beck's <em>Test Driven Development by Example</em></li>
</ul>
<h3 id="specifics"><a class="header" href="#specifics">Specifics</a></h3>
<ul>
<li>Concurrency - C++ Concurrency in Action by Anthony Williams</li>
<li>Generic Programming - Modern C++ Design by Andrei Alexandrescu</li>
</ul>
<hr />
<blockquote>
<p>&quot;Our passion for learning ... is our tool for survival.&quot;</p>
<p>- Carl Sagan</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
