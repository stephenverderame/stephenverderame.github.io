<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Friends and Overloads - Excursion through C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded "><a href="../intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="../guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="../basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="../basics/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="../oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../oop/overloads.html" class="active"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="../oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="../oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="../oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="../oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="../oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="../exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="../exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="../pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="../pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="../pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="../pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="../pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="../move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="../move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="../move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="../templates/intro.html"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="../templates/concepts.html"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="../templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="../templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="../templates/variadic.html"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="../templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="../functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functional/lambdas.html"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="../functional/functional_types.html"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="../functional/algorithm.html"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="../more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="../more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="../more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="../more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="../more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/locks.html"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="../concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="../concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="../concurrency/atomic.html"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="../concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="../cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="../testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="../testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="../testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="../testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="../testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="../testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="../design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="../resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h1>
<p>Let's first create a class <code>Rational</code> to see an example of overloading:</p>
<pre><code class="language-C++">class Rational {
    int num, den;
public:
    Rational(int numerator, int denominator) : num(numerator), den(denominator) {}

    Rational(int numerator) : Rational(numerator, 1) {}
    // forward call to a different constructor

    Rational(const Rational &amp; other) : num(other.num), den(other.den) {}
    // copy constructor
};

</code></pre>
<p>This class has two private integers and 3 constructors. 
The first is a constructor that passes in the values for <code>num</code> and <code>den</code>. 
The second is a conversion constructor from <code>int</code>. 
You could also have given <code>denominator</code> a default argument like so: <code>Rational(int numerator, int denominator = 1)</code>. 
Both cases allow for implicit conversion to <code>Rational</code> from <code>int</code> (and types that implicitly convert to <code>int</code>) since we don't use the <code>explicit</code> keyword. 
The third is a special kind of constructor known as a <code>copy</code> constructor. We'll talk more about this later, but basically it allows us to create a new <code>Rational</code> by copying (and not modifying) an existing one.</p>
<pre><code class="language-C++">Rational r = 5; // invoke constructor 2
auto r2 = r; // copy constructor
Rational r3(10); // ctor 2
Rational r4{20}; // ctor 2
Rational r5(10, 2); // ctor 1
Rational r6{20, 10}; //ctor 1
</code></pre>
<p>Constructors can use <code>()</code> or <code>{}</code>. This is to avoid <em>the most vexing parse</em>. Consider the following ambiguous line:</p>
<pre><code class="language-C++">Bar bar(FooBar());
</code></pre>
<p>This can be interpreted two ways: as a variable definition for <code>bar</code> which is passed a new instance of <code>FooBar</code> in its constructor,
or a function declaration for <code>bar</code> which returns an object of type <code>Bar</code> and accepts a pointer to a function that takes no input and
returns a <code>FooBar</code> object. The standard dictates that the latter interpretation must be chosen. Braces allow us to avoid
this issue: <code>Bar bar(FoorBar{})</code> or <code>Bar bar{FooBar()}</code>.</p>
<p>Back to overloading: we have already seen how to overload functions, but we can also overload operators as well.</p>
<p>Binary operator overloads take two arguments (the left and right operand), and unary operators take one. 
If the two arguments are different types, then you'd have to define two overloads in order for the operator to be commutative. 
One overload has type <code>x</code> as the left operand (first arguments) and type <code>y</code> as the right (second arguments),
and the other is the opposite with <code>y</code> for the left operand (first arg) and <code>x</code> as the right.</p>
<p>But first, it's important to realize that methods (member functions) of a class have an implicit first argument that is the context object for that function. 
So if you define a binary operator overload as a member function, the left argument will be an instance of the class.</p>
<p>Let's define the assignment operator to allow updating our object.</p>
<pre><code class="language-C++">
    //...

    Rational&amp; operator=(int num) {
        this-&gt;num = num;
        den = 1;
        return *this;
    }

    Rational&amp; operator=(const Rational &amp; num) {
        this-&gt;num = num.num;
        den = num.den;
        return *this;
    }
};
</code></pre>
<pre><code class="language-C++">Rational r = 10;
r = 20; // assignment op 1
const Rational r2(5, 2);
r = r2; //assign 2
</code></pre>
<p>All methods of a class have a <code>this</code> pointer, which refers to the calling context of the method. 
This calling context is the implicit first argument of member methods. Therefore, <code>operator=</code> is a binary operator despite its overload appearing to only have one argument. 
Moreover, <code>operator=</code> typically returns a reference to the updated object; so we return <code>*this</code>, which dereferences the <code>this</code> pointer. 
Once again notice how <code>num</code> in the second overload is <code>const &amp;</code>. It is <code>const</code> since there is no need to mutate it, and we pass by reference to avoid extra copying (plus this is the idiomatic way of defining <code>operator=</code>). 
You may also notice the strange <code>-&gt;</code> operator. This is the pointer scope resolution operator, basically the dot operator for pointers. </p>
<p>Let's define basic arithmetic operations. 
I typically like to define arithmetic operators as free functions because it's slightly more clear what the type of the left operand is (otherwise, the left operand is the implicit first argument <code>this</code>). 
Let's look at both ways:</p>
<pre><code class="language-C++">    // ...
    // member method
    Rational operator+(const Rational &amp; other) const {
        return {num * other.den + other.num * den, den * other.den};
        // No need to specify &quot;Rational {...}&quot; because the compiler can see
        // that this function returns a Rational
    }

};

//free function
Rational operator*(const Rational &amp; a, const Rational &amp; b) {
    return { a.num * b.num, a.den * b.den };
}

</code></pre>
<p>Since we are creating a new <code>Rational</code> we declare the member function to be <code>const</code>, this way it takes <code>const this</code> as its implicit first argument.</p>
<p>Now you might be curious: &quot;Aren't <code>num</code> and <code>den</code> private members? How can we access them outside the class <code>Rational</code>?&quot; 
The answer is we can't. Well, not without declaring the function a <code>friend</code>. 
<code>friend</code> classes and functions are classes and functions do not have to be defined in the class scope, but are essentially part of the class they are friends with. 
They have access to all private, protected, and public members. 
They should be used sparingly, as it is the strongest coupling relation available. In this case, it's a good choice since we want <code>operator*</code> to behave like a member of the class itself.</p>
<p>Now as currently written, you would expect addition to be commutative, however:</p>
<pre><code class="language-C++">Rational r(5, 3);

auto r2 = r + 10; // good
r2 = 10 + r; // error
</code></pre>
<p>It's not! That's because, as defined, <code>operator+</code> expects its first argument to be a Rational object and member functions will not do implicit conversions on the implicit first argument. 
However, in the third line we pass an integer. Therefore, we'll need to define a free function which has <code>int</code> as the left-hand argument.</p>
<pre><code class="language-C++">Rational operator+(int a, const Rational &amp; b) {/*...*/}


Rational operator+(const Rational &amp; a, int b) {/*...*/} 
// equivalent to the operator+ we just defined as a member
</code></pre>
<p>Or, we can just define one free function which takes <code>Rational</code> since <code>int</code> can be implicitly converted to <code>Rational</code>.</p>
<p>Let's also make <code>Rational</code> able to be printed to <code>cout</code>. For that we can overload <code>operator&lt;&lt;</code>, which takes a reference to an <code>std::ostream</code>, a super type of the class that <code>std::cout</code> is an instance of.</p>
<pre><code class="language-C++">std::ostream&amp; operator&lt;&lt;(std::ostream &amp; stream, const Rational &amp; r) {
    stream &lt;&lt; r.num &lt;&lt; &quot;/&quot; r.den;
    return stream;
}
</code></pre>
<p>Two final overloads I want to give special attention to are the increment/decrement operators. 
Both of these have a postfix and prefix version which do different things. 
The prefix version directly increments the object while the postfix version makes a copy, increments the object, and returns the copy made. 
Therefore, unless you need the old value, it's good practice to use the prefix increment/decrement by default. 
Furthermore, to make compiler optimizations easier, it's smart to implement the postfix operators in terms of their prefix counterparts (it's good code reuse as well).</p>
<pre><code class="language-C++">    //...
    Rational&amp; operator++() {
        num += den;
        return *this;
    }

    //postfix increment
    Rational operator++(int) {
        const auto cpy = *this;
        ++(*this);
        return cpy;
    }
};
</code></pre>
<p>Here's a completed Rational class:</p>
<pre><code class="language-C++">#include &lt;numeric&gt;
#include &lt;ostream&gt;

class Rational {
    // Invariant: num and den are in simplest form
    int num, den;
    friend Rational operator+(const Rational&amp;, const Rational&amp;);
    friend Rational operator*(const Rational&amp;, const Rational&amp;);
    friend Rational operator/(const Rational&amp;, const Rational&amp;);
    friend Rational operator-(const Rational&amp;, const Rational&amp;);
    friend bool operator==(const Rational&amp;, const Rational&amp;);
    friend bool operator&lt;=(const Rational&amp;, const Rational&amp;);
    friend bool operator&gt;=(const Rational&amp;, const Rational&amp;);
    friend bool operator&lt;(const Rational&amp;, const Rational&amp;);
    friend bool operator&gt;(const Rational&amp;, const Rational&amp;);
    friend bool operator!=(const Rational&amp;, const Rational&amp;);
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Rational&amp;);
public:
    Rational(int numerator, int denominator) : num(numerator / std::gcd(numerator, denominator)),
        den(denominator / std::gcd(numerator, denominator)) {}

    Rational(int numerator) : Rational(numerator, 1) {}
    // forward call to a different constructor

    Rational(const Rational&amp; other) : num(other.num), den(other.den) {}
    // copy constructor

    Rational&amp; operator=(int num) {
        this-&gt;num = num;
        den = 1;
        return *this;
    }

    Rational&amp; operator=(const Rational&amp; num) {
        this-&gt;num = num.num;
        den = num.den;
        return *this;
    }

    Rational&amp; operator++() {
        num += den;
        return *this;
    }

    //postfix increment
    Rational operator++(int) {
        const auto cpy = *this;
        ++(*this);
        return cpy;
    }

    Rational&amp; operator--() {
        num -= den;
        return *this;
    }

    //postfix decrement
    Rational operator--(int) {
        const auto cpy = *this;
        --(*this);
        return cpy;
    }

    


};

Rational operator+(const Rational&amp; a, const Rational&amp; b) {
    return { a.num * b.den + b.num * a.den, a.den * b.den };
}

Rational operator-(const Rational&amp; a, const Rational&amp; b) {
    return { a.num * b.den - b.num * a.den, a.den * b.den };
}

Rational operator/(const Rational&amp; a, const Rational&amp; b) {
    return a * Rational { b.den, b.num };

}

Rational operator*(const Rational&amp; a, const Rational&amp; b) {
    return { a.num * b.num, a.den * b.den };
}

bool operator==(const Rational&amp; a, const Rational&amp; b) {
    return a.num == b.num &amp;&amp; a.den == b.den;
}

bool operator!=(const Rational&amp; a, const Rational&amp; b) {
    return !(a == b);
}

bool operator&lt;=(const Rational&amp; a, const Rational&amp; b) {
    return a &lt; b || a == b;
}

bool operator&gt;=(const Rational&amp; a, const Rational&amp; b) {
    return a &gt; b || a == b;
}

bool operator&lt;(const Rational&amp; a, const Rational&amp; b) {
    return a.den &gt; b.den || (a.den == b.den &amp;&amp; a.num &lt; b.num);
}

bool operator&gt;(const Rational&amp; a, const Rational&amp; b) {
    return !(a &lt; b) &amp;&amp; a != b;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Rational&amp; r)
{
    stream &lt;&lt; r.num &lt;&lt; &quot;/&quot; &lt;&lt; r.den;
    return stream;
}
</code></pre>
<p>In C++20, we can let the compiler generate all those comparison functions for us by just defining a single function: <code>operator&lt;=&gt;</code>.</p>
<hr />
<h3 id="possible-exercises"><a class="header" href="#possible-exercises">Possible Exercises</a></h3>
<ol>
<li>Create a Vec3d class (or whatever you'd like to call it) which stores 3 doubles and represents a 3D vector in the Cartesian plane. It should support the following operations:
<ul>
<li><code>operator+</code> and <code>operator-</code> (for vectors and scalars)</li>
<li><code>operator*</code> and <code>operator/</code> for scalars</li>
<li><code>operator*</code> for vectors which will be the dot product</li>
<li><code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code></li>
<li><code>operator+=</code>, <code>operator-=</code> for vectors and scalars</li>
<li><code>operator[]</code> where index 0 gets the <code>x</code> value, index 1 <code>y</code>, and 2 <code>z</code>.
<ul>
<li>Out of bounds is undefined behavior, and you can do (or not do) whatever you see fit</li>
</ul>
</li>
<li>Its data may or may not be encapsulated</li>
<li>Separate the interface and implementation into a header and code file
<ul>
<li>Can you do this without any include directives in the header file?</li>
</ul>
</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../oop/intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../oop/adt.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../oop/intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../oop/adt.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
