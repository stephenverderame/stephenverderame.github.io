<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tuple, Variant, Optional - Excursion through C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded "><a href="../intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="../guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="../basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="../basics/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="../oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../oop/overloads.html"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="../oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="../oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="../oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="../oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="../oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="../exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="../exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="../pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="../pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="../pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="../pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="../pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="../move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="../move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="../move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="../templates/intro.html"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="../templates/concepts.html"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="../templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="../templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="../templates/variadic.html"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="../templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="../functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functional/lambdas.html"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="../functional/functional_types.html" class="active"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="../functional/algorithm.html"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="../more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="../more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="../more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="../more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="../more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/locks.html"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="../concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="../concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="../concurrency/atomic.html"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="../concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="../cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="../testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="../testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="../testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="../testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="../testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="../testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="../design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="../resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tuple"><a class="header" href="#tuple">Tuple</a></h1>
<p>Like <code>std::array</code>, <code>std::tuple</code> is a fixed size container, but the difference is it can hold different types. A tuple can be created by enumerating the values it will store in its constructor or using one of the following:</p>
<ul>
<li><code>std::tie()</code>
<ul>
<li>Creates a tuple of lvalue references</li>
</ul>
</li>
<li><code>std::make_tuple()</code>
<ul>
<li>General usage way to make a tuple. Same idea as <code>std::bind</code>, arguments are copy or move constructed.</li>
</ul>
</li>
<li><code>std::forward_as_tuple()</code>
<ul>
<li>Creates a tuple of references, lvalue references if the argument is a lvalue, rvalue references if it's a rvalue.</li>
</ul>
</li>
</ul>
<p>Accessing a tuple uses <code>std::get</code>, which takes either a type or index as the template argument. 
Therefore, you can only use <code>std::get</code> if you know the type or index you want to get at compile time. 
We can use the template <code>std::tuple_size_v&lt;T&gt;</code> to get the size of a tuple, and we can use <code>std::tuple_element_t&lt;I, Tuple&gt;</code> to get the type of index <code>I</code> of tuple <code>Tuple</code>.</p>
<pre><code class="language-C++">std::tuple&lt;int, char, double&gt; myTuple{5, 'c', 83.0};

auto tuple2 = std::make_tuple(23, true, 'a', 5.f);
float f = std::get&lt;3&gt;(tuple2); // gets value at index 3, which is 5.f
bool b = std::get&lt;bool&gt;(tuple2); // gets the first bool in the tuple, which is true

constexpr auto sz = tuple_size_v&lt;decltype(tuple2)&gt;; // 4

using type_2 = tuple_element_t&lt;decltype(tuple), 2&gt;; // double

std::tuple&lt;float&amp;, bool&amp;&gt; t3 = std::tie(f, b);
// tuple holds lvalue references!
// what it refers to must outlive it

std::tuple&lt;bool&amp;, int&amp;&amp;, double&amp;&amp;&gt; t4 = std::forward_as_tuple(b, getInt(), 5.374);
auto c = std::get&lt;0&gt;(t4);
c = false;
 
</code></pre>
<p>What if we need to get a value from a tuple from an index computed at runtime? We can recursively call a template function that has the index as a template argument.</p>
<pre><code class="language-C++">template&lt;class Tuple, size_t N = 0&gt;
constexpr auto dynamicGet(const Tuple&amp; tuple, size_t index) 
    -&gt; std::enable_if_t&lt;N &lt; std::tuple_size_v&lt;Tuple&gt;, std::tuple_element_t&lt;Tuple, N&gt;&gt; 
{
    if (index == N)
        return std::get&lt;N&gt;(tuple);
    else
        return dynamicGet&lt;Tuple, N + 1&gt;(tuple, index);
}

const auto t = std::make_tuple(10, 20);
const auto r = dynamicGet(t, 1);
</code></pre>
<p>Using this function requires the compiler to instantiate a new <code>dynamicGet</code> for the specific tuple type for all indices of the tuple. 
How this works is that we first call <code>dynamicGet&lt;Tuple, 0&gt;</code>. If the runtime index <code>index</code> is equal to the compile time index of the function (<code>N</code>), then we call <code>std::get&lt;N&gt;</code>. 
Otherwise, we call the next <code>dynamicGet</code> function.</p>
<p>Tuples are copyable and moveable if all of their contents are copyable and moveable, respectively. 
Tuples cannot be modified. The only way to do this would be to swap two tuples of the same type. Furthermore, we can make larger tuples by concatenating existing tuples together with <code>std::tuple_cat</code>.</p>
<pre><code class="language-C++">std::tuple&lt;int, double, char&gt; t = std::make_tuple(5, 5.0, 'c');
std::tuple&lt;int, double, char&gt; t2;
// default construct able if each type it 
// holds is as well
t2.swap(t);
std::swap(t, t2);

std::tuple&lt;int, double, char, float, bool&gt; t3 = std::tuple_cat(t2, {500.f, false});
std::get&lt;3&gt;; // 500.f
</code></pre>
<p>The main usage of tuples is for passing or returning multiple things from a function. Returning a tuple should be preferred to output parameters. 
However, accessing the data via <code>std::get</code> is quite annoying. So we can use a <em>structured binding</em> to unpack a tuple. 
A structured binding unpacks a <code>std::tuple</code>, <code>std::array</code>, <code>std::pair</code>, or <code>struct</code>. Each member of a tuple is assigned to the corresponding name specified within the <code>[]</code> of the structured binding. 
The general syntax is as follows:</p>
<pre><code class="language-C++">auto [name_1, name_2, ..., name_n] = std::tuple&lt;type_1, type_2, ..., type_n&gt;();
</code></pre>
<p>The nth value in the tuple is assigned to the nth name in the structured binding. A structured binding must have the same number of names as values in the object being unpacked. 
If <code>auto</code> (or any form of <code>auto</code>) is used, the type of each name is deduced from the unpacking. If you manually specify the type, then all names must have the same type.</p>
<pre><code class="language-C++">struct Bar {
    std::string foo;
    unsigned fizz : 5;
    unsigned buzz : 27;
};

auto [foo, fizz, buzz] = Bar{&quot;Hello&quot;, 30, 120};
// unpacks a struct, left most name in binding corresponds to top left most member in struct definition

std::array myArray = {100, 200, 300};
int [a, b, c] = myArray;
// a = 100, b = 200, c = 300
</code></pre>
<p>Structured bindings make using tuples to return multiple things really easy:</p>
<pre><code class="language-C++">auto myFunc() {
    Person p;
    return std::make_tuple(p, 10);
    // person is copied
}

template&lt;typename T&gt;
auto getForward(T&amp;&amp; t) {
    return std::forward_as_tuple(t, 5);
    // 5 is moved
    // t is forwarded
}

auto [person, count] = myFunc();
// person has type Person
// count has type int

const Person p;
auto&amp;&amp; [p3, num] = getForward(p);
// p3 has type const Person&amp;
// num has type int&amp;&amp;
</code></pre>
<p>Another usage of tuples is to use them to pass arguments to functions via <code>std::apply</code>. <code>std::apply</code> takes a callable object and a tuple which will be unpacked as the arguments for that callable object.</p>
<pre><code class="language-C++">auto f = [](int a, int b){
    return a + b;
};
auto tup = std::make_tuple(50, 23);
auto res = std::apply(f, tup);
//res is 73
</code></pre>
<h1 id="optional"><a class="header" href="#optional">Optional</a></h1>
<p>An optional is a type that may contain a value. It's especially useful for returning something from a function that can fail. 
If an optional contains a value, that value is part of the optional's memory layout. That is to say the value it contains is not dynamically allocated. 
If the optional does not contain a value, that value has yet to be constructed and there is no memory reserved for it. 
Therefore, an optional provides practically no overhead to code that uses them regardless if they are empty or not.</p>
<p>An optional's <code>has_value()</code> member can be used to query if the optional contains a value, the optional is also convertible to <code>bool</code>. 
It has a default constructor that creates an empty optional, and an implicit conversion constructor to convert wrap an object of the contained type into a filled optional. 
We can use <code>operator*</code>, <code>operator-&gt;</code>, or the <code>value()</code> members to get access to the contained value of the optional. 
If the optional does not contain a value when one of these members are called, it throws <code>std::bad_optional_access</code>. 
Remember that dereferencing a <code>nullptr</code> is undefined behavior, however optionals provides a defined result when getting the data of an empty one.</p>
<pre><code class="language-C++">auto opt = std::make_optional(100);
if (opt) {
    std::cout &lt;&lt; *opt &lt;&lt; std::endl;
    // prints 100
}
struct Data {
    int32_t number;
    uint64_t id;
    int16_t fs[100];
};

std::vector&lt;Data&gt; dataFrames;

std::optional&lt;Data&gt; readFile(std::string_view s) {
    std::ifstream stream(s.data(), std::ios::binary);
    if (stream.is_open()) {
        Data d;
        stream.read(reinterpret_cast&lt;char*&gt;(&amp;d), sizeof(Data));
        return d;
    }
    return {}; // default construct, empty optional
}

if (auto result = readFile(&quot;data.bin&quot;); result) {
    // This is called init-if
    // the first statement is the initializer
    // the second is the condition that is tested

    const auto t = result-&gt;number;
    dataFrames.push_back(result.value());
}
</code></pre>
<p>We can construct an element directly in the containing optional with the <code>emplace()</code> member function. 
Furthermore, we can use <code>value_or()</code> to get a default value if one doesn't exist, and use <code>std::nullopt</code> to indicate an empty optional.</p>
<pre><code class="language-C++">std::optional&lt;int&gt; p = std::nullopt; // empty
int v = p.value_or(-1); // p is -1

p.emplace(100);
if (p != std::nullopt) {
    std::cout &lt;&lt; p.value() &lt;&lt; std::endl; // prints 100
    p.reset(); // makes it empty
}
</code></pre>
<p>Optionals are a great tool for error handling, especially when the error might be somewhat expected every now and again. 
For example, a user might enter an incorrect path and the system not being able to open the specified file.</p>
<h1 id="variant"><a class="header" href="#variant">Variant</a></h1>
<p>The Variant is a type safe union. It can hold one of the multiple types specified as template arguments. 
A possible usage of a variant is to return either an error message, or a result from a function. Like an optional, the variant's data is held directly within the variant so no dynamic allocation. 
Furthermore, it does not hold extra data besides the value that is currently stored within it. We can use <code>std::get</code> to get the specified type or index of the variant. 
If the variant does indeed hold that type, the value is returned. 
Otherwise, the exception <code>std::bad_variant_access</code> is thrown. Once again this requires us to know the type or index of the type we want at compile time. 
We can use the <code>std::holds_alternative&lt;T&gt;</code> function to check if the variant holds a value of type <code>T</code>.</p>
<pre><code class="language-C++">
std::variant&lt;int, char, std::string&gt; var = 'H';

if (std::holds_alternative&lt;std::string&gt;(var)) {
    // .. do something with the string
} else if (std::holds_alternative&lt;char&gt;(var)) {
    std::cout &lt;&lt; std::get&lt;char&gt;(var) &lt;&lt; std::endl; // prints 'H'
}
</code></pre>
<p>There is also the <code>std::get_if&lt;T&gt;</code> function which takes a pointer to a variant and returns a pointer to <code>T</code> if the variant contains <code>T</code>. 
Otherwise, the function returns <code>nullptr</code>.</p>
<pre><code class="language-C++">std::variant&lt;Data, std::string&gt; readData(std::string_view s) {
    std::ifstream stream(s.data(), std::ios::binary);
    if (stream.is_open()) {
        try {
            Data d;
            stream.read(reinterpret_cast&lt;char*&gt;(&amp;d), sizeof(Data));
            return d;
        } catch (const std::exception &amp; e) {
            return e.what();
        } catch (...) {
            return &quot;An unknown error occurred while reading file&quot;;
        }
    }
    return &quot;Could not open file&quot;;
}

auto v = readData(&quot;data.bin&quot;);
if (auto ptr = std::get_if&lt;Data&gt;(&amp;v); ptr) {
    Data cpy = *ptr;
    // ...
} else {
    std::cerr &lt;&lt; &quot;An error has ocurred: &quot; &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; std::endl;
}
</code></pre>
<p>Another way to determine what a variant holds besides <code>std::get_if</code> is the member function <code>index()</code> which returns the index of the currently held value's type.</p>
<pre><code class="language-C++">
std::variant&lt;std::string, std::vector&lt;char&gt;, std::vector&lt;unsigned char&gt;&gt; bytes;

if(bytes.index() == 1) {
    //do something with std::vector&lt;char&gt;
}

if(std::holds_alternative&lt;std::string&gt;(bytes)){
    auto str = std::get&lt;std::string&gt;(bytes);
    if(!str.empty()){
        bytes.emplace(std::vector{str[0]});
        // constructs a new value in-place
    }
} 
</code></pre>
<p>As shown in the example, variants also define the <code>emplace()</code> member function for constructing a value directly in the variant.</p>
<p>We can use <code>std::visit</code> to perform a function templated on the type the variant holds. 
Using <em>constexpr if</em> we can perform a different action based on what the variant holds. 
Constexpr if is an if statement that is evaluated at compile time. Thus, when using constexpr if, the compiler can determine which branch is taken and inline that choice directly in the code. 
This makes it look like there wasn't a conditional to begin with if you were to look at the compiled code.</p>
<pre><code class="language-C++">std::variant&lt;char, int, double&gt; getGpa();

auto variant = getGpa();
std::visit([](auto&amp;&amp; gpa) {
    using T = std::decay_t&lt;decltype(gpa)&gt;;
    if constexpr (std::is_same_v&lt;T, char&gt;) {
        printf(&quot;Letter scale\n&quot;);
    }
    else if constexpr (std::is_same_v&lt;T, int&gt;) {
        printf(&quot;Numeric scale\n&quot;);
    }
    else if constexpr (std::is_same_v&lt;T, double&gt;) {
        printf(&quot;4.0 scale\n&quot;);
    }
}, variant);
</code></pre>
<p>What <code>std::visit</code> does is call the supplied function passing in the value held by the variant. 
Notice the use of <code>auto&amp;&amp;</code>, which is essentially a universal reference because visit will pass in different types. So this lambda is essentially a template of sorts. 
A normal template function however wouldn't work, because you'd need to know which instantiation to call, and the fact that we don't have this information is one of the reasons we're using <code>std::visit</code> in the first place. 
<code>std::visit</code> essentially applies the <em>visitor</em> pattern. Here we use one function with constexpr-if to simulate having multiple overloads. 
We also need the <code>std::decay_t</code>, which will remove the reference if the function is passed an lvalue. <code>std::decay_t</code> also decays arrays into pointers, which is functionality not used in this example.</p>
<p>A variant cannot be empty, but if wanted it to be able to hold nothing, we can allow it to hold <code>std::monostate</code> which is basically an empty struct designed to indicate an empty variant. </p>
<pre><code class="language-C++">std::variant&lt;std::vector&lt;int&gt;, std::string, std::monostate&gt; var = std::monostate{};

if (std::holds_alternative&lt;std::monostate&gt;(var)) {
    // empty variant
}
</code></pre>
<h2 id="union"><a class="header" href="#union">Union</a></h2>
<p>I mentioned that <code>variant</code> is a type safe union. So you may be wondering what a union is. Well basically, it's the C way of holding a value of one or multiple types all within the same area of memory. 
All members of a union are stored in the same memory location, so a union only takes up the amount of space needed for its largest member.</p>
<pre><code class="language-C++">
union MyUnion {
    int num;
    std::string name;
    unsigned flag : 1;
    unsigned long long id;
};

MyUnion un;
un.name = &quot;Peach&quot;;
sizeof(MyUnion) == sizeof(std::string); // largest member

un.flag = 0;
</code></pre>
<p>A common usage for <code>union</code> is to set the memory as one type, and read it off as another to essentially perform a <code>reinterpret_cast</code>. 
This is called <em>type punning</em> and is <strong>undefined behavior</strong> in C++ (but not C). Thus, in C++, you should only read from a member that has the same type as the actual stored value. 
Given this, I cannot think of a situation where a union would be preferable to <code>std::variant</code>.</p>
<h1 id="any"><a class="header" href="#any">Any</a></h1>
<p><code>std::any</code> is another utility type similar to <code>variant</code>, <code>optional</code>, and <code>tuple</code>, but <code>any</code> holds only 1 value of <em>any</em> type, as the name may suggest. 
We can check if a <code>std::any</code> has a value via the <code>has_value()</code> member function. 
We can also get the <code>std::type__info&amp;</code> of the stored type via the <code>type()</code> member function. Mutating the <code>any</code> can be done with the assignment operator, <code>swap()</code>, or <code>emplace()</code> just like a variant.</p>
<pre><code class="language-C++">std::any any = 1;
std::cout &lt;&lt; any.type().name() &lt;&lt; std::endl;
//compiler dependent but likely &quot;int&quot;
any = 3.14;
std::cout &lt;&lt; any.type().name() &lt;&lt; std::endl;
//compiler dependent but likely &quot;double&quot;

if(any.has_value()){
    any.emplace&lt;std::string&gt;(&quot;something new&quot;);
}
</code></pre>
<p>Getting a value stored from an any can be done with <code>std::any_cast</code>. We can also construct an any with <code>std::make_any</code>. 
<code>any_cast</code> allows type safe retrieval of the value in the any. It will throw an exception if the RTTI of the type parameter and the stored value do not match.</p>
<pre><code class="language-C++">auto anything = std::make_any(20);

int n = std::any_cast&lt;int&gt;(anything);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../functional/lambdas.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../functional/algorithm.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../functional/lambdas.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../functional/algorithm.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
