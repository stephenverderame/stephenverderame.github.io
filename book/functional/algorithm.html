<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Algorithms - Excursion through C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded "><a href="../intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="../guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="../basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="../basics/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="../oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../oop/overloads.html"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="../oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="../oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="../oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="../oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="../oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="../exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="../exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="../pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="../pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="../pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="../pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="../pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="../move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="../move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="../move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="../templates/intro.html"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="../templates/concepts.html"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="../templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="../templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="../templates/variadic.html"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="../templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="../functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functional/lambdas.html"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="../functional/functional_types.html"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="../functional/algorithm.html" class="active"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="../more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="../more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="../more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="../more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="../more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/locks.html"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="../concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="../concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="../concurrency/atomic.html"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="../concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="../cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="../testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="../testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="../testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="../testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="../testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="../testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="../design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="../resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h1>
<p>STL algorithms are in the <code>&lt;algorithms&gt;</code> header. These are generic algorithms which operate on pairs of iterators (a start and end iterator). 
C++20 includes versions of these algorithms that operate on ranges and views. This is discussed more in the C++20 section
of the book, but ranges and views are basically like an abstraction over a pair of iterators.
Often times they will take a callable object to perform some computation. 
Whenever you write a for loop, the first though should be &quot;is there an algorithm which does this for me?&quot;. 
Generally, we want to use algorithms as much as possible because they help us avoid making simple indexing or iterator mistakes and are well tested. 
As we'll see later, some algorithms may also take an execution policy as their first argument. The execution policy changes their concurrency behavior. 
Thus, using STL algorithms, one parameter is all it takes to convert sequential code to concurrent code. 
I'll briefly discuss a few common ones, but more information can be found on the documentation of the algorithms library.</p>
<p>A predicate is a function that takes in an element and returns true if that element matches the criteria. 
A comparator is a function that takes in two arguments and returns true if the first argument should be ordered before the second.</p>
<p>If you are familiar with functional programming, some of the algorithms are very much like common operations in functional
languages such as <code>map</code> or <code>fold</code>. I indicate that in the following list with the phrase &quot;analogous to ...&quot; or &quot;similar to ...&quot;</p>
<ul>
<li><code>std::for_each(It begin, It end, Func f)</code> - analogous to <code>iterate</code>
<ul>
<li>Calls <code>f</code>, passing in the dereferenced iterator for all elements between <code>begin</code> and <code>end</code></li>
</ul>
</li>
<li><code>std::for_each_n(It begin, Size num, Func)</code> - analogous to <code>take</code>
<ul>
<li>Same as <code>for_each</code> but takes a number indicating the amount of elements to iterate through starting from <code>begin</code>.</li>
</ul>
<pre><code class="language-C++">std::array a = {600, 97, 3784, 474, 3, 906, 0};
std::for_each_n(a.begin(), 3, [](auto e) {
    std::cout &lt;&lt; e &lt;&lt; &quot;, &quot;;
});
// 600, 97, 3784, 
</code></pre>
</li>
<li><code>std::all_of</code>/<code>std::any_of</code>/<code>std::none_of</code> <code>(It begin, It end, Func pred)</code>
<ul>
<li>Iterates through and applies a predicate which takes the dereference of the iterator and returns a bool</li>
</ul>
</li>
<li><code>std::count(It begin, It end, T elem)</code>
<ul>
<li>Iterates through and counts how many elements equal <code>elem</code></li>
</ul>
</li>
<li><code>std::count_if(begin, end, pred)</code>
<ul>
<li>Same as <code>count</code> but counts how many times the predicate returns true</li>
</ul>
</li>
<li><code>std::find(begin, end, elem)</code>
<ul>
<li>Returns the iterator to the first element that equals <code>elem</code> or <code>end</code> if not found</li>
<li><code>std::find_if</code> is the same but takes a predicate instead of an element</li>
</ul>
</li>
<li><code>std::copy(begin, end, dstBegin)</code>
<ul>
<li>Copies elements from range to a new area beginning at <code>dstBegin</code>. Does not check whether <code>dstBegin</code> is valid or can support the amount of elements in the range</li>
<li><code>std::copy_if(begin, end, dstBegin, pred)</code> - similar to <code>filter</code>
<ul>
<li>Same as copy but only copies if the predicate returns true for that element</li>
</ul>
</li>
</ul>
</li>
<li><code>std::copy_backward(begin, end, dst)</code>
<ul>
<li>Same as copy but stores the elements in <code>dst</code> backwards</li>
</ul>
</li>
<li><code>std::move(begin, end, dst)</code>, <code>std::move_backward(begin, end, dst)</code>
<ul>
<li>Self explanatory</li>
</ul>
</li>
<li><code>std::fill(begin, end elem)</code>
<ul>
<li>Assigns <code>elem</code> to every iterator in the range</li>
<li><code>std::fill_n(begin, count, elem)</code></li>
</ul>
</li>
<li><code>std::generate(begin, end, f)</code>
<ul>
<li>Assigns the result of calling <code>f</code> to every iterator in the range</li>
<li><code>std::generate_n(begin, count, f)</code></li>
</ul>
<pre><code class="language-C++">std::vector&lt;int&gt; nums(100); // 100 integers
std::generate(nums.begin(), nums.end(), [count = 0]() mutable {
    return count++;
});

std::vector&lt;char&gt; letters;
std::generate_n(std::back_inserter(letters), 100, [](){ return 'A'; });
letters.size(); //100
</code></pre>
</li>
<li><code>std::transform(begin, end, [optional 2nd range begin], dstBegin, func)</code> - analogous to <code>map</code>, and <code>zip</code>
<ul>
<li>Iterates through a range or two, calls the function and stores the result of that function in the destination range</li>
<li>The second range must be at least as large as the first</li>
<li>Func takes in the underlying value of the iterator from the first range as the first argument, and if a second range is specified, the value of the second second as the second argument</li>
</ul>
<pre><code class="language-C++">std::vector a = {100, 200, 300};
std::array b = {100.0, 50.1, -300.67};
std::vector&lt;double&gt; out;

std::transform(a.begin(), a.end(), b.begin(), std::back_inserter(out),
    [](auto a, auto b) {
        return a + b;
    });
// out is {200.0, 250.1, -0.67}

// transform in-place is allowed
std::transform(a.begin(), a.end(), a.begin(),
    [](auto a) {
        return a * 2;
    });
// a is 200, 400, 600
</code></pre>
</li>
<li><code>std::swap_ranges(begin, end, otherBegin)</code>
<ul>
<li>Swaps the values of each element in two equal sized ranges</li>
</ul>
</li>
<li><code>std::iter_swap(a, b)</code>
<ul>
<li>Swaps the underlying value of two iterators</li>
</ul>
</li>
<li><code>std::shuffle(begin, end, [optional function which returns a randomly selected iterator difference_type or a UniformRandomBitGenerator])</code>
<ul>
<li>Randomly rearranges the elements</li>
</ul>
</li>
<li><code>std::rotate(begin, new_begin, end)</code>
<ul>
<li>Rotates the elements in <code>begin</code> to <code>end</code> to the left so that the iterator <code>new_begin</code> becomes the first element of the resulting range</li>
</ul>
</li>
<li><code>std::sample(begin, end, out, count, gen)</code>
<ul>
<li>Selects <code>count</code> elements at random from <code>begin</code> and <code>end</code> and writes them to <code>out</code> using <code>gen</code> (a random number generator) as a source or randomness</li>
</ul>
</li>
<li><code>std::unique(begin, end)</code>
<ul>
<li>Removes consecutive duplicates from the range</li>
<li>Removal is done by moving all elements to be removed to the back of the iterator range, then returning a new ending iterator that does not include these removed elements</li>
<li><code>std::unique_copy(begin, end, out)</code> - same but does not perform in-place</li>
</ul>
</li>
<li><code>std::remove_if(begin, end, predicate)</code>
<ul>
<li>Removes all elements satisfying the predicate by moving them to the end of the iterator range</li>
<li>Returns an iterator to the first removed element which is also an iterator off the back of the range of remaining elements</li>
</ul>
<pre><code class="language-C++">std::vector v = {100, 200, 300, 400, 500, 600};
const auto new_end = 
    std::remove_if(v.begin(), v.end(), [](auto e) { return e &lt;= 300; });

for(auto num : v) {
    std::cout &lt;&lt; num &lt;&lt; std::endl;
}
// Prints 400, 500, 600, then the remaining numbers (probably: 100, 200, 300)

for(auto it = v.begin(); it != new_end; ++it) {
    std::cout &lt;&lt; *it &lt;&lt; std::endl;
}
// Only prints 400, 500, 600 
</code></pre>
</li>
<li><code>std::partition(begin, end, pred)</code>
<ul>
<li>Partitions a range so that elements that satisfy <code>pred</code> are at the beginning of the range and those that don't are at the end</li>
<li>Returns an iterator to the point at which the range is partitioned</li>
<li><code>std::partition_copy</code> - same idea but not in place</li>
</ul>
</li>
<li><code>std::sort(begin, end, [optional comparator])</code></li>
<li><code>std::stable_sort(being, end, [optional comparator])</code> - sort that guarantees that elements that compare equally are kept in the same order as they were</li>
<li><code>std::lower_bound(begin, end, elem, [optional comparator])</code>
<ul>
<li>Returns an iterator to the first element &gt;= to <code>elem</code> or <code>end</code> of no such element is found</li>
<li>Requires <code>begin</code> and <code>end</code> be sorted or partitioned on <code>val &lt; elem</code> (ascending order)</li>
<li>Think of finding the lower bound of a series of <code>elem</code> within the range</li>
<li>The comparator defines what &lt; means in this context. Will get the first element in which calling the comparator returns <code>false</code>. The comparator returns true if the first argument is ordered before the second.</li>
</ul>
</li>
<li><code>std::upper_bound(begin, end, elem, [optional comparator])</code>
<ul>
<li>Same as lower_bound but finds first element &gt; <code>elem</code> or <code>end</code> if no such element is found</li>
<li>Think of finding the upper bound of a series of <code>elem</code> within the range</li>
</ul>
</li>
<li><code>std::binary_search(begin, end, val, [optional comparator])</code>
<ul>
<li>Returns true if <code>val</code> is present, false otherwise</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">// Requires begin and end be sorted in ascending order
// gets iterator to first iter that equals elem or end if not found
template&lt;typename Iter, typename T&gt;
auto binarySearch(Iter begin, Iter end, T elem) {
    const auto e = std::lower_bound(begin, end, elem);
    return *e == elem ? e : end;
}
</code></pre>
<ul>
<li><code>std::merge(begin, end, begin2, end2, out)</code>
<ul>
<li>Merges two sorted ranges and puts the result starting from the <code>out</code> iterator</li>
</ul>
</li>
<li><code>std::make_heap(begin, end, [optional comparator])</code>
<ul>
<li>Makes the range a max heap</li>
</ul>
</li>
<li><code>std::push_heap(begin, end, elem, [optional comparator])</code>
<ul>
<li>Appends an element to an existing heap</li>
</ul>
</li>
<li><code>std::pop_heap(begin, end, [comparator])</code></li>
<li><code>set_union</code>, <code>set_intersection</code>, <code>set_difference</code>
<ul>
<li>Treats two ranges as sets and performs the set operation</li>
</ul>
</li>
<li><code>max_element</code>, <code>min_element</code>, <code>minmax_element</code>
<ul>
<li>gets the max, min, and min and max, respectively from a range</li>
</ul>
</li>
<li><code>lexicographic_compare(begin, end, begin2, end2, [comparator])</code>
<ul>
<li>returns true if the first range is lexicographically less than the second</li>
</ul>
</li>
</ul>
<p>The following are part of the <code>&lt;numeric&gt;</code> header</p>
<ul>
<li>
<p><code>std::iota(begin, end, start)</code></p>
<ul>
<li>Fills the range with sequentially increasing values starting from <code>start</code></li>
</ul>
</li>
<li>
<p><code>std::accumulate(begin, end, start, [optional operation])</code> - similar to <code>fold_left</code> or <code>reduce</code></p>
<ul>
<li>Sums all the elements in the range with an initial value of <code>start</code></li>
<li>If a binary function is passed, calls that function with the first argument as the current accumulation value (initialized to <code>start</code>) and the second argument as the current value in the range. The returned value becomes the new accumulated value</li>
<li><code>std::reduce</code> is similar to <code>accumulate</code> but it can take an execution policy, and the initial value is optional</li>
</ul>
<pre><code class="language-C++">const std::vector v = {10.0, 5.4, 2, -1.2};
const auto pi_v = std::accumulate(v.begin(), v.end(), 1, [](auto a, auto b) {
    return a * b;
}); // 1 (initial value) * 10 * 5.4 * 2 * -1.2
</code></pre>
</li>
<li>
<p><code>std::partial_sum(begin, end, out, [optional op])</code></p>
<ul>
<li>Same as accumulate except saves each accumulation step as a separate element in <code>out</code></li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../functional/functional_types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../more_templates/intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../functional/functional_types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../more_templates/intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
