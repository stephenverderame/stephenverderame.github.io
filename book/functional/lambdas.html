<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lambdas and Functional - Excursion through C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded "><a href="../intro/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hello_world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../intro/hello_cmake.html"><strong aria-hidden="true">1.2.</strong> Hello CMake</a></li></ol></li><li class="chapter-item expanded "><a href="../guessing_game/gg1.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guessing_game/gg2.html"><strong aria-hidden="true">2.1.</strong> Coding the Guessing Game</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Basics</li><li class="chapter-item expanded "><a href="../basics/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/control_flow.html"><strong aria-hidden="true">3.1.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basics/primitives.html"><strong aria-hidden="true">3.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li><li class="chapter-item expanded "><a href="../basics/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">3.6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">3.7.</strong> Comments and Headers</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/org.html"><strong aria-hidden="true">4.</strong> Getting Organized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/classes.html"><strong aria-hidden="true">4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../organization/struct.html"><strong aria-hidden="true">4.2.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../organization/enums.html"><strong aria-hidden="true">4.3.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../organization/namespaces.html"><strong aria-hidden="true">4.4.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="../oop/intro.html"><strong aria-hidden="true">5.</strong> Classes and OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../oop/overloads.html"><strong aria-hidden="true">5.1.</strong> Friends and Overloads</a></li><li class="chapter-item expanded "><a href="../oop/adt.html"><strong aria-hidden="true">5.2.</strong> Abstract Types and Virtual</a></li><li class="chapter-item expanded "><a href="../oop/inheritance.html"><strong aria-hidden="true">5.3.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../oop/casts.html"><strong aria-hidden="true">5.4.</strong> Casts and Conversions</a></li><li class="chapter-item expanded "><a href="../oop/guidelines.html"><strong aria-hidden="true">5.5.</strong> OOP Guidelines</a></li><li class="chapter-item expanded "><a href="../oop/constructors.html"><strong aria-hidden="true">5.6.</strong> Constructors and Destructors</a></li><li class="chapter-item expanded "><a href="../oop/raii.html"><strong aria-hidden="true">5.7.</strong> RAII</a></li></ol></li><li class="chapter-item expanded "><a href="../exceptions/basics.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exceptions/noexcept.html"><strong aria-hidden="true">6.1.</strong> Noexcept, Strong, and Basic</a></li><li class="chapter-item expanded "><a href="../exceptions/swap.html"><strong aria-hidden="true">6.2.</strong> Swap</a></li></ol></li><li class="chapter-item expanded "><a href="../pointers/intro.html"><strong aria-hidden="true">7.</strong> Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pointers/unique.html"><strong aria-hidden="true">7.1.</strong> Unique Ptr and Deleters</a></li><li class="chapter-item expanded "><a href="../pointers/shared.html"><strong aria-hidden="true">7.2.</strong> Shared and Weak Ptr</a></li><li class="chapter-item expanded "><a href="../pointers/raw.html"><strong aria-hidden="true">7.3.</strong> Raw and Function Pointers</a></li><li class="chapter-item expanded "><a href="../pointers/pimpl.html"><strong aria-hidden="true">7.4.</strong> PIMPL and Polymorphism</a></li><li class="chapter-item expanded "><a href="../pointers/reference_wrapper.html"><strong aria-hidden="true">7.5.</strong> Reference Wrappers</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_containers/intro.html"><strong aria-hidden="true">8.</strong> Basic Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_containers/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../basic_containers/strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../basic_containers/vector.html"><strong aria-hidden="true">8.3.</strong> List of Containers</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Details and More Advanced Topics</li><li class="chapter-item expanded "><a href="../move/intro.html"><strong aria-hidden="true">9.</strong> Move Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../move/values.html"><strong aria-hidden="true">9.1.</strong> Lvalues, Rvalues, and more; Oh My!</a></li><li class="chapter-item expanded "><a href="../move/optimizations.html"><strong aria-hidden="true">9.2.</strong> RVO and NRVO</a></li><li class="chapter-item expanded "><a href="../move/like_move.html"><strong aria-hidden="true">9.3.</strong> std::move and RTTI</a></li></ol></li><li class="chapter-item expanded "><a href="../templates/intro.html"><strong aria-hidden="true">10.</strong> Template Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../templates/special.html"><strong aria-hidden="true">10.1.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="../templates/concepts.html"><strong aria-hidden="true">10.2.</strong> Concepts and Type Traits</a></li><li class="chapter-item expanded "><a href="../templates/forwarding.html"><strong aria-hidden="true">10.3.</strong> Forwarding</a></li><li class="chapter-item expanded "><a href="../templates/type_deductions.html"><strong aria-hidden="true">10.4.</strong> Type Deduction</a></li><li class="chapter-item expanded "><a href="../templates/variadic.html"><strong aria-hidden="true">10.5.</strong> Variadic Templates</a></li><li class="chapter-item expanded "><a href="../templates/iterators.html"><strong aria-hidden="true">10.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../templates/policies.html"><strong aria-hidden="true">10.7.</strong> Customizing STL Containers</a></li></ol></li><li class="chapter-item expanded "><a href="../functional/intro.html"><strong aria-hidden="true">11.</strong> Functional Programming in STL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functional/lambdas.html" class="active"><strong aria-hidden="true">11.1.</strong> Lambdas and Functional</a></li><li class="chapter-item expanded "><a href="../functional/functional_types.html"><strong aria-hidden="true">11.2.</strong> Tuple, Variant, Optional</a></li><li class="chapter-item expanded "><a href="../functional/algorithm.html"><strong aria-hidden="true">11.3.</strong> Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../more_templates/intro.html"><strong aria-hidden="true">12.</strong> Advanced Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../more_templates/constexpr.html"><strong aria-hidden="true">12.1.</strong> Constexpr</a></li><li class="chapter-item expanded "><a href="../more_templates/tmp.html"><strong aria-hidden="true">12.2.</strong> TMP</a></li><li class="chapter-item expanded "><a href="../more_templates/crtp.html"><strong aria-hidden="true">12.3.</strong> CRTP</a></li><li class="chapter-item expanded "><a href="../more_templates/pbd.html"><strong aria-hidden="true">12.4.</strong> PBD Techniques</a></li><li class="chapter-item expanded "><a href="../more_templates/erasure.html"><strong aria-hidden="true">12.5.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="../more_templates/examples.html"><strong aria-hidden="true">12.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/intro.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">13.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/locks.html"><strong aria-hidden="true">13.2.</strong> Locks and Mutexes</a></li><li class="chapter-item expanded "><a href="../concurrency/cond_var.html"><strong aria-hidden="true">13.3.</strong> Condition Variables, Latches, Barriers, and Semaphores</a></li><li class="chapter-item expanded "><a href="../concurrency/async.html"><strong aria-hidden="true">13.4.</strong> Async, Promises, and Futures</a></li><li class="chapter-item expanded "><a href="../concurrency/atomic.html"><strong aria-hidden="true">13.5.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../concurrency/consider.html"><strong aria-hidden="true">13.6.</strong> Considerations and Atomic Memory Orders</a></li><li class="chapter-item expanded "><a href="../concurrency/examples.html"><strong aria-hidden="true">13.7.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp_20/intro.html"><strong aria-hidden="true">14.</strong> C++20</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp_20/concepts.html"><strong aria-hidden="true">14.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../cpp_20/modules.html"><strong aria-hidden="true">14.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../cpp_20/ranges.html"><strong aria-hidden="true">14.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../cpp_20/coroutines.html"><strong aria-hidden="true">14.4.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="../cpp_20/misc.html"><strong aria-hidden="true">14.5.</strong> Other Features</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">In Practice</li><li class="chapter-item expanded "><a href="../testing/tools.html"><strong aria-hidden="true">15.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/intro.html"><strong aria-hidden="true">15.1.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/gtest.html"><strong aria-hidden="true">15.1.1.</strong> GTest</a></li><li class="chapter-item expanded "><a href="../testing/gmock.html"><strong aria-hidden="true">15.1.2.</strong> GMock</a></li><li class="chapter-item expanded "><a href="../testing/gdb.html"><strong aria-hidden="true">15.1.3.</strong> GDB and GProf</a></li><li class="chapter-item expanded "><a href="../testing/valgrind.html"><strong aria-hidden="true">15.1.4.</strong> More Profiling and Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/doxygen.html"><strong aria-hidden="true">15.2.</strong> Doxygen</a></li><li class="chapter-item expanded "><a href="../testing/cmake.html"><strong aria-hidden="true">15.3.</strong> CMake</a></li><li class="chapter-item expanded "><a href="../testing/analysis.html"><strong aria-hidden="true">15.4.</strong> Static Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../project.html"><strong aria-hidden="true">16.</strong> Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swe_tips.html"><strong aria-hidden="true">16.1.</strong> SWE Tips</a></li><li class="chapter-item expanded "><a href="../design_patterns.html"><strong aria-hidden="true">16.2.</strong> Design Patterns</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="../macros.html"><strong aria-hidden="true">17.</strong> Macros and the Compiler</a></li><li class="chapter-item expanded affix "><a href="../resources.html">Further Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Excursion through C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lambdas"><a class="header" href="#lambdas">Lambdas</a></h1>
<p>You've likely seen lambdas in other programming languages, so I'll just get into the C++ specifics.</p>
<p>Lambdas have the syntax:</p>
<pre><code>[]() {

}
</code></pre>
<p>Where <code>[]</code> contains the variables captured by the lambda from the local scope, <code>()</code> encloses the arguments, and <code>{}</code> encloses the code that is part of the lambda. 
Data that is captured is copied into the lambda's <em>closure</em> which is a runtime object that holds copies or references to captured data and is an instance of the
<em>closure class</em> that the lambda belongs to. 
We can think of a lambda as being syntactic sugar for the compiler creating a class which provides an <code>operator()</code>, and instantiating that class like so:</p>
<pre><code class="language-C++">class ClosureClass {
    int myCapture;
public:
    ClosureClass(int myCapture) : myCapture(myCapture) {};
    // think of lambda capture as constructing a member in the closure class

    bool operator()(int myArgument) {
        return myArgument &gt; myCapture;
    }
};

ClosureClass closure(10);
const auto test = closure(20);

// Lambda version:

int myCapture = 10;
const auto lambda = [myCapture](auto arg) {
    return arg &gt; myCapture;
};

const auto test = lambda(20);
</code></pre>
<p>Unlike functions, the arguments in lambdas can be <code>auto</code>, leaving the compiler to deduce their type using the same method it uses to deduce template types. 
The return type is automatically deduced, however it can be manually specified with a trailing return type.</p>
<pre><code class="language-C++">int capture = 10;
const auto lambda2 = [capture](int arg) -&gt; bool {
    return arg &gt; capture;
};
</code></pre>
<p>The variables captured by a lambda are, by default, copied unless you manually request a reference by prepending the variable name with <code>&amp;</code>.<br />
The captured variables are captured once, when the lambda is defined. 
Even though the variables are copied, they are immutable unless you make the lambda a <code>mutable</code> lambda,
which allows the closure to modify the members of the closure class. </p>
<pre><code class="language-C++">int cap = 30;
const auto l2 = [cap]() mutable {
    return --cap;
    // although cap is copied, it cannot be mutated from within the lambda
    // unless you declare the lambda mutable
};

l2();
l2();
const auto r = l2();
// r is 27

cap; // 30

const auto l3 = [&amp;cap]() {
    cap = 20;
    // fine because the closure class member (the reference)
    // isn't changing but the data it refers to is
};

l3();

cap; // 20
</code></pre>
<p>A better way to capture variables is by <em>init-capture</em>. 
This method allows you to move variables into the closure along with making it very clear how each variable is captured. 
It uses the syntax <code>&lt;name&gt; = &lt;expression&gt;</code> where <code>&lt;name&gt;</code> is the name of the variable within the closure that will store the result of <code>&lt;expression&gt;</code>. 
This variable is created by move or copy constructing a new instance of the result of <code>&lt;expression&gt;</code>.</p>
<pre><code class="language-C++">std::unique_ptr&lt;Person&gt; pp;
int num = 0;
Person p;

const auto l4 = [person1 = std::move(pp), num = num, person2 = &amp;p] {
    num; // copied
    person1; // move constructed from pp
    person2; // pointer to p
};
</code></pre>
<p>If we wanted a reference instead of a pointer, we can wrap the data in a <code>std::reference_wrapper&lt;T&gt;</code> using <code>std::ref</code>. 
A <code>std::reference_wrapper</code> provided <em>value semantics</em> (is copyable) for a reference. It is implicitly converted to a <code>T</code> reference, or explicitly with its member function <code>get()</code>. 
It also provides <code>operator()</code> so that if it holds a reference to a callable object, it can directly invoke that callable object without unwrapping it. 
If we wanted a <code>const</code> reference we can create one with <code>std::cref</code>. This is needed because passing a lvalue reference will invoke the copy constructor, and rvalue references will invoke the move constructor. 
Therefore, we wrap the reference in a <code>reference_wrapper</code> which avoids constructing a new instance of the underlying data and instead will construct a new instance of <code>std::reference_wrapper</code>.</p>
<pre><code class="language-C++">const auto l5 = [person3 = std::ref(p)] {
    person3.get().speak();
    const auto name = person3.get().name;
    // person3 is a std::reference_wrapper&lt;Person&gt; not a Person&amp;
    person3.get() = Person();
};
</code></pre>
<p><code>std::reference_wrapper&lt;T&gt;</code> is also useful to allow containers such as <code>std::vector</code> that cannot hold references to be able to do so. 
However <code>std::reference_wrapper</code>, is just, well a <code>reference_wrapper</code> and provides no mechanisms to prevent or check for dangling references. 
In terms of safety, it's not much better than having a container of raw pointers.</p>
<pre><code class="language-C++">std::vector&lt;std::reference_wrapper&lt;int&gt;&gt; nums;

int myNum = 10;
nums.emplace_back(myNum); // emplace forwards arguments to constructor 
// in this case passing an lvalue reference to constructor
// myNum must live at least as long as its reference held in nums

nums.back() = 20;

myNum; //20
</code></pre>
<p>Back to lambdas: there are limitations to what can be captured. 
Static variables cannot be captured and neither can member variables. 
Static variables can be accessed from within a lambda without capturing them, and member variables can be accessed by copying the pointer of the owning instance object.
This means that in both of these cases, the value of the variable will be what the value is at the time the lambda is invoked, and not at the time the lambda is defined.
This is opposite the normal behavior!</p>
<p>Variables in a lambda can be captured by a default capture mode <code>[&amp;] or [=]</code>. 
Default capture modes capture all used variables by reference or by value, respectively. 
You should prefer init capture or enumerating the variables you capture instead of using default capture modes. 
The reason is that default captures make it harder to reason about object lifetimes and realize when certain variables cannot be captured.</p>
<p>Consider we use the default reference capture mode to pass everything by reference. 
You must take care to ensure that the objects you capture outlives the lambda. 
Lambdas are very easy to bring out of the scope they were declared in (say, adding it to a vector)
and thus anything that is captured must live outside the initial scope as well.</p>
<p>To avoid this, you might be tempted to just copy all variables you use with the default copy capture mode. 
But the capture mode <code>[=]</code> to capture by copy doesn't always copy everything you &quot;capture&quot;. 
Remember, when you capture member variables you aren't actually copying them. You are copying the <code>this</code> pointer to the owning object. 
Thus, the default &quot;pass by value&quot; capture is susceptible to the same dangling pointer problem as passing by reference.
Furthermore, using the default copy capture mode might make you think a static variable's value was saved in the closure, however no copy was actually made
and any outside code that mutates the static variable also affects the lambda! 
A static variable &quot;captured&quot; by a default capture mode isn't really captured,
as the code will simply refer to the single instance of the static variable that exists outside the scope of the lambda. 
Therefore, a default capture by value isn't actually capturing everything by value. 
This confusion can be avoided by using <em>init-capture</em>.</p>
<pre><code class="language-C++">class Foo {
private:
    int data;
    Person person;
//...

    // in some member function:
    // bringing the lambda out of the function scope
    callbacks.push_back([=]() {
        return data * 5;
        // data is not copied
        // the this pointer is
        // if this lambda outlives the owning 
        // instance of Foo
        // we'll have a dangling pointer!
    });
    
    // This is what's really happening:
    callbacks.push_back([ptr = this]() {
        return ptr-&gt;data * 5;
    });
    SomeClass c;
    auto p = [=, &amp;c]() {
        // &quot;everything&quot; captured by value except c
    };
    
    // Init capture examples:
    [person = std::move(person), c2 = &amp;c]() {
        // Foo::person is moved to a variable person
        // in the closure
        // c is passed by pointer to a variable c2
        // in the closure
    }
    
}
</code></pre>
<p>The closure class's <code>operator()</code> is by default const. So mutating a captured variable requires declaring your lambda mutable.</p>
<h1 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h1>
<p>Lambdas are a type of callable object, but not the only one. In the header <code>&lt;functional&gt;</code>, the STL provides a generic function class <code>std::function</code> which can wrap any callable object 
(lambdas, function pointers, objects that define <code>operator()</code>, etc.). 
They are copyable and moveable and otherwise work like you might expect from a function. 
They enable us to use higher order programming and to pass function-like objects as values. The syntax for declaring one is as follows:</p>
<pre><code class="language-C++">std::function&lt;ReturnType(Args, ...)&gt;

// example
std::function&lt;void(int, int)&gt;; // takes two integers and returns nothing
std::function&lt;char()&gt;; // returns a char, takes nothing
std::function&lt;int(int, int)&gt;; // returns an int from two ints
</code></pre>
<pre><code class="language-C++">using my_func_t = std::function&lt;int(int, int)&gt;;

int sum(int a, int b) {
    return a + b;
}

struct DivOp {
    int operator()(int a, int b) const {
        return a / b;
    }
};

my_func_t f1 = &amp;sum;
my_func_t f2 = DivOp();
my_func_t f3 = [](auto a, auto b) {
    return a * b;
};
</code></pre>
<p>The syntax <code>ReturnType(Args...)</code> such as <code>int()</code> or <code>char(std::string, int)</code> is the syntax for a function type.
The syntax might be somewhat reminiscent to you of function pointer syntax. You can think of this as the non-pointer function type.</p>
<pre><code class="language-C++">int fun(char c) {
    return c - 'a';
}

using fun_ptr_t = int(*)(char); //function pointer
using fun_val_t = int(char); //function &quot;value&quot;
// I use the term &quot;value&quot;, but functions are not values in C++

fun_ptr_t funPtr1 = &amp;fun;
fun_val_t * funPtr2 = &amp;fun;
</code></pre>
<p>Here are some more <code>std::function</code> examples:</p>
<pre><code class="language-C++">struct Test {
    std::string str;

    void print() const {
        std::cout &lt;&lt; str &lt;&lt; std::endl;
    }
};

std::function&lt;void(const Test&amp;)&gt; func = &amp;Test::print;
Test t = {&quot;Hi&quot;};
func(t); 

std::function&lt;void()&gt; f2 = []() {
    std::cout &lt;&lt; &quot;qwertyuiop&quot; &lt;&lt; std::endl;
};
f2();
</code></pre>
<p>The real power of <code>std::function</code> is to be able to pass callable objects to functions and classes to control behavior. 
However, especially in the case of lambdas, you must be careful not to let a function outlive any references it may use.</p>
<pre><code class="language-C++">/**
* Creates a new container containing only the elements that fell in line
* Order is determined by the function f, which returns true if the first argument should come
*  before the second
*/
template&lt;class Container, typename Element&gt;
auto stalinSort(const Container&amp; container, 
    std::function&lt;bool(const Element&amp;, const Element&amp;)&gt; f) 
    -&gt; std::enable_if_t&lt;std::is_same_v&lt;
        typename std::iterator_traits&lt;decltype(std::declval&lt;Container&gt;().begin())&gt;::value_type,
        Element
    &gt;, Container&gt;
{
    Container result;
    if (container.empty()) return result;
    auto it = container.begin();
    result.push_back(*it);
    it = std::next(it);

    auto last = result.begin();
    for (; it != container.end(); ++it) {
        if (f(*last, *it)) {
            result.push_back(*it);
            // ++last; BAD
            // we cannot just increment last
            // because the container might move 
            // if it needs to reallocate. If this happens
            // last will become invalid
            last = result.begin();
            std::advance(last, result.size() - 1);
        }
    }

    return result;

}

std::vector nums = { 10, 400, 20, 30, 60, 708, -100, 1000 };
auto res = stalinSort&lt;std::vector&lt;int&gt;, int&gt;(nums, [](auto a, auto b) { return a &lt; b; });
// res is 10, 400, 708, 1000
</code></pre>
<h2 id="partial-application-and-bind"><a class="header" href="#partial-application-and-bind">Partial Application and Bind</a></h2>
<p>Generally, lambdas should be preferred to <code>bind</code>, but I do feel it is good to know about. 
Bind can be used to partially apply a callable object.
Partial application is when you supply some, but not all the arguments to a function.
The returned object of a partial application is another callable objects that takes the unspecified arguments.
<code>std::bind</code> takes a callable object, and constructs a <em>bind object</em> from it by copying in the arguments passed to <code>std::bind</code>. 
The bind object works similarly to a closure. 
However, its <code>operator()</code> can only delegate to the callable object that was passed to <code>std::bind</code>. 
The first argument of <code>std::bind</code> is the callable object, if the callable object is a member function then the second argument is a pointer to the
owning instance (or a placeholder). 
Remember, this owning object pointer can really be viewed as the first argument to the function. 
The rest of the arguments are placeholders or parameters bound to the underlying function arguments based on position. 
The arguments passed to <code>std::bind</code> are constructed in the bind object. 
Thus, lvalues are copied into the bind object and rvalues are moved. 
Furthermore, we can use <code>std::placeholders</code> to map arguments of the bind object's <code>operator()</code> to arguments in the underlying callable object. 
Each placeholder has a number that corresponds to the argument index during invocation of the bind object. This is best explained with an example:</p>
<pre><code class="language-C++">class Bar {
public:
    void memberFunction(int a, double &amp; b, char c) {
    }
}
Bar b;
double dub = 0;
auto foo = std::bind(&amp;Bar::memberFunction, &amp;b, 
    5, std::ref(dub), std::placeholders::_1);
// create a bind object for 
// memberFunction belonging to instance b
// to pass a reference, since all variables are 
// copied requires
// wrapping in std::ref()
// all arguments to bind are evaluated at the time 
// of the  call to bind
// the placeholder allows a user to call the bind object 
// with some more arguments

foo('c'); 
// calls b.memberFunction(5, dub, 'c');

char doFoo(std::string name, std::string text);

std::string myStr = &quot;Hello World&quot;;
auto foo2 = std::bind(&amp;doFoo, std::placeholders::_1, myStr);
myStr = &quot;Goodbye&quot;;

char res = foo2(&quot;Joe&quot;); 
// calls doFoo(&quot;Joe&quot;, &quot;Hello World&quot;);

auto foo3 = std::bind(&amp;doFoo, std::placeholders::_2, std::placeholders::_1);
foo3(&quot;Hello&quot;, &quot;World&quot;);
// calls doFoo(&quot;World&quot;, &quot;Hello&quot;)
</code></pre>
<p>References must be wrapped in <code>std::reference_wrapper</code> for the same reason as lambdas. 
Like lambdas, unless you use a <code>reference_wrapper</code>, arguments are evaluated at the call site of <code>std::bind</code>, not at the call site of the bind object.</p>
<pre><code class="language-C++">auto str = &quot;Billy&quot;;
auto foo4 = std::bind(&amp;doFoo, str, std::placeholders::_1);

str = &quot;Joey&quot;;

foo4(&quot;Johns&quot;);
// calls doFoo(&quot;Billy&quot;, &quot;Johns&quot;)

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../functional/intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../functional/functional_types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../functional/intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../functional/functional_types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
