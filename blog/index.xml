<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on</title><link>https://stephenverderame.github.io/blog/</link><description>Recent content in Blog on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 18 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://stephenverderame.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Compiler Enforced Semantic Unit Types</title><link>https://stephenverderame.github.io/blog/unit-types/</link><pubDate>Fri, 18 Aug 2023 00:00:00 +0000</pubDate><guid>https://stephenverderame.github.io/blog/unit-types/</guid><description>Computations of physical values in programming languages can quickly get out of hand due to the complex units that the programmer has to keep track of. Good variable naming and comments can help, but nothing is stopping double run_time_sec from storing a time measured in milliseconds. Furthermore, different functions might use the same value, but measured in different units, requiring manual conversions. Overall, it&amp;rsquo;s just an unpleasant burden placed on the programmer and a cause of many errors.</description></item><item><title>Real-Time, Accurate Collision Detection</title><link>https://stephenverderame.github.io/blog/oort-collisions/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://stephenverderame.github.io/blog/oort-collisions/</guid><description>Accurate collision detection is a vital part of video games and simulation, and fast collision detection is paramount for real-time applications such as games. In high school, building such a fast and accurate collision engine eluded me. This post describes, conceptually, the algorithm I settled upon when developing Project Oort. I will assume a basic familiarity with the problem of collision detection, including bounding spheres and axis-aligned bounding boxes, simple data structures like trees, and the basics of concrete linear algebra including vectors, matrices, and linear transformations.</description></item><item><title>The Case of the Disappearing Shadow: Gradual Shadow Fading</title><link>https://stephenverderame.github.io/blog/oort-shadows/</link><pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate><guid>https://stephenverderame.github.io/blog/oort-shadows/</guid><description>When implementing the cloaking ability for Project Oort, I came upon a somewhat interesting problem: At what point during the gradual disappearing process should the object&amp;rsquo;s shadow disappear?
At first, I just had the object abruptly stop writing to the depth buffer at a certain transparency threshold. This would cause the shadow to simply cut out at an arbitrary point. I didn&amp;rsquo;t like the look of that and decided that I wanted the shadow to fade in and out gradually.</description></item></channel></rss>